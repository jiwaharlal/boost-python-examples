# 1 "/home/maxim/projects/boost-python-examples/01-HelloWorld/hello.cpp"
# 1 "/home/maxim/projects/boost-python-examples/build/01-HelloWorld//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/maxim/projects/boost-python-examples/01-HelloWorld/hello.cpp"
char const* greet()
{
   return "hello, world";
}

# 1 "/usr/local/include/boost/python.hpp" 1 3
# 11 "/usr/local/include/boost/python.hpp" 3
# 1 "/usr/local/include/boost/python/args.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/prefix.hpp" 1 3
# 13 "/usr/local/include/boost/python/detail/prefix.hpp" 3
# 1 "/usr/local/include/boost/python/detail/wrap_python.hpp" 1 3
# 57 "/usr/local/include/boost/python/detail/wrap_python.hpp" 3
# 1 "/usr/include/python2.7/pyconfig.h" 1 3


# 1 "/usr/include/x86_64-linux-gnu/python2.7/pyconfig.h" 1 3 4
# 4 "/usr/include/python2.7/pyconfig.h" 2 3
# 58 "/usr/local/include/boost/python/detail/wrap_python.hpp" 2 3
# 68 "/usr/local/include/boost/python/detail/wrap_python.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 2 3 4
# 69 "/usr/local/include/boost/python/detail/wrap_python.hpp" 2 3
# 82 "/usr/local/include/boost/python/detail/wrap_python.hpp" 3
# 1 "/usr/include/python2.7/patchlevel.h" 1 3
# 83 "/usr/local/include/boost/python/detail/wrap_python.hpp" 2 3
# 168 "/usr/local/include/boost/python/detail/wrap_python.hpp" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wregister"
# 178 "/usr/local/include/boost/python/detail/wrap_python.hpp" 3
# 1 "/usr/include/python2.7/Python.h" 1 3






# 1 "/usr/include/python2.7/patchlevel.h" 1 3
# 8 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pyconfig.h" 1 3
# 9 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pymacconfig.h" 1 3
# 10 "/usr/include/python2.7/Python.h" 2 3
# 19 "/usr/include/python2.7/Python.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 20 "/usr/include/python2.7/Python.h" 2 3
# 33 "/usr/include/python2.7/Python.h" 3
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4


# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 38 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 22 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4




typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
}
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 59 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;




typedef __off64_t off64_t;






typedef __ssize_t ssize_t;
# 80 "/usr/include/stdio.h" 3 4
typedef _G_fpos64_t fpos_t;


typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 162 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;






extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 243 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

  ;
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  ;






extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 715 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64")

                  ;
extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");
# 739 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64")
                                          ;
extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64")
                                                          ;







extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 868 "/usr/include/stdio.h" 3 4
}
# 34 "/usr/include/python2.7/Python.h" 2 3




# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 88 "/usr/include/string.h" 3 4
}
# 98 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 153 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 203 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 223 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 250 "/usr/include/string.h" 3 4
}
# 260 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 300 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 327 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 368 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4
}
# 39 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;





typedef int error_t;




}
# 41 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 36 "/usr/include/c++/7/stdlib.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 1 3
# 229 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/os_defines.h" 1 3
# 534 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/cpu_defines.h" 1 3
# 537 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++config.h" 2 3
# 42 "/usr/include/c++/7/cstdlib" 2 3
# 75 "/usr/include/c++/7/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 157 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 195 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

extern unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));
# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;
# 232 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64")
                     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 763 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/7/cstdlib" 2 3

# 1 "/usr/include/c++/7/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/7/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/7/bits/std_abs.h" 3
# 46 "/usr/include/c++/7/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 100 "/usr/include/c++/7/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/7/cstdlib" 2 3
# 121 "/usr/include/c++/7/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/7/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/7/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/7/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 43 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 270 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 340 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) throw () __asm__ ("" "lseek64")

             ;





extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 391 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")

                    ;
extern ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64")

                     ;
# 407 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw () __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 873 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 998 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off64_t __length) throw () __asm__ ("" "truncate64")

                  __attribute__ ((__nonnull__ (1))) ;





extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1020 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) throw () __asm__ ("" "ftruncate64")
                        ;





extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1038 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1059 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1085 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64")
                       ;





extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1110 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1167 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;







}
# 45 "/usr/include/python2.7/Python.h" 2 3


# 1 "/usr/include/crypt.h" 1 3 4
# 29 "/usr/include/crypt.h" 3 4
extern "C" {


extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));




struct crypt_data
  {
    char keysched[16 * 8];
    char sb0[32768];
    char sb1[32768];
    char sb2[32768];
    char sb3[32768];

    char crypt_3_buf[14];
    char current_salt[2];
    long int current_saltbits;
    int direction, initialized;
  };

extern char *crypt_r (const char *__key, const char *__salt,
        struct crypt_data * __restrict __data)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));

extern void setkey_r (const char *__key,
        struct crypt_data * __restrict __data)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern void encrypt_r (char *__glibc_block, int __edflag,
         struct crypt_data * __restrict __data)
     throw () __attribute__ ((__nonnull__ (1, 3)));


}
# 48 "/usr/include/python2.7/Python.h" 2 3
# 59 "/usr/include/python2.7/Python.h" 3
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 60 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/pyport.h" 1 3



# 1 "/usr/include/python2.7/pyconfig.h" 1 3
# 5 "/usr/include/python2.7/pyport.h" 2 3




# 1 "/usr/include/inttypes.h" 1 3 4
# 27 "/usr/include/inttypes.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 100 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4
# 266 "/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();
# 432 "/usr/include/inttypes.h" 3 4
}
# 10 "/usr/include/python2.7/pyport.h" 2 3
# 159 "/usr/include/python2.7/pyport.h" 3
typedef uintptr_t Py_uintptr_t;
typedef intptr_t Py_intptr_t;
# 183 "/usr/include/python2.7/pyport.h" 3
typedef ssize_t Py_ssize_t;
# 319 "/usr/include/python2.7/pyport.h" 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 320 "/usr/include/python2.7/pyport.h" 2 3





# 1 "/usr/include/c++/7/math.h" 1 3
# 36 "/usr/include/c++/7/math.h" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3


# 1 "/usr/include/c++/7/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "/usr/include/c++/7/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/7/cmath" 2 3
# 1 "/usr/include/c++/7/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/7/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/7/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/usr/include/c++/7/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;




extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ()
                               ;


extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int totalorder (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermag (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;




extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ()
                               ;


extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int totalorderf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;




extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ()
                               ;


extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int totalorderl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ()
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32 __nanf32 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int totalorderf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ()
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64 __nanf64 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int totalorderf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) throw ();


extern int __issignalingf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) throw (); extern _Float128 __acosf128 (_Float128 __x) throw ();

extern _Float128 asinf128 (_Float128 __x) throw (); extern _Float128 __asinf128 (_Float128 __x) throw ();

extern _Float128 atanf128 (_Float128 __x) throw (); extern _Float128 __atanf128 (_Float128 __x) throw ();

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) throw (); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) throw ();


 extern _Float128 cosf128 (_Float128 __x) throw (); extern _Float128 __cosf128 (_Float128 __x) throw ();

 extern _Float128 sinf128 (_Float128 __x) throw (); extern _Float128 __sinf128 (_Float128 __x) throw ();

extern _Float128 tanf128 (_Float128 __x) throw (); extern _Float128 __tanf128 (_Float128 __x) throw ();




extern _Float128 coshf128 (_Float128 __x) throw (); extern _Float128 __coshf128 (_Float128 __x) throw ();

extern _Float128 sinhf128 (_Float128 __x) throw (); extern _Float128 __sinhf128 (_Float128 __x) throw ();

extern _Float128 tanhf128 (_Float128 __x) throw (); extern _Float128 __tanhf128 (_Float128 __x) throw ();



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw (); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw ()
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) throw (); extern _Float128 __acoshf128 (_Float128 __x) throw ();

extern _Float128 asinhf128 (_Float128 __x) throw (); extern _Float128 __asinhf128 (_Float128 __x) throw ();

extern _Float128 atanhf128 (_Float128 __x) throw (); extern _Float128 __atanhf128 (_Float128 __x) throw ();





 extern _Float128 expf128 (_Float128 __x) throw (); extern _Float128 __expf128 (_Float128 __x) throw ();


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) throw (); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) throw ();


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) throw (); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) throw ();


 extern _Float128 logf128 (_Float128 __x) throw (); extern _Float128 __logf128 (_Float128 __x) throw ();


extern _Float128 log10f128 (_Float128 __x) throw (); extern _Float128 __log10f128 (_Float128 __x) throw ();


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) throw (); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) throw (); extern _Float128 __exp10f128 (_Float128 __x) throw ();




extern _Float128 expm1f128 (_Float128 __x) throw (); extern _Float128 __expm1f128 (_Float128 __x) throw ();


extern _Float128 log1pf128 (_Float128 __x) throw (); extern _Float128 __log1pf128 (_Float128 __x) throw ();


extern _Float128 logbf128 (_Float128 __x) throw (); extern _Float128 __logbf128 (_Float128 __x) throw ();




extern _Float128 exp2f128 (_Float128 __x) throw (); extern _Float128 __exp2f128 (_Float128 __x) throw ();


extern _Float128 log2f128 (_Float128 __x) throw (); extern _Float128 __log2f128 (_Float128 __x) throw ();






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 sqrtf128 (_Float128 __x) throw (); extern _Float128 __sqrtf128 (_Float128 __x) throw ();



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) throw ();




extern _Float128 cbrtf128 (_Float128 __x) throw (); extern _Float128 __cbrtf128 (_Float128 __x) throw ();






extern _Float128 ceilf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float128 __nanf128 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) throw (); extern _Float128 __j0f128 (_Float128) throw ();
extern _Float128 j1f128 (_Float128) throw (); extern _Float128 __j1f128 (_Float128) throw ();
extern _Float128 jnf128 (int, _Float128) throw (); extern _Float128 __jnf128 (int, _Float128) throw ();
extern _Float128 y0f128 (_Float128) throw (); extern _Float128 __y0f128 (_Float128) throw ();
extern _Float128 y1f128 (_Float128) throw (); extern _Float128 __y1f128 (_Float128) throw ();
extern _Float128 ynf128 (int, _Float128) throw (); extern _Float128 __ynf128 (int, _Float128) throw ();





extern _Float128 erff128 (_Float128) throw (); extern _Float128 __erff128 (_Float128) throw ();
extern _Float128 erfcf128 (_Float128) throw (); extern _Float128 __erfcf128 (_Float128) throw ();
extern _Float128 lgammaf128 (_Float128) throw (); extern _Float128 __lgammaf128 (_Float128) throw ();




extern _Float128 tgammaf128 (_Float128) throw (); extern _Float128 __tgammaf128 (_Float128) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) throw (); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) throw ();






extern _Float128 rintf128 (_Float128 __x) throw (); extern _Float128 __rintf128 (_Float128 __x) throw ();


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) throw ();






extern _Float128 nextdownf128 (_Float128 __x) throw (); extern _Float128 __nextdownf128 (_Float128 __x) throw ();

extern _Float128 nextupf128 (_Float128 __x) throw (); extern _Float128 __nextupf128 (_Float128 __x) throw ();



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) throw ();



extern _Float128 scalbnf128 (_Float128 __x, int __n) throw (); extern _Float128 __scalbnf128 (_Float128 __x, int __n) throw ();



extern int ilogbf128 (_Float128 __x) throw (); extern int __ilogbf128 (_Float128 __x) throw ();




extern long int llogbf128 (_Float128 __x) throw (); extern long int __llogbf128 (_Float128 __x) throw ();




extern _Float128 scalblnf128 (_Float128 __x, long int __n) throw (); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) throw ();



extern _Float128 nearbyintf128 (_Float128 __x) throw (); extern _Float128 __nearbyintf128 (_Float128 __x) throw ();



extern _Float128 roundf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) throw () __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw (); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw ();






extern long int lrintf128 (_Float128 __x) throw (); extern long int __lrintf128 (_Float128 __x) throw ();
__extension__
extern long long int llrintf128 (_Float128 __x) throw (); extern long long int __llrintf128 (_Float128 __x) throw ();



extern long int lroundf128 (_Float128 __x) throw (); extern long int __lroundf128 (_Float128 __x) throw ();
__extension__
extern long long int llroundf128 (_Float128 __x) throw (); extern long long int __llroundf128 (_Float128 __x) throw ();



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw (); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw ();




extern _Float128 roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern int totalorderf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) throw ();


extern _Float128 getpayloadf128 (const _Float128 *__x) throw (); extern _Float128 __getpayloadf128 (const _Float128 *__x) throw ();


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) throw ();


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) throw ();
# 424 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ()
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32x __nanf32x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int totalorderf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ()
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64x __nanf64x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int totalorderf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 684 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 685 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}

inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 725 "/usr/include/math.h" 3 4
extern "C++" {
# 754 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1205 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (double __x, double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/7/cmath" 2 3
# 77 "/usr/include/c++/7/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/7/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 536 "/usr/include/c++/7/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 957 "/usr/include/c++/7/cmath" 3

}
# 1075 "/usr/include/c++/7/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }



}
# 1917 "/usr/include/c++/7/cmath" 3
}
# 37 "/usr/include/c++/7/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 326 "/usr/include/python2.7/pyport.h" 2 3






# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 68 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 186 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 333 "/usr/include/python2.7/pyport.h" 2 3
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 334 "/usr/include/python2.7/pyport.h" 2 3
# 390 "/usr/include/python2.7/pyport.h" 3
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 213 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "stat64")

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) throw () __asm__ ("" "fstat64")
     __attribute__ ((__nonnull__ (2)));






extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 239 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file, struct stat *__restrict __buf, int __flag) throw () __asm__ ("" "fstatat64")


                 __attribute__ ((__nonnull__ (2, 3)));






extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 263 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "lstat64")


     __attribute__ ((__nonnull__ (1, 2)));





extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
# 406 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) throw () __asm__ ("" "__fxstat64")

     __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__xstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__lxstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename, struct stat *__stat_buf, int __flag) throw () __asm__ ("" "__fxstatat64")


                    __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));
# 530 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
}
# 391 "/usr/include/python2.7/pyport.h" 2 3
# 412 "/usr/include/python2.7/pyport.h" 3
extern "C" {
# 899 "/usr/include/python2.7/pyport.h" 3
}
# 62 "/usr/include/python2.7/Python.h" 2 3
# 80 "/usr/include/python2.7/Python.h" 3
# 1 "/usr/include/python2.7/pymath.h" 1 3



# 1 "/usr/include/python2.7/pyconfig.h" 1 3
# 5 "/usr/include/python2.7/pymath.h" 2 3
# 80 "/usr/include/python2.7/pymath.h" 3
unsigned short _Py_get_387controlword(void);
void _Py_set_387controlword(unsigned short);
# 81 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pymem.h" 1 3
# 11 "/usr/include/python2.7/pymem.h" 3
extern "C" {
# 52 "/usr/include/python2.7/pymem.h" 3
void * PyMem_Malloc(size_t);
void * PyMem_Realloc(void *, size_t);
void PyMem_Free(void *);
# 119 "/usr/include/python2.7/pymem.h" 3
}
# 82 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/object.h" 1 3



extern "C" {
# 106 "/usr/include/python2.7/object.h" 3
typedef struct _object {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
} PyObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;
} PyVarObject;
# 133 "/usr/include/python2.7/object.h" 3
typedef PyObject * (*unaryfunc)(PyObject *);
typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
typedef int (*inquiry)(PyObject *);
typedef Py_ssize_t (*lenfunc)(PyObject *);
typedef int (*coercion)(PyObject **, PyObject **);
typedef PyObject *(*intargfunc)(PyObject *, int) __attribute__((__deprecated__));
typedef PyObject *(*intintargfunc)(PyObject *, int, int) __attribute__((__deprecated__));
typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);
typedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);
typedef int(*intobjargproc)(PyObject *, int, PyObject *);
typedef int(*intintobjargproc)(PyObject *, int, int, PyObject *);
typedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);
typedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);




typedef int (*getreadbufferproc)(PyObject *, int, void **);
typedef int (*getwritebufferproc)(PyObject *, int, void **);
typedef int (*getsegcountproc)(PyObject *, int *);
typedef int (*getcharbufferproc)(PyObject *, int, char **);

typedef Py_ssize_t (*readbufferproc)(PyObject *, Py_ssize_t, void **);
typedef Py_ssize_t (*writebufferproc)(PyObject *, Py_ssize_t, void **);
typedef Py_ssize_t (*segcountproc)(PyObject *, Py_ssize_t *);
typedef Py_ssize_t (*charbufferproc)(PyObject *, Py_ssize_t, char **);



typedef struct bufferinfo {
    void *buf;
    PyObject *obj;
    Py_ssize_t len;
    Py_ssize_t itemsize;

    int readonly;
    int ndim;
    char *format;
    Py_ssize_t *shape;
    Py_ssize_t *strides;
    Py_ssize_t *suboffsets;
    Py_ssize_t smalltable[2];

    void *internal;
} Py_buffer;

typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
# 215 "/usr/include/python2.7/object.h" 3
typedef int (*objobjproc)(PyObject *, PyObject *);
typedef int (*visitproc)(PyObject *, void *);
typedef int (*traverseproc)(PyObject *, visitproc, void *);

typedef struct {
# 228 "/usr/include/python2.7/object.h" 3
    binaryfunc nb_add;
    binaryfunc nb_subtract;
    binaryfunc nb_multiply;
    binaryfunc nb_divide;
    binaryfunc nb_remainder;
    binaryfunc nb_divmod;
    ternaryfunc nb_power;
    unaryfunc nb_negative;
    unaryfunc nb_positive;
    unaryfunc nb_absolute;
    inquiry nb_nonzero;
    unaryfunc nb_invert;
    binaryfunc nb_lshift;
    binaryfunc nb_rshift;
    binaryfunc nb_and;
    binaryfunc nb_xor;
    binaryfunc nb_or;
    coercion nb_coerce;
    unaryfunc nb_int;
    unaryfunc nb_long;
    unaryfunc nb_float;
    unaryfunc nb_oct;
    unaryfunc nb_hex;

    binaryfunc nb_inplace_add;
    binaryfunc nb_inplace_subtract;
    binaryfunc nb_inplace_multiply;
    binaryfunc nb_inplace_divide;
    binaryfunc nb_inplace_remainder;
    ternaryfunc nb_inplace_power;
    binaryfunc nb_inplace_lshift;
    binaryfunc nb_inplace_rshift;
    binaryfunc nb_inplace_and;
    binaryfunc nb_inplace_xor;
    binaryfunc nb_inplace_or;



    binaryfunc nb_floor_divide;
    binaryfunc nb_true_divide;
    binaryfunc nb_inplace_floor_divide;
    binaryfunc nb_inplace_true_divide;


    unaryfunc nb_index;
} PyNumberMethods;

typedef struct {
    lenfunc sq_length;
    binaryfunc sq_concat;
    ssizeargfunc sq_repeat;
    ssizeargfunc sq_item;
    ssizessizeargfunc sq_slice;
    ssizeobjargproc sq_ass_item;
    ssizessizeobjargproc sq_ass_slice;
    objobjproc sq_contains;

    binaryfunc sq_inplace_concat;
    ssizeargfunc sq_inplace_repeat;
} PySequenceMethods;

typedef struct {
    lenfunc mp_length;
    binaryfunc mp_subscript;
    objobjargproc mp_ass_subscript;
} PyMappingMethods;

typedef struct {
    readbufferproc bf_getreadbuffer;
    writebufferproc bf_getwritebuffer;
    segcountproc bf_getsegcount;
    charbufferproc bf_getcharbuffer;
    getbufferproc bf_getbuffer;
    releasebufferproc bf_releasebuffer;
} PyBufferProcs;


typedef void (*freefunc)(void *);
typedef void (*destructor)(PyObject *);
typedef int (*printfunc)(PyObject *, FILE *, int);
typedef PyObject *(*getattrfunc)(PyObject *, char *);
typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
typedef int (*cmpfunc)(PyObject *, PyObject *);
typedef PyObject *(*reprfunc)(PyObject *);
typedef long (*hashfunc)(PyObject *);
typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
typedef PyObject *(*getiterfunc) (PyObject *);
typedef PyObject *(*iternextfunc) (PyObject *);
typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);

typedef struct _typeobject {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;
    const char *tp_name;
    Py_ssize_t tp_basicsize, tp_itemsize;



    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    cmpfunc tp_compare;
    reprfunc tp_repr;



    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;



    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;


    PyBufferProcs *tp_as_buffer;


    long tp_flags;

    const char *tp_doc;



    traverseproc tp_traverse;


    inquiry tp_clear;



    richcmpfunc tp_richcompare;


    Py_ssize_t tp_weaklistoffset;



    getiterfunc tp_iter;
    iternextfunc tp_iternext;


    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    Py_ssize_t tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free;
    inquiry tp_is_gc;
    PyObject *tp_bases;
    PyObject *tp_mro;
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
    destructor tp_del;


    unsigned int tp_version_tag;
# 411 "/usr/include/python2.7/object.h" 3
} PyTypeObject;



typedef struct _heaptypeobject {


    PyTypeObject ht_type;
    PyNumberMethods as_number;
    PyMappingMethods as_mapping;
    PySequenceMethods as_sequence;




    PyBufferProcs as_buffer;
    PyObject *ht_name, *ht_slots;

} PyHeapTypeObject;







int PyType_IsSubtype(PyTypeObject *, PyTypeObject *);



extern PyTypeObject PyType_Type;
extern PyTypeObject PyBaseObject_Type;
extern PyTypeObject PySuper_Type;





int PyType_Ready(PyTypeObject *);
PyObject * PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
PyObject * PyType_GenericNew(PyTypeObject *,
                                               PyObject *, PyObject *);
PyObject * _PyType_Lookup(PyTypeObject *, PyObject *);
PyObject * _PyObject_LookupSpecial(PyObject *, char *, PyObject **);
unsigned int PyType_ClearCache(void);
void PyType_Modified(PyTypeObject *);


int PyObject_Print(PyObject *, FILE *, int);
void _PyObject_Dump(PyObject *);
PyObject * PyObject_Repr(PyObject *);
PyObject * _PyObject_Str(PyObject *);
PyObject * PyObject_Str(PyObject *);


PyObject * PyObject_Unicode(PyObject *);

int PyObject_Compare(PyObject *, PyObject *);
PyObject * PyObject_RichCompare(PyObject *, PyObject *, int);
int PyObject_RichCompareBool(PyObject *, PyObject *, int);
PyObject * PyObject_GetAttrString(PyObject *, const char *);
int PyObject_SetAttrString(PyObject *, const char *, PyObject *);
int PyObject_HasAttrString(PyObject *, const char *);
PyObject * PyObject_GetAttr(PyObject *, PyObject *);
int PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
int PyObject_HasAttr(PyObject *, PyObject *);
PyObject ** _PyObject_GetDictPtr(PyObject *);
PyObject * PyObject_SelfIter(PyObject *);
PyObject * _PyObject_NextNotImplemented(PyObject *);
PyObject * PyObject_GenericGetAttr(PyObject *, PyObject *);
int PyObject_GenericSetAttr(PyObject *,
                                              PyObject *, PyObject *);
long PyObject_Hash(PyObject *);
long PyObject_HashNotImplemented(PyObject *);
int PyObject_IsTrue(PyObject *);
int PyObject_Not(PyObject *);
int PyCallable_Check(PyObject *);
int PyNumber_Coerce(PyObject **, PyObject **);
int PyNumber_CoerceEx(PyObject **, PyObject **);

void PyObject_ClearWeakRefs(PyObject *);


extern int _PyObject_SlotCompare(PyObject *, PyObject *);


PyObject *
_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *);
int
_PyObject_GenericSetAttrWithDict(PyObject *, PyObject *,
                                 PyObject *, PyObject *);







PyObject * PyObject_Dir(PyObject *);



int Py_ReprEnter(PyObject *);
void Py_ReprLeave(PyObject *);


long _Py_HashDouble(double);
long _Py_HashPointer(void*);

typedef struct {
    long prefix;
    long suffix;
} _Py_HashSecret_t;
extern _Py_HashSecret_t _Py_HashSecret;
# 864 "/usr/include/python2.7/object.h" 3
void Py_IncRef(PyObject *);
void Py_DecRef(PyObject *);







extern PyObject _Py_NoneStruct;
# 883 "/usr/include/python2.7/object.h" 3
extern PyObject _Py_NotImplementedStruct;
# 897 "/usr/include/python2.7/object.h" 3
extern int _Py_SwappedOp[];
# 1011 "/usr/include/python2.7/object.h" 3
void _PyTrash_deposit_object(PyObject*);
void _PyTrash_destroy_chain(void);
extern int _PyTrash_delete_nesting;
extern PyObject * _PyTrash_delete_later;


void _PyTrash_thread_deposit_object(PyObject*);
void _PyTrash_thread_destroy_chain(void);
# 1044 "/usr/include/python2.7/object.h" 3
}
# 84 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/objimpl.h" 1 3
# 11 "/usr/include/python2.7/objimpl.h" 3
extern "C" {
# 97 "/usr/include/python2.7/objimpl.h" 3
void * PyObject_Malloc(size_t);
void * PyObject_Realloc(void *, size_t);
void PyObject_Free(void *);
# 150 "/usr/include/python2.7/objimpl.h" 3
PyObject * PyObject_Init(PyObject *, PyTypeObject *);
PyVarObject * PyObject_InitVar(PyVarObject *,
                                                 PyTypeObject *, Py_ssize_t);
PyObject * _PyObject_New(PyTypeObject *);
PyVarObject * _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
# 235 "/usr/include/python2.7/objimpl.h" 3
Py_ssize_t PyGC_Collect(void);
# 244 "/usr/include/python2.7/objimpl.h" 3
PyVarObject * _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
# 255 "/usr/include/python2.7/objimpl.h" 3
union _gc_head;
union _gc_head_old {
    struct {
        union _gc_head_old *gc_next;
        union _gc_head_old *gc_prev;
        Py_ssize_t gc_refs;
    } gc;
    long double dummy;
};


typedef union _gc_head {
    struct {
        union _gc_head *gc_next;
        union _gc_head *gc_prev;
        Py_ssize_t gc_refs;
    } gc;
    double dummy;
    char dummy_padding[sizeof(union _gc_head_old)];
} PyGC_Head;

extern PyGC_Head *_PyGC_generation0;
# 321 "/usr/include/python2.7/objimpl.h" 3
PyObject * _PyObject_GC_Malloc(size_t);
PyObject * _PyObject_GC_New(PyTypeObject *);
PyVarObject * _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
void PyObject_GC_Track(void *);
void PyObject_GC_UnTrack(void *);
void PyObject_GC_Del(void *);
# 367 "/usr/include/python2.7/objimpl.h" 3
}
# 85 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/pydebug.h" 1 3




extern "C" {


extern int Py_DebugFlag;
extern int Py_VerboseFlag;
extern int Py_InteractiveFlag;
extern int Py_InspectFlag;
extern int Py_OptimizeFlag;
extern int Py_NoSiteFlag;
extern int Py_BytesWarningFlag;
extern int Py_UseClassExceptionsFlag;
extern int Py_FrozenFlag;
extern int Py_TabcheckFlag;
extern int Py_UnicodeFlag;
extern int Py_IgnoreEnvironmentFlag;
extern int Py_DivisionWarningFlag;
extern int Py_DontWriteBytecodeFlag;
extern int Py_NoUserSiteDirectory;



extern int _Py_QnewFlag;

extern int Py_Py3kWarningFlag;
extern int Py_HashRandomizationFlag;






void Py_FatalError(const char *message);


}
# 87 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/unicodeobject.h" 1 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 5 "/usr/include/python2.7/unicodeobject.h" 2 3
# 57 "/usr/include/python2.7/unicodeobject.h" 3
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 58 "/usr/include/python2.7/unicodeobject.h" 2 3
# 120 "/usr/include/python2.7/unicodeobject.h" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4





typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 121 "/usr/include/python2.7/unicodeobject.h" 2 3







typedef unsigned int Py_UCS4;
# 137 "/usr/include/python2.7/unicodeobject.h" 3
typedef Py_UCS4 Py_UNICODE;
# 410 "/usr/include/python2.7/unicodeobject.h" 3
extern "C" {




typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    Py_ssize_t length;
    Py_UNICODE *str;
    long hash;
    PyObject *defenc;


} PyUnicodeObject;

extern PyTypeObject PyUnicode_Type;
# 464 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_FromUnicode(
    const Py_UNICODE *u,
    Py_ssize_t size
    );


PyObject* PyUnicodeUCS4_FromStringAndSize(
    const char *u,
    Py_ssize_t size
    );



PyObject* PyUnicodeUCS4_FromString(
    const char *u
    );




Py_UNICODE * PyUnicodeUCS4_AsUnicode(
    PyObject *unicode
    );



Py_ssize_t PyUnicodeUCS4_GetSize(
    PyObject *unicode
    );


Py_UNICODE PyUnicodeUCS4_GetMax(void);
# 511 "/usr/include/python2.7/unicodeobject.h" 3
int PyUnicodeUCS4_Resize(
    PyObject **unicode,
    Py_ssize_t length
    );
# 533 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_FromEncodedObject(
    register PyObject *obj,
    const char *encoding,
    const char *errors
    );
# 552 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_FromObject(
    register PyObject *obj
    );

PyObject * PyUnicodeUCS4_FromFormatV(const char*, va_list);
PyObject * PyUnicodeUCS4_FromFormat(const char*, ...);



PyObject * _PyUnicode_FormatAdvanced(PyObject *obj,
                                                 Py_UNICODE *format_spec,
                                                 Py_ssize_t format_spec_len);
# 574 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_FromWideChar(
    register const wchar_t *w,
    Py_ssize_t size
    );
# 591 "/usr/include/python2.7/unicodeobject.h" 3
Py_ssize_t PyUnicodeUCS4_AsWideChar(
    PyUnicodeObject *unicode,
    register wchar_t *w,
    Py_ssize_t size
    );
# 609 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_FromOrdinal(int ordinal);
# 620 "/usr/include/python2.7/unicodeobject.h" 3
int PyUnicodeUCS4_ClearFreelist(void);
# 656 "/usr/include/python2.7/unicodeobject.h" 3
PyObject * _PyUnicodeUCS4_AsDefaultEncodedString(
    PyObject *, const char *);
# 668 "/usr/include/python2.7/unicodeobject.h" 3
const char* PyUnicodeUCS4_GetDefaultEncoding(void);







int PyUnicodeUCS4_SetDefaultEncoding(
    const char *encoding
    );






PyObject* PyUnicodeUCS4_Decode(
    const char *s,
    Py_ssize_t size,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicodeUCS4_Encode(
    const Py_UNICODE *s,
    Py_ssize_t size,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicodeUCS4_AsEncodedObject(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicodeUCS4_AsEncodedString(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );

PyObject* PyUnicode_BuildEncodingMap(
    PyObject* string
   );




PyObject* PyUnicode_DecodeUTF7(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_DecodeUTF7Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    Py_ssize_t *consumed
    );

PyObject* PyUnicode_EncodeUTF7(
    const Py_UNICODE *data,
    Py_ssize_t length,
    int base64SetO,
    int base64WhiteSpace,
    const char *errors
    );



PyObject* PyUnicodeUCS4_DecodeUTF8(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicodeUCS4_DecodeUTF8Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    Py_ssize_t *consumed
    );

PyObject* PyUnicodeUCS4_AsUTF8String(
    PyObject *unicode
    );

PyObject* PyUnicodeUCS4_EncodeUTF8(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors
    );
# 798 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_DecodeUTF32(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder


    );

PyObject* PyUnicodeUCS4_DecodeUTF32Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder,


    Py_ssize_t *consumed
    );




PyObject* PyUnicodeUCS4_AsUTF32String(
    PyObject *unicode
    );
# 840 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_EncodeUTF32(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors,
    int byteorder
    );
# 872 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_DecodeUTF16(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder


    );

PyObject* PyUnicodeUCS4_DecodeUTF16Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder,


    Py_ssize_t *consumed
    );




PyObject* PyUnicodeUCS4_AsUTF16String(
    PyObject *unicode
    );
# 918 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_EncodeUTF16(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors,
    int byteorder
    );



PyObject* PyUnicodeUCS4_DecodeUnicodeEscape(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicodeUCS4_AsUnicodeEscapeString(
    PyObject *unicode
    );

PyObject* PyUnicodeUCS4_EncodeUnicodeEscape(
    const Py_UNICODE *data,
    Py_ssize_t length
    );



PyObject* PyUnicodeUCS4_DecodeRawUnicodeEscape(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicodeUCS4_AsRawUnicodeEscapeString(
    PyObject *unicode
    );

PyObject* PyUnicodeUCS4_EncodeRawUnicodeEscape(
    const Py_UNICODE *data,
    Py_ssize_t length
    );





PyObject *_PyUnicode_DecodeUnicodeInternal(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );







PyObject* PyUnicodeUCS4_DecodeLatin1(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicodeUCS4_AsLatin1String(
    PyObject *unicode
    );

PyObject* PyUnicodeUCS4_EncodeLatin1(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors
    );







PyObject* PyUnicodeUCS4_DecodeASCII(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicodeUCS4_AsASCIIString(
    PyObject *unicode
    );

PyObject* PyUnicodeUCS4_EncodeASCII(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors
    );
# 1035 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_DecodeCharmap(
    const char *string,
    Py_ssize_t length,
    PyObject *mapping,

    const char *errors
    );

PyObject* PyUnicodeUCS4_AsCharmapString(
    PyObject *unicode,
    PyObject *mapping

    );

PyObject* PyUnicodeUCS4_EncodeCharmap(
    const Py_UNICODE *data,
    Py_ssize_t length,
    PyObject *mapping,

    const char *errors
    );
# 1070 "/usr/include/python2.7/unicodeobject.h" 3
PyObject * PyUnicodeUCS4_TranslateCharmap(
    const Py_UNICODE *data,
    Py_ssize_t length,
    PyObject *table,
    const char *errors
    );
# 1130 "/usr/include/python2.7/unicodeobject.h" 3
int PyUnicodeUCS4_EncodeDecimal(
    Py_UNICODE *s,
    Py_ssize_t length,
    char *output,
    const char *errors
    );
# 1145 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_Concat(
    PyObject *left,
    PyObject *right
    );
# 1161 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_Split(
    PyObject *s,
    PyObject *sep,
    Py_ssize_t maxsplit
    );






PyObject* PyUnicodeUCS4_Splitlines(
    PyObject *s,
    int keepends
    );



PyObject* PyUnicodeUCS4_Partition(
    PyObject *s,
    PyObject *sep
    );




PyObject* PyUnicodeUCS4_RPartition(
    PyObject *s,
    PyObject *sep
    );
# 1205 "/usr/include/python2.7/unicodeobject.h" 3
PyObject* PyUnicodeUCS4_RSplit(
    PyObject *s,
    PyObject *sep,
    Py_ssize_t maxsplit
    );
# 1223 "/usr/include/python2.7/unicodeobject.h" 3
PyObject * PyUnicodeUCS4_Translate(
    PyObject *str,
    PyObject *table,
    const char *errors
    );




PyObject* PyUnicodeUCS4_Join(
    PyObject *separator,
    PyObject *seq
    );




Py_ssize_t PyUnicodeUCS4_Tailmatch(
    PyObject *str,
    PyObject *substr,
    Py_ssize_t start,
    Py_ssize_t end,
    int direction
    );





Py_ssize_t PyUnicodeUCS4_Find(
    PyObject *str,
    PyObject *substr,
    Py_ssize_t start,
    Py_ssize_t end,
    int direction
    );



Py_ssize_t PyUnicodeUCS4_Count(
    PyObject *str,
    PyObject *substr,
    Py_ssize_t start,
    Py_ssize_t end
    );




PyObject * PyUnicodeUCS4_Replace(
    PyObject *str,
    PyObject *substr,
    PyObject *replstr,
    Py_ssize_t maxcount

    );




int PyUnicodeUCS4_Compare(
    PyObject *left,
    PyObject *right
    );
# 1304 "/usr/include/python2.7/unicodeobject.h" 3
PyObject * PyUnicodeUCS4_RichCompare(
    PyObject *left,
    PyObject *right,
    int op
    );




PyObject * PyUnicodeUCS4_Format(
    PyObject *format,
    PyObject *args
    );







int PyUnicodeUCS4_Contains(
    PyObject *container,
    PyObject *element
    );


PyObject * _PyUnicode_XStrip(
    PyUnicodeObject *self,
    int striptype,
    PyObject *sepobj
    );





extern const unsigned char _Py_ascii_whitespace[];
# 1349 "/usr/include/python2.7/unicodeobject.h" 3
int _PyUnicodeUCS4_IsLowercase(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsUppercase(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsTitlecase(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsWhitespace(
    const Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsLinebreak(
    const Py_UNICODE ch
    );

Py_UNICODE _PyUnicodeUCS4_ToLowercase(
    Py_UNICODE ch
    );

Py_UNICODE _PyUnicodeUCS4_ToUppercase(
    Py_UNICODE ch
    );

Py_UNICODE _PyUnicodeUCS4_ToTitlecase(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_ToDecimalDigit(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_ToDigit(
    Py_UNICODE ch
    );

double _PyUnicodeUCS4_ToNumeric(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsDecimalDigit(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsDigit(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsNumeric(
    Py_UNICODE ch
    );

int _PyUnicodeUCS4_IsAlpha(
    Py_UNICODE ch
    );


}
# 89 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/intobject.h" 1 3
# 20 "/usr/include/python2.7/intobject.h" 3
extern "C" {


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    long ob_ival;
} PyIntObject;

extern PyTypeObject PyInt_Type;
# 37 "/usr/include/python2.7/intobject.h" 3
PyObject * PyInt_FromString(char*, char**, int);

PyObject * PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, int);

PyObject * PyInt_FromLong(long);
PyObject * PyInt_FromSize_t(size_t);
PyObject * PyInt_FromSsize_t(Py_ssize_t);
long PyInt_AsLong(PyObject *);
Py_ssize_t PyInt_AsSsize_t(PyObject *);
int _PyInt_AsInt(PyObject *);
unsigned long PyInt_AsUnsignedLongMask(PyObject *);

unsigned long long PyInt_AsUnsignedLongLongMask(PyObject *);


long PyInt_GetMax(void);
# 63 "/usr/include/python2.7/intobject.h" 3
unsigned long PyOS_strtoul(char *, char **, int);
long PyOS_strtol(char *, char **, int);


int PyInt_ClearFreeList(void);





PyObject* _PyInt_Format(PyIntObject* v, int base, int newstyle);



PyObject * _PyInt_FormatAdvanced(PyObject *obj,
          char *format_spec,
          Py_ssize_t format_spec_len);


}
# 90 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/boolobject.h" 1 3





extern "C" {



typedef PyIntObject PyBoolObject;

extern PyTypeObject PyBool_Type;







extern PyIntObject _Py_ZeroStruct, _Py_TrueStruct;
# 31 "/usr/include/python2.7/boolobject.h" 3
PyObject * PyBool_FromLong(long);


}
# 91 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/longobject.h" 1 3



extern "C" {





typedef struct _longobject PyLongObject;

extern PyTypeObject PyLong_Type;





PyObject * PyLong_FromLong(long);
PyObject * PyLong_FromUnsignedLong(unsigned long);
PyObject * PyLong_FromDouble(double);
PyObject * PyLong_FromSize_t(size_t);
PyObject * PyLong_FromSsize_t(Py_ssize_t);
long PyLong_AsLong(PyObject *);
long PyLong_AsLongAndOverflow(PyObject *, int *);
unsigned long PyLong_AsUnsignedLong(PyObject *);
unsigned long PyLong_AsUnsignedLongMask(PyObject *);
Py_ssize_t PyLong_AsSsize_t(PyObject *);
int _PyLong_AsInt(PyObject *);
PyObject * PyLong_GetInfo(void);





extern int _PyLong_DigitValue[256];







double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e);

double PyLong_AsDouble(PyObject *);
PyObject * PyLong_FromVoidPtr(void *);
void * PyLong_AsVoidPtr(PyObject *);


PyObject * PyLong_FromLongLong(long long);
PyObject * PyLong_FromUnsignedLongLong(unsigned long long);
long long PyLong_AsLongLong(PyObject *);
unsigned long long PyLong_AsUnsignedLongLong(PyObject *);
unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *);
long long PyLong_AsLongLongAndOverflow(PyObject *, int *);


PyObject * PyLong_FromString(char *, char **, int);

PyObject * PyLong_FromUnicode(Py_UNICODE*, Py_ssize_t, int);






int _PyLong_Sign(PyObject *v);
# 77 "/usr/include/python2.7/longobject.h" 3
size_t _PyLong_NumBits(PyObject *v);
# 92 "/usr/include/python2.7/longobject.h" 3
PyObject * _PyLong_FromByteArray(
 const unsigned char* bytes, size_t n,
 int little_endian, int is_signed);
# 115 "/usr/include/python2.7/longobject.h" 3
int _PyLong_AsByteArray(PyLongObject* v,
 unsigned char* bytes, size_t n,
 int little_endian, int is_signed);






PyObject * _PyLong_Format(PyObject *aa, int base, int addL, int newstyle);



PyObject * _PyLong_FormatAdvanced(PyObject *obj,
           char *format_spec,
           Py_ssize_t format_spec_len);


}
# 92 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/floatobject.h" 1 3
# 11 "/usr/include/python2.7/floatobject.h" 3
extern "C" {


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    double ob_fval;
} PyFloatObject;

extern PyTypeObject PyFloat_Type;
# 41 "/usr/include/python2.7/floatobject.h" 3
double PyFloat_GetMax(void);
double PyFloat_GetMin(void);
PyObject * PyFloat_GetInfo(void);




PyObject * PyFloat_FromString(PyObject*, char** junk);


PyObject * PyFloat_FromDouble(double);



double PyFloat_AsDouble(PyObject *);






void PyFloat_AsReprString(char*, PyFloatObject *v);






void PyFloat_AsString(char*, PyFloatObject *v);
# 103 "/usr/include/python2.7/floatobject.h" 3
int _PyFloat_Pack4(double x, unsigned char *p, int le);
int _PyFloat_Pack8(double x, unsigned char *p, int le);


int _PyFloat_Digits(char *buf, double v, int *signum);
void _PyFloat_DigitsInit(void);
# 118 "/usr/include/python2.7/floatobject.h" 3
double _PyFloat_Unpack4(const unsigned char *p, int le);
double _PyFloat_Unpack8(const unsigned char *p, int le);


int PyFloat_ClearFreeList(void);



PyObject * _PyFloat_FormatAdvanced(PyObject *obj,
            char *format_spec,
            Py_ssize_t format_spec_len);




PyObject * _Py_double_round(double x, int ndigits);




}
# 93 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/complexobject.h" 1 3





extern "C" {


typedef struct {
    double real;
    double imag;
} Py_complex;
# 24 "/usr/include/python2.7/complexobject.h" 3
Py_complex _Py_c_sum(Py_complex, Py_complex);
Py_complex _Py_c_diff(Py_complex, Py_complex);
Py_complex _Py_c_neg(Py_complex);
Py_complex _Py_c_prod(Py_complex, Py_complex);
Py_complex _Py_c_quot(Py_complex, Py_complex);
Py_complex _Py_c_pow(Py_complex, Py_complex);
double _Py_c_abs(Py_complex);
# 40 "/usr/include/python2.7/complexobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    Py_complex cval;
} PyComplexObject;

extern PyTypeObject PyComplex_Type;




PyObject * PyComplex_FromCComplex(Py_complex);
PyObject * PyComplex_FromDoubles(double real, double imag);

double PyComplex_RealAsDouble(PyObject *op);
double PyComplex_ImagAsDouble(PyObject *op);
Py_complex PyComplex_AsCComplex(PyObject *op);



PyObject * _PyComplex_FormatAdvanced(PyObject *obj,
                                                 char *format_spec,
                                                 Py_ssize_t format_spec_len);


}
# 95 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/rangeobject.h" 1 3






extern "C" {
# 21 "/usr/include/python2.7/rangeobject.h" 3
extern PyTypeObject PyRange_Type;




}
# 97 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/stringobject.h" 1 3






extern "C" {
# 35 "/usr/include/python2.7/stringobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;
    long ob_shash;
    int ob_sstate;
    char ob_sval[1];
# 49 "/usr/include/python2.7/stringobject.h" 3
} PyStringObject;





extern PyTypeObject PyBaseString_Type;
extern PyTypeObject PyString_Type;





PyObject * PyString_FromStringAndSize(const char *, Py_ssize_t);
PyObject * PyString_FromString(const char *);
PyObject * PyString_FromFormatV(const char*, va_list)
    __attribute__((format(printf, 1, 0)));
PyObject * PyString_FromFormat(const char*, ...)
    __attribute__((format(printf, 1, 2)));
Py_ssize_t PyString_Size(PyObject *);
char * PyString_AsString(PyObject *);
PyObject * PyString_Repr(PyObject *, int);
void PyString_Concat(PyObject **, PyObject *);
void PyString_ConcatAndDel(PyObject **, PyObject *);
int _PyString_Resize(PyObject **, Py_ssize_t);
int _PyString_Eq(PyObject *, PyObject*);
PyObject * PyString_Format(PyObject *, PyObject *);
PyObject * _PyString_FormatLong(PyObject*, int, int,
        int, char**, int*);
PyObject * PyString_DecodeEscape(const char *, Py_ssize_t,
         const char *, Py_ssize_t,
         const char *);

void PyString_InternInPlace(PyObject **);
void PyString_InternImmortal(PyObject **);
PyObject * PyString_InternFromString(const char *);
void _Py_ReleaseInternedStrings(void);
# 96 "/usr/include/python2.7/stringobject.h" 3
PyObject * _PyString_Join(PyObject *sep, PyObject *x);






PyObject* PyString_Decode(
    const char *s,
    Py_ssize_t size,
    const char *encoding,
    const char *errors
    );




PyObject* PyString_Encode(
    const char *s,
    Py_ssize_t size,
    const char *encoding,
    const char *errors
    );




PyObject* PyString_AsEncodedObject(
    PyObject *str,
    const char *encoding,
    const char *errors
    );
# 137 "/usr/include/python2.7/stringobject.h" 3
PyObject* PyString_AsEncodedString(
    PyObject *str,
    const char *encoding,
    const char *errors
    );




PyObject* PyString_AsDecodedObject(
    PyObject *str,
    const char *encoding,
    const char *errors
    );
# 160 "/usr/include/python2.7/stringobject.h" 3
PyObject* PyString_AsDecodedString(
    PyObject *str,
    const char *encoding,
    const char *errors
    );







int PyString_AsStringAndSize(
    register PyObject *obj,
    register char **s,
    register Py_ssize_t *len


    );





Py_ssize_t _PyString_InsertThousandsGroupingLocale(char *buffer,
                                  Py_ssize_t n_buffer,
                                  char *digits,
                                  Py_ssize_t n_digits,
                                  Py_ssize_t min_width);




Py_ssize_t _PyString_InsertThousandsGrouping(char *buffer,
                                  Py_ssize_t n_buffer,
                                  char *digits,
                                  Py_ssize_t n_digits,
                                  Py_ssize_t min_width,
                                  const char *grouping,
                                  const char *thousands_sep);



PyObject * _PyBytes_FormatAdvanced(PyObject *obj,
            char *format_spec,
            Py_ssize_t format_spec_len);


}
# 98 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/memoryobject.h" 1 3





extern "C" {


extern PyTypeObject PyMemoryView_Type;
# 19 "/usr/include/python2.7/memoryobject.h" 3
PyObject * PyMemoryView_GetContiguous(PyObject *base,
        int buffertype,
        char fort);
# 54 "/usr/include/python2.7/memoryobject.h" 3
PyObject * PyMemoryView_FromObject(PyObject *base);

PyObject * PyMemoryView_FromBuffer(Py_buffer *info);







typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *base;
    Py_buffer view;
} PyMemoryViewObject;



}
# 99 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/bufferobject.h" 1 3
# 9 "/usr/include/python2.7/bufferobject.h" 3
extern "C" {



extern PyTypeObject PyBuffer_Type;





PyObject * PyBuffer_FromObject(PyObject *base,
                                           Py_ssize_t offset, Py_ssize_t size);
PyObject * PyBuffer_FromReadWriteObject(PyObject *base,
                                                    Py_ssize_t offset,
                                                    Py_ssize_t size);

PyObject * PyBuffer_FromMemory(void *ptr, Py_ssize_t size);
PyObject * PyBuffer_FromReadWriteMemory(void *ptr, Py_ssize_t size);

PyObject * PyBuffer_New(Py_ssize_t size);


}
# 100 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/bytesobject.h" 1 3
# 101 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/bytearrayobject.h" 1 3





extern "C" {
# 22 "/usr/include/python2.7/bytearrayobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;

    int ob_exports;
    Py_ssize_t ob_alloc;
    char *ob_bytes;
} PyByteArrayObject;


extern PyTypeObject PyByteArray_Type;
extern PyTypeObject PyByteArrayIter_Type;






PyObject * PyByteArray_FromObject(PyObject *);
PyObject * PyByteArray_Concat(PyObject *, PyObject *);
PyObject * PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
Py_ssize_t PyByteArray_Size(PyObject *);
char * PyByteArray_AsString(PyObject *);
int PyByteArray_Resize(PyObject *, Py_ssize_t);







extern char _PyByteArray_empty_string[];


}
# 102 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/tupleobject.h" 1 3






extern "C" {
# 24 "/usr/include/python2.7/tupleobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;
    PyObject *ob_item[1];





} PyTupleObject;

extern PyTypeObject PyTuple_Type;





PyObject * PyTuple_New(Py_ssize_t size);
Py_ssize_t PyTuple_Size(PyObject *);
PyObject * PyTuple_GetItem(PyObject *, Py_ssize_t);
int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
PyObject * PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
int _PyTuple_Resize(PyObject **, Py_ssize_t);
PyObject * PyTuple_Pack(Py_ssize_t, ...);
void _PyTuple_MaybeUntrack(PyObject *);
# 56 "/usr/include/python2.7/tupleobject.h" 3
int PyTuple_ClearFreeList(void);


}
# 103 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/listobject.h" 1 3
# 19 "/usr/include/python2.7/listobject.h" 3
extern "C" {


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;

    PyObject **ob_item;
# 38 "/usr/include/python2.7/listobject.h" 3
    Py_ssize_t allocated;
} PyListObject;

extern PyTypeObject PyList_Type;





PyObject * PyList_New(Py_ssize_t size);
Py_ssize_t PyList_Size(PyObject *);
PyObject * PyList_GetItem(PyObject *, Py_ssize_t);
int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
int PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
int PyList_Append(PyObject *, PyObject *);
PyObject * PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
int PyList_Sort(PyObject *);
int PyList_Reverse(PyObject *);
PyObject * PyList_AsTuple(PyObject *);
PyObject * _PyList_Extend(PyListObject *, PyObject *);







}
# 104 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/dictobject.h" 1 3



extern "C" {
# 50 "/usr/include/python2.7/dictobject.h" 3
typedef struct {




    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictEntry;
# 69 "/usr/include/python2.7/dictobject.h" 3
typedef struct _dictobject PyDictObject;
struct _dictobject {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    Py_ssize_t ma_fill;
    Py_ssize_t ma_used;





    Py_ssize_t ma_mask;






    PyDictEntry *ma_table;
    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
    PyDictEntry ma_smalltable[8];
};

extern PyTypeObject PyDict_Type;
extern PyTypeObject PyDictIterKey_Type;
extern PyTypeObject PyDictIterValue_Type;
extern PyTypeObject PyDictIterItem_Type;
extern PyTypeObject PyDictKeys_Type;
extern PyTypeObject PyDictItems_Type;
extern PyTypeObject PyDictValues_Type;
# 109 "/usr/include/python2.7/dictobject.h" 3
PyObject * PyDict_New(void);
PyObject * PyDict_GetItem(PyObject *mp, PyObject *key);
PyObject * _PyDict_GetItemWithError(PyObject *mp, PyObject *key);
int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
int PyDict_DelItem(PyObject *mp, PyObject *key);
int _PyDict_DelItemIf(PyObject *mp, PyObject *key,
                                  int (*predicate)(PyObject *value));

void PyDict_Clear(PyObject *mp);
int PyDict_Next(
    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
int _PyDict_Next(
    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, long *hash);
PyObject * PyDict_Keys(PyObject *mp);
PyObject * PyDict_Values(PyObject *mp);
PyObject * PyDict_Items(PyObject *mp);
Py_ssize_t PyDict_Size(PyObject *mp);
PyObject * PyDict_Copy(PyObject *mp);
int PyDict_Contains(PyObject *mp, PyObject *key);
int _PyDict_Contains(PyObject *mp, PyObject *key, long hash);
PyObject * _PyDict_NewPresized(Py_ssize_t minused);
void _PyDict_MaybeUntrack(PyObject *mp);


int PyDict_Update(PyObject *mp, PyObject *other);






int PyDict_Merge(PyObject *mp,
                                   PyObject *other,
                                   int override);






int PyDict_MergeFromSeq2(PyObject *d,
                                           PyObject *seq2,
                                           int override);

PyObject * PyDict_GetItemString(PyObject *dp, const char *key);
int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
int PyDict_DelItemString(PyObject *dp, const char *key);


}
# 105 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/enumobject.h" 1 3






extern "C" {


extern PyTypeObject PyEnum_Type;
extern PyTypeObject PyReversed_Type;


}
# 106 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/setobject.h" 1 3





extern "C" {
# 24 "/usr/include/python2.7/setobject.h" 3
typedef struct {
    long hash;
    PyObject *key;
} setentry;






typedef struct _setobject PySetObject;
struct _setobject {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;

    Py_ssize_t fill;
    Py_ssize_t used;





    Py_ssize_t mask;





    setentry *table;
    setentry *(*lookup)(PySetObject *so, PyObject *key, long hash);
    setentry smalltable[8];

    long hash;
    PyObject *weakreflist;
};

extern PyTypeObject PySet_Type;
extern PyTypeObject PyFrozenSet_Type;
# 83 "/usr/include/python2.7/setobject.h" 3
PyObject * PySet_New(PyObject *);
PyObject * PyFrozenSet_New(PyObject *);
Py_ssize_t PySet_Size(PyObject *anyset);

int PySet_Clear(PyObject *set);
int PySet_Contains(PyObject *anyset, PyObject *key);
int PySet_Discard(PyObject *set, PyObject *key);
int PySet_Add(PyObject *set, PyObject *key);
int _PySet_Next(PyObject *set, Py_ssize_t *pos, PyObject **key);
int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, long *hash);
PyObject * PySet_Pop(PyObject *set);
int _PySet_Update(PyObject *set, PyObject *iterable);


}
# 107 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/methodobject.h" 1 3






extern "C" {






extern PyTypeObject PyCFunction_Type;



typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,
          PyObject *);
typedef PyObject *(*PyNoArgsFunction)(PyObject *);

PyCFunction PyCFunction_GetFunction(PyObject *);
PyObject * PyCFunction_GetSelf(PyObject *);
int PyCFunction_GetFlags(PyObject *);
# 35 "/usr/include/python2.7/methodobject.h" 3
PyObject * PyCFunction_Call(PyObject *, PyObject *, PyObject *);

struct PyMethodDef {
    const char *ml_name;
    PyCFunction ml_meth;
    int ml_flags;

    const char *ml_doc;
};
typedef struct PyMethodDef PyMethodDef;

PyObject * Py_FindMethod(PyMethodDef[], PyObject *, const char *);


PyObject * PyCFunction_NewEx(PyMethodDef *, PyObject *,
      PyObject *);
# 73 "/usr/include/python2.7/methodobject.h" 3
typedef struct PyMethodChain {
    PyMethodDef *methods;
    struct PyMethodChain *link;
} PyMethodChain;

PyObject * Py_FindMethodInChain(PyMethodChain *, PyObject *,
                                            const char *);

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyMethodDef *m_ml;
    PyObject *m_self;
    PyObject *m_module;
} PyCFunctionObject;

int PyCFunction_ClearFreeList(void);


}
# 108 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/moduleobject.h" 1 3






extern "C" {


extern PyTypeObject PyModule_Type;




PyObject * PyModule_New(const char *);
PyObject * PyModule_GetDict(PyObject *);
char * PyModule_GetName(PyObject *);
char * PyModule_GetFilename(PyObject *);
void _PyModule_Clear(PyObject *);


}
# 109 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/funcobject.h" 1 3






extern "C" {
# 21 "/usr/include/python2.7/funcobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *func_code;
    PyObject *func_globals;
    PyObject *func_defaults;
    PyObject *func_closure;
    PyObject *func_doc;
    PyObject *func_name;
    PyObject *func_dict;
    PyObject *func_weakreflist;
    PyObject *func_module;






} PyFunctionObject;

extern PyTypeObject PyFunction_Type;



PyObject * PyFunction_New(PyObject *, PyObject *);
PyObject * PyFunction_GetCode(PyObject *);
PyObject * PyFunction_GetGlobals(PyObject *);
PyObject * PyFunction_GetModule(PyObject *);
PyObject * PyFunction_GetDefaults(PyObject *);
int PyFunction_SetDefaults(PyObject *, PyObject *);
PyObject * PyFunction_GetClosure(PyObject *);
int PyFunction_SetClosure(PyObject *, PyObject *);
# 67 "/usr/include/python2.7/funcobject.h" 3
extern PyTypeObject PyClassMethod_Type;
extern PyTypeObject PyStaticMethod_Type;

PyObject * PyClassMethod_New(PyObject *);
PyObject * PyStaticMethod_New(PyObject *);


}
# 110 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/classobject.h" 1 3
# 9 "/usr/include/python2.7/classobject.h" 3
extern "C" {


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *cl_bases;
    PyObject *cl_dict;
    PyObject *cl_name;

    PyObject *cl_getattr;
    PyObject *cl_setattr;
    PyObject *cl_delattr;
    PyObject *cl_weakreflist;
} PyClassObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyClassObject *in_class;
    PyObject *in_dict;
    PyObject *in_weakreflist;
} PyInstanceObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *im_func;
    PyObject *im_self;
    PyObject *im_class;
    PyObject *im_weakreflist;
} PyMethodObject;

extern PyTypeObject PyClass_Type, PyInstance_Type, PyMethod_Type;





PyObject * PyClass_New(PyObject *, PyObject *, PyObject *);
PyObject * PyInstance_New(PyObject *, PyObject *,
                                            PyObject *);
PyObject * PyInstance_NewRaw(PyObject *, PyObject *);
PyObject * PyMethod_New(PyObject *, PyObject *, PyObject *);

PyObject * PyMethod_Function(PyObject *);
PyObject * PyMethod_Self(PyObject *);
PyObject * PyMethod_Class(PyObject *);
# 65 "/usr/include/python2.7/classobject.h" 3
PyObject * _PyInstance_Lookup(PyObject *pinst, PyObject *name);
# 76 "/usr/include/python2.7/classobject.h" 3
int PyClass_IsSubclass(PyObject *, PyObject *);

int PyMethod_ClearFreeList(void);


}
# 111 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/fileobject.h" 1 3






extern "C" {


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    FILE *f_fp;
    PyObject *f_name;
    PyObject *f_mode;
    int (*f_close)(FILE *);
    int f_softspace;
    int f_binary;

    char* f_buf;
    char* f_bufend;
    char* f_bufptr;
    char *f_setbuf;
    int f_univ_newline;
    int f_newlinetypes;
    int f_skipnextlf;
    PyObject *f_encoding;
    PyObject *f_errors;
    PyObject *weakreflist;
    int unlocked_count;

    int readable;
    int writable;
} PyFileObject;

extern PyTypeObject PyFile_Type;




PyObject * PyFile_FromString(char *, char *);
void PyFile_SetBufSize(PyObject *, int);
int PyFile_SetEncoding(PyObject *, const char *);
int PyFile_SetEncodingAndErrors(PyObject *, const char *, char *errors);
PyObject * PyFile_FromFile(FILE *, char *, char *,
                                             int (*)(FILE *));
FILE * PyFile_AsFile(PyObject *);
void PyFile_IncUseCount(PyFileObject *);
void PyFile_DecUseCount(PyFileObject *);
PyObject * PyFile_Name(PyObject *);
PyObject * PyFile_GetLine(PyObject *, int);
int PyFile_WriteObject(PyObject *, PyObject *, int);
int PyFile_SoftSpace(PyObject *, int);
int PyFile_WriteString(const char *, PyObject *);
int PyObject_AsFileDescriptor(PyObject *);




extern const char * Py_FileSystemDefaultEncoding;





char *Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);
size_t Py_UniversalNewlineFread(char *, size_t, FILE *, PyObject *);




int _PyFile_SanitizeMode(char *mode);
# 95 "/usr/include/python2.7/fileobject.h" 3
}
# 112 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/cobject.h" 1 3
# 40 "/usr/include/python2.7/cobject.h" 3
extern "C" {


extern PyTypeObject PyCObject_Type;
# 53 "/usr/include/python2.7/cobject.h" 3
PyObject * PyCObject_FromVoidPtr(
 void *cobj, void (*destruct)(void*));







PyObject * PyCObject_FromVoidPtrAndDesc(
 void *cobj, void *desc, void (*destruct)(void*,void*));


void * PyCObject_AsVoidPtr(PyObject *);


void * PyCObject_GetDesc(PyObject *);


void * PyCObject_Import(char *module_name, char *cobject_name);


int PyCObject_SetVoidPtr(PyObject *self, void *cobj);


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    void *cobject;
    void *desc;
    void (*destructor)(void *);
} PyCObject;



}
# 113 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pycapsule.h" 1 3
# 18 "/usr/include/python2.7/pycapsule.h" 3
extern "C" {


extern PyTypeObject PyCapsule_Type;

typedef void (*PyCapsule_Destructor)(PyObject *);




PyObject * PyCapsule_New(
    void *pointer,
    const char *name,
    PyCapsule_Destructor destructor);

void * PyCapsule_GetPointer(PyObject *capsule, const char *name);

PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule);

const char * PyCapsule_GetName(PyObject *capsule);

void * PyCapsule_GetContext(PyObject *capsule);

int PyCapsule_IsValid(PyObject *capsule, const char *name);

int PyCapsule_SetPointer(PyObject *capsule, void *pointer);

int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor);

int PyCapsule_SetName(PyObject *capsule, const char *name);

int PyCapsule_SetContext(PyObject *capsule, void *context);

void * PyCapsule_Import(const char *name, int no_block);


}
# 114 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/traceback.h" 1 3




extern "C" {


struct _frame;



typedef struct _traceback {
 Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
 struct _traceback *tb_next;
 struct _frame *tb_frame;
 int tb_lasti;
 int tb_lineno;
} PyTracebackObject;

int PyTraceBack_Here(struct _frame *);
int PyTraceBack_Print(PyObject *, PyObject *);
int _Py_DisplaySourceLine(PyObject *, const char *, int, int);


extern PyTypeObject PyTraceBack_Type;



}
# 115 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/sliceobject.h" 1 3



extern "C" {




extern PyObject _Py_EllipsisObject;
# 22 "/usr/include/python2.7/sliceobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *start, *stop, *step;
} PySliceObject;

extern PyTypeObject PySlice_Type;
extern PyTypeObject PyEllipsis_Type;



PyObject * PySlice_New(PyObject* start, PyObject* stop,
                                  PyObject* step);
PyObject * _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
int PySlice_GetIndices(PySliceObject *r, Py_ssize_t length,
                                  Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);
int PySlice_GetIndicesEx(PySliceObject *r, Py_ssize_t length,
        Py_ssize_t *start, Py_ssize_t *stop,
        Py_ssize_t *step, Py_ssize_t *slicelength);

int _PySlice_Unpack(PyObject *slice,
                                Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);
Py_ssize_t _PySlice_AdjustIndices(Py_ssize_t length,
                                              Py_ssize_t *start, Py_ssize_t *stop,
                                              Py_ssize_t step);


}
# 116 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/cellobject.h" 1 3





extern "C" {


typedef struct {
 Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
 PyObject *ob_ref;
} PyCellObject;

extern PyTypeObject PyCell_Type;



PyObject * PyCell_New(PyObject *);
PyObject * PyCell_Get(PyObject *);
int PyCell_Set(PyObject *, PyObject *);





}
# 117 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/iterobject.h" 1 3




extern "C" {


extern PyTypeObject PySeqIter_Type;



PyObject * PySeqIter_New(PyObject *);

extern PyTypeObject PyCallIter_Type;



PyObject * PyCallIter_New(PyObject *, PyObject *);

}
# 118 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/genobject.h" 1 3






extern "C" {


struct _frame;

typedef struct {
 Py_ssize_t ob_refcnt; struct _typeobject *ob_type;



 struct _frame *gi_frame;


 int gi_running;


 PyObject *gi_code;


 PyObject *gi_weakreflist;
} PyGenObject;

extern PyTypeObject PyGen_Type;




PyObject * PyGen_New(struct _frame *);
int PyGen_NeedsFinalizing(PyGenObject *);


}
# 119 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/descrobject.h" 1 3




extern "C" {


typedef PyObject *(*getter)(PyObject *, void *);
typedef int (*setter)(PyObject *, PyObject *, void *);

typedef struct PyGetSetDef {
    char *name;
    getter get;
    setter set;
    char *doc;
    void *closure;
} PyGetSetDef;

typedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,
                                 void *wrapped);

typedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,
                                      void *wrapped, PyObject *kwds);

struct wrapperbase {
    char *name;
    int offset;
    void *function;
    wrapperfunc wrapper;
    char *doc;
    int flags;
    PyObject *name_strobj;
};
# 45 "/usr/include/python2.7/descrobject.h" 3
typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; PyTypeObject *d_type; PyObject *d_name;
} PyDescrObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; PyTypeObject *d_type; PyObject *d_name;
    PyMethodDef *d_method;
} PyMethodDescrObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; PyTypeObject *d_type; PyObject *d_name;
    struct PyMemberDef *d_member;
} PyMemberDescrObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; PyTypeObject *d_type; PyObject *d_name;
    PyGetSetDef *d_getset;
} PyGetSetDescrObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; PyTypeObject *d_type; PyObject *d_name;
    struct wrapperbase *d_base;
    void *d_wrapped;
} PyWrapperDescrObject;

extern PyTypeObject PyWrapperDescr_Type;
extern PyTypeObject PyDictProxy_Type;
extern PyTypeObject PyGetSetDescr_Type;
extern PyTypeObject PyMemberDescr_Type;

PyObject * PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
PyObject * PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
PyObject * PyDescr_NewMember(PyTypeObject *,
                                               struct PyMemberDef *);
PyObject * PyDescr_NewGetSet(PyTypeObject *,
                                               struct PyGetSetDef *);
PyObject * PyDescr_NewWrapper(PyTypeObject *,
                                                struct wrapperbase *, void *);


PyObject * PyDictProxy_New(PyObject *);
PyObject * PyWrapper_New(PyObject *, PyObject *);


extern PyTypeObject PyProperty_Type;

}
# 120 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/warnings.h" 1 3



extern "C" {


void _PyWarnings_Init(void);

int PyErr_WarnEx(PyObject *, const char *, Py_ssize_t);
int PyErr_WarnExplicit(PyObject *, const char *, const char *, int,
                                    const char *, PyObject *);
# 20 "/usr/include/python2.7/warnings.h" 3
}
# 121 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/weakrefobject.h" 1 3





extern "C" {



typedef struct _PyWeakReference PyWeakReference;




struct _PyWeakReference {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;





    PyObject *wr_object;


    PyObject *wr_callback;




    long hash;






    PyWeakReference *wr_prev;
    PyWeakReference *wr_next;
};

extern PyTypeObject _PyWeakref_RefType;
extern PyTypeObject _PyWeakref_ProxyType;
extern PyTypeObject _PyWeakref_CallableProxyType;
# 56 "/usr/include/python2.7/weakrefobject.h" 3
PyObject * PyWeakref_NewRef(PyObject *ob,
                                              PyObject *callback);
PyObject * PyWeakref_NewProxy(PyObject *ob,
                                                PyObject *callback);
PyObject * PyWeakref_GetObject(PyObject *ref);

Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head);

void _PyWeakref_ClearRef(PyWeakReference *self);
# 80 "/usr/include/python2.7/weakrefobject.h" 3
}
# 122 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/codecs.h" 1 3



extern "C" {
# 26 "/usr/include/python2.7/codecs.h" 3
int PyCodec_Register(
       PyObject *search_function
       );
# 48 "/usr/include/python2.7/codecs.h" 3
PyObject * _PyCodec_Lookup(
       const char *encoding
       );
# 62 "/usr/include/python2.7/codecs.h" 3
PyObject * PyCodec_Encode(
       PyObject *object,
       const char *encoding,
       const char *errors
       );
# 78 "/usr/include/python2.7/codecs.h" 3
PyObject * PyCodec_Decode(
       PyObject *object,
       const char *encoding,
       const char *errors
       );
# 97 "/usr/include/python2.7/codecs.h" 3
PyObject * _PyCodec_LookupTextEncoding(
       const char *encoding,
       const char *alternate_command
       );

PyObject * _PyCodec_EncodeText(
       PyObject *object,
       const char *encoding,
       const char *errors
       );

PyObject * _PyCodec_DecodeText(
       PyObject *object,
       const char *encoding,
       const char *errors
       );




PyObject * _PyCodecInfo_GetIncrementalDecoder(
       PyObject *codec_info,
       const char *errors
       );

PyObject * _PyCodecInfo_GetIncrementalEncoder(
       PyObject *codec_info,
       const char *errors
       );
# 139 "/usr/include/python2.7/codecs.h" 3
PyObject * PyCodec_Encoder(
       const char *encoding
       );



PyObject * PyCodec_Decoder(
       const char *encoding
       );



PyObject * PyCodec_IncrementalEncoder(
       const char *encoding,
       const char *errors
       );



PyObject * PyCodec_IncrementalDecoder(
       const char *encoding,
       const char *errors
       );



PyObject * PyCodec_StreamReader(
       const char *encoding,
       PyObject *stream,
       const char *errors
       );



PyObject * PyCodec_StreamWriter(
       const char *encoding,
       PyObject *stream,
       const char *errors
       );
# 187 "/usr/include/python2.7/codecs.h" 3
int PyCodec_RegisterError(const char *name, PyObject *error);




PyObject * PyCodec_LookupError(const char *name);


PyObject * PyCodec_StrictErrors(PyObject *exc);


PyObject * PyCodec_IgnoreErrors(PyObject *exc);


PyObject * PyCodec_ReplaceErrors(PyObject *exc);


PyObject * PyCodec_XMLCharRefReplaceErrors(PyObject *exc);


PyObject * PyCodec_BackslashReplaceErrors(PyObject *exc);


}
# 124 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pyerrors.h" 1 3



extern "C" {




typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *dict;
    PyObject *args;
    PyObject *message;
} PyBaseExceptionObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *dict;
    PyObject *args;
    PyObject *message;
    PyObject *msg;
    PyObject *filename;
    PyObject *lineno;
    PyObject *offset;
    PyObject *text;
    PyObject *print_file_and_line;
} PySyntaxErrorObject;


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *dict;
    PyObject *args;
    PyObject *message;
    PyObject *encoding;
    PyObject *object;
    Py_ssize_t start;
    Py_ssize_t end;
    PyObject *reason;
} PyUnicodeErrorObject;


typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *dict;
    PyObject *args;
    PyObject *message;
    PyObject *code;
} PySystemExitObject;

typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    PyObject *dict;
    PyObject *args;
    PyObject *message;
    PyObject *myerrno;
    PyObject *strerror;
    PyObject *filename;
} PyEnvironmentErrorObject;
# 76 "/usr/include/python2.7/pyerrors.h" 3
void PyErr_SetNone(PyObject *);
void PyErr_SetObject(PyObject *, PyObject *);
void PyErr_SetString(PyObject *, const char *);
PyObject * PyErr_Occurred(void);
void PyErr_Clear(void);
void PyErr_Fetch(PyObject **, PyObject **, PyObject **);
void PyErr_Restore(PyObject *, PyObject *, PyObject *);
# 91 "/usr/include/python2.7/pyerrors.h" 3
int PyErr_GivenExceptionMatches(PyObject *, PyObject *);
int PyErr_ExceptionMatches(PyObject *);
void PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);
void _PyErr_ReplaceException(PyObject *, PyObject *, PyObject *);
# 119 "/usr/include/python2.7/pyerrors.h" 3
extern PyObject * PyExc_BaseException;
extern PyObject * PyExc_Exception;
extern PyObject * PyExc_StopIteration;
extern PyObject * PyExc_GeneratorExit;
extern PyObject * PyExc_StandardError;
extern PyObject * PyExc_ArithmeticError;
extern PyObject * PyExc_LookupError;

extern PyObject * PyExc_AssertionError;
extern PyObject * PyExc_AttributeError;
extern PyObject * PyExc_EOFError;
extern PyObject * PyExc_FloatingPointError;
extern PyObject * PyExc_EnvironmentError;
extern PyObject * PyExc_IOError;
extern PyObject * PyExc_OSError;
extern PyObject * PyExc_ImportError;
extern PyObject * PyExc_IndexError;
extern PyObject * PyExc_KeyError;
extern PyObject * PyExc_KeyboardInterrupt;
extern PyObject * PyExc_MemoryError;
extern PyObject * PyExc_NameError;
extern PyObject * PyExc_OverflowError;
extern PyObject * PyExc_RuntimeError;
extern PyObject * PyExc_NotImplementedError;
extern PyObject * PyExc_SyntaxError;
extern PyObject * PyExc_IndentationError;
extern PyObject * PyExc_TabError;
extern PyObject * PyExc_ReferenceError;
extern PyObject * PyExc_SystemError;
extern PyObject * PyExc_SystemExit;
extern PyObject * PyExc_TypeError;
extern PyObject * PyExc_UnboundLocalError;
extern PyObject * PyExc_UnicodeError;
extern PyObject * PyExc_UnicodeEncodeError;
extern PyObject * PyExc_UnicodeDecodeError;
extern PyObject * PyExc_UnicodeTranslateError;
extern PyObject * PyExc_ValueError;
extern PyObject * PyExc_ZeroDivisionError;







extern PyObject * PyExc_BufferError;

extern PyObject * PyExc_MemoryErrorInst;
extern PyObject * PyExc_RecursionErrorInst;


extern PyObject * PyExc_Warning;
extern PyObject * PyExc_UserWarning;
extern PyObject * PyExc_DeprecationWarning;
extern PyObject * PyExc_PendingDeprecationWarning;
extern PyObject * PyExc_SyntaxWarning;
extern PyObject * PyExc_RuntimeWarning;
extern PyObject * PyExc_FutureWarning;
extern PyObject * PyExc_ImportWarning;
extern PyObject * PyExc_UnicodeWarning;
extern PyObject * PyExc_BytesWarning;




int PyErr_BadArgument(void);
PyObject * PyErr_NoMemory(void);
PyObject * PyErr_SetFromErrno(PyObject *);
PyObject * PyErr_SetFromErrnoWithFilenameObject(
    PyObject *, PyObject *);
PyObject * PyErr_SetFromErrnoWithFilename(
    PyObject *, const char *);





PyObject * PyErr_Format(PyObject *, const char *, ...)
                        __attribute__((format(printf, 2, 3)));
# 217 "/usr/include/python2.7/pyerrors.h" 3
void PyErr_BadInternalCall(void);
void _PyErr_BadInternalCall(const char *filename, int lineno);





PyObject * PyErr_NewException(
    char *name, PyObject *base, PyObject *dict);
PyObject * PyErr_NewExceptionWithDoc(
    char *name, char *doc, PyObject *base, PyObject *dict);
void PyErr_WriteUnraisable(PyObject *);


int PyErr_CheckSignals(void);
void PyErr_SetInterrupt(void);


int PySignal_SetWakeupFd(int fd);


void PyErr_SyntaxLocation(const char *, int);
PyObject * PyErr_ProgramText(const char *, int);






PyObject * PyUnicodeDecodeError_Create(
    const char *, const char *, Py_ssize_t, Py_ssize_t, Py_ssize_t, const char *);


PyObject * PyUnicodeEncodeError_Create(
    const char *, const Py_UNICODE *, Py_ssize_t, Py_ssize_t, Py_ssize_t, const char *);


PyObject * PyUnicodeTranslateError_Create(
    const Py_UNICODE *, Py_ssize_t, Py_ssize_t, Py_ssize_t, const char *);


PyObject * PyUnicodeEncodeError_GetEncoding(PyObject *);
PyObject * PyUnicodeDecodeError_GetEncoding(PyObject *);


PyObject * PyUnicodeEncodeError_GetObject(PyObject *);
PyObject * PyUnicodeDecodeError_GetObject(PyObject *);
PyObject * PyUnicodeTranslateError_GetObject(PyObject *);



int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *);
int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *);
int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *);



int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t);
int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t);
int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t);



int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *);
int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *);
int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *);



int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t);
int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t);
int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);


PyObject * PyUnicodeEncodeError_GetReason(PyObject *);
PyObject * PyUnicodeDecodeError_GetReason(PyObject *);
PyObject * PyUnicodeTranslateError_GetReason(PyObject *);



int PyUnicodeEncodeError_SetReason(
    PyObject *, const char *);
int PyUnicodeDecodeError_SetReason(
    PyObject *, const char *);
int PyUnicodeTranslateError_SetReason(
    PyObject *, const char *);
# 321 "/usr/include/python2.7/pyerrors.h" 3
int PyOS_snprintf(char *str, size_t size, const char *format, ...)
                        __attribute__((format(printf, 3, 4)));
int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
                        __attribute__((format(printf, 3, 0)));


}
# 125 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/pystate.h" 1 3







extern "C" {




struct _ts;
struct _is;

typedef struct _is {

    struct _is *next;
    struct _ts *tstate_head;

    PyObject *modules;
    PyObject *sysdict;
    PyObject *builtins;
    PyObject *modules_reloading;

    PyObject *codec_search_path;
    PyObject *codec_search_cache;
    PyObject *codec_error_registry;


    int dlopenflags;





} PyInterpreterState;




struct _frame;


typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
# 56 "/usr/include/python2.7/pystate.h" 3
typedef struct _ts {


    struct _ts *next;
    PyInterpreterState *interp;

    struct _frame *frame;
    int recursion_depth;



    int tracing;
    int use_tracing;

    Py_tracefunc c_profilefunc;
    Py_tracefunc c_tracefunc;
    PyObject *c_profileobj;
    PyObject *c_traceobj;

    PyObject *curexc_type;
    PyObject *curexc_value;
    PyObject *curexc_traceback;

    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;

    PyObject *dict;







    int tick_counter;

    int gilstate_counter;

    PyObject *async_exc;
    long thread_id;

    int trash_delete_nesting;
    PyObject *trash_delete_later;



} PyThreadState;


PyInterpreterState * PyInterpreterState_New(void);
void PyInterpreterState_Clear(PyInterpreterState *);
void PyInterpreterState_Delete(PyInterpreterState *);

PyThreadState * PyThreadState_New(PyInterpreterState *);
PyThreadState * _PyThreadState_Prealloc(PyInterpreterState *);
void _PyThreadState_Init(PyThreadState *);
void PyThreadState_Clear(PyThreadState *);
void PyThreadState_Delete(PyThreadState *);

void PyThreadState_DeleteCurrent(void);


PyThreadState * PyThreadState_Get(void);
PyThreadState * PyThreadState_Swap(PyThreadState *);
PyObject * PyThreadState_GetDict(void);
int PyThreadState_SetAsyncExc(long, PyObject *);




extern PyThreadState * _PyThreadState_Current;







typedef
    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
        PyGILState_STATE;
# 160 "/usr/include/python2.7/pystate.h" 3
PyGILState_STATE PyGILState_Ensure(void);
# 170 "/usr/include/python2.7/pystate.h" 3
void PyGILState_Release(PyGILState_STATE);







PyThreadState * PyGILState_GetThisThreadState(void);




PyObject * _PyThread_CurrentFrames(void);



PyInterpreterState * PyInterpreterState_Head(void);
PyInterpreterState * PyInterpreterState_Next(PyInterpreterState *);
PyThreadState * PyInterpreterState_ThreadHead(PyInterpreterState *);
PyThreadState * PyThreadState_Next(PyThreadState *);

typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);


extern PyThreadFrameGetter _PyThreadState_GetFrame;


}
# 127 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/pyarena.h" 1 3







extern "C" {


  typedef struct _arena PyArena;
# 35 "/usr/include/python2.7/pyarena.h" 3
  PyArena * PyArena_New(void);
  void PyArena_Free(PyArena *);
# 50 "/usr/include/python2.7/pyarena.h" 3
  void * PyArena_Malloc(PyArena *, size_t size);





  int PyArena_AddPyObject(PyArena *, PyObject *);


}
# 129 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/modsupport.h" 1 3




extern "C" {
# 23 "/usr/include/python2.7/modsupport.h" 3
PyObject * _Py_VaBuildValue_SizeT(const char *, va_list);


int PyArg_Parse(PyObject *, const char *, ...);
int PyArg_ParseTuple(PyObject *, const char *, ...) ;
int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *,
                                                  const char *, char **, ...);
int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
PyObject * Py_BuildValue(const char *, ...);
PyObject * _Py_BuildValue_SizeT(const char *, ...);
int _PyArg_NoKeywords(const char *funcname, PyObject *kw);

int PyArg_VaParse(PyObject *, const char *, va_list);
int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *,
                                                  const char *, char **, va_list);
PyObject * Py_VaBuildValue(const char *, va_list);

int PyModule_AddObject(PyObject *, const char *, PyObject *);
int PyModule_AddIntConstant(PyObject *, const char *, long);
int PyModule_AddStringConstant(PyObject *, const char *, const char *);
# 117 "/usr/include/python2.7/modsupport.h" 3
PyObject * Py_InitModule4_64(const char *name, PyMethodDef *methods,
                                      const char *doc, PyObject *self,
                                      int apiver);
# 129 "/usr/include/python2.7/modsupport.h" 3
extern char * _Py_PackageContext;


}
# 130 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pythonrun.h" 1 3






extern "C" {
# 18 "/usr/include/python2.7/pythonrun.h" 3
typedef struct {
    int cf_flags;
} PyCompilerFlags;

void Py_SetProgramName(char *);
char * Py_GetProgramName(void);

void Py_SetPythonHome(char *);
char * Py_GetPythonHome(void);

void Py_Initialize(void);
void Py_InitializeEx(int);
void Py_Finalize(void);
int Py_IsInitialized(void);
PyThreadState * Py_NewInterpreter(void);
void Py_EndInterpreter(PyThreadState *);

int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
int PyRun_AnyFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
int PyRun_SimpleFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
int PyRun_InteractiveOneFlags(FILE *, const char *, PyCompilerFlags *);
int PyRun_InteractiveLoopFlags(FILE *, const char *, PyCompilerFlags *);

struct _mod * PyParser_ASTFromString(const char *, const char *,
                                                 int, PyCompilerFlags *flags,
                                                 PyArena *);
struct _mod * PyParser_ASTFromFile(FILE *, const char *, int,
                                               char *, char *,
                                               PyCompilerFlags *, int *,
                                               PyArena *);




struct _node * PyParser_SimpleParseStringFlags(const char *, int,
                                                          int);
struct _node * PyParser_SimpleParseFileFlags(FILE *, const char *,
                                                        int, int);

PyObject * PyRun_StringFlags(const char *, int, PyObject *,
                                         PyObject *, PyCompilerFlags *);

PyObject * PyRun_FileExFlags(FILE *, const char *, int,
                                         PyObject *, PyObject *, int,
                                         PyCompilerFlags *);


PyObject * Py_CompileStringFlags(const char *, const char *, int,
                                             PyCompilerFlags *);
struct symtable * Py_SymtableString(const char *, const char *, int);

void PyErr_Print(void);
void PyErr_PrintEx(int);
void PyErr_Display(PyObject *, PyObject *, PyObject *);

int Py_AtExit(void (*func)(void));

void Py_Exit(int);

int Py_FdIsInteractive(FILE *, const char *);


int Py_Main(int argc, char **argv);
# 103 "/usr/include/python2.7/pythonrun.h" 3
char * Py_GetProgramFullPath(void);
char * Py_GetPrefix(void);
char * Py_GetExecPrefix(void);
char * Py_GetPath(void);


const char * Py_GetVersion(void);
const char * Py_GetPlatform(void);
const char * Py_GetCopyright(void);
const char * Py_GetCompiler(void);
const char * Py_GetBuildInfo(void);
const char * Py_SubversionRevision(void);
const char * Py_SubversionShortBranch(void);
const char * _Py_gitidentifier(void);
const char * _Py_gitversion(void);


PyObject * _PyBuiltin_Init(void);
PyObject * _PySys_Init(void);
void _PyImport_Init(void);
void _PyExc_Init(void);
void _PyImportHooks_Init(void);
int _PyFrame_Init(void);
int _PyInt_Init(void);
int _PyLong_Init(void);
void _PyFloat_Init(void);
int PyByteArray_Init(void);
void _PyRandom_Init(void);


void _PyExc_Fini(void);
void _PyImport_Fini(void);
void PyMethod_Fini(void);
void PyFrame_Fini(void);
void PyCFunction_Fini(void);
void PyDict_Fini(void);
void PyTuple_Fini(void);
void PyList_Fini(void);
void PySet_Fini(void);
void PyString_Fini(void);
void PyInt_Fini(void);
void PyFloat_Fini(void);
void PyOS_FiniInterrupts(void);
void PyByteArray_Fini(void);
void _PyRandom_Fini(void);


char * PyOS_Readline(FILE *, FILE *, char *);
extern int (*PyOS_InputHook)(void);
extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, char *);
extern PyThreadState* _PyOS_ReadlineTState;
# 171 "/usr/include/python2.7/pythonrun.h" 3
typedef void (*PyOS_sighandler_t)(int);
PyOS_sighandler_t PyOS_getsig(int);
PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t);


int _PyOS_URandom (void *buffer, Py_ssize_t size);


}
# 131 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/ceval.h" 1 3



extern "C" {





PyObject * PyEval_CallObjectWithKeywords(
    PyObject *, PyObject *, PyObject *);





PyObject * PyEval_CallFunction(PyObject *obj,
                                           const char *format, ...);
PyObject * PyEval_CallMethod(PyObject *obj,
                                         const char *methodname,
                                         const char *format, ...);

void PyEval_SetProfile(Py_tracefunc, PyObject *);
void PyEval_SetTrace(Py_tracefunc, PyObject *);

struct _frame;

PyObject * PyEval_GetBuiltins(void);
PyObject * PyEval_GetGlobals(void);
PyObject * PyEval_GetLocals(void);
struct _frame * PyEval_GetFrame(void);
int PyEval_GetRestricted(void);




int PyEval_MergeCompilerFlags(PyCompilerFlags *cf);

int Py_FlushLine(void);

int Py_AddPendingCall(int (*func)(void *), void *arg);
int Py_MakePendingCalls(void);


void Py_SetRecursionLimit(int);
int Py_GetRecursionLimit(void);






int _Py_CheckRecursiveCall(const char *where);
extern int _Py_CheckRecursionLimit;






const char * PyEval_GetFuncName(PyObject *);
const char * PyEval_GetFuncDesc(PyObject *);

PyObject * PyEval_GetCallStats(PyObject *);
PyObject * PyEval_EvalFrame(struct _frame *);
PyObject * PyEval_EvalFrameEx(struct _frame *f, int exc);


extern volatile int _Py_Ticker;
extern int _Py_CheckInterval;
# 117 "/usr/include/python2.7/ceval.h" 3
PyThreadState * PyEval_SaveThread(void);
void PyEval_RestoreThread(PyThreadState *);



int PyEval_ThreadsInitialized(void);
void PyEval_InitThreads(void);
void PyEval_AcquireLock(void);
void PyEval_ReleaseLock(void);
void PyEval_AcquireThread(PyThreadState *tstate);
void PyEval_ReleaseThread(PyThreadState *tstate);
void PyEval_ReInitThreads(void);
# 147 "/usr/include/python2.7/ceval.h" 3
int _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *);



}
# 132 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/sysmodule.h" 1 3






extern "C" {


PyObject * PySys_GetObject(char *);
int PySys_SetObject(char *, PyObject *);
FILE * PySys_GetFile(char *, FILE *);
void PySys_SetArgv(int, char **);
void PySys_SetArgvEx(int, char **, int);
void PySys_SetPath(char *);

void PySys_WriteStdout(const char *format, ...)
   __attribute__((format(printf, 1, 2)));
void PySys_WriteStderr(const char *format, ...)
   __attribute__((format(printf, 1, 2)));

void PySys_ResetWarnOptions(void);
void PySys_AddWarnOption(char *);
int PySys_HasWarnOptions(void);

size_t _PySys_GetSizeOf(PyObject *);


}
# 133 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/intrcheck.h" 1 3




extern "C" {


int PyOS_InterruptOccurred(void);
void PyOS_InitInterrupts(void);
void PyOS_AfterFork(void);


}
# 134 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/import.h" 1 3






extern "C" {


long PyImport_GetMagicNumber(void);
PyObject * PyImport_ExecCodeModule(char *name, PyObject *co);
PyObject * PyImport_ExecCodeModuleEx(
 char *name, PyObject *co, char *pathname);
PyObject * PyImport_GetModuleDict(void);
PyObject * PyImport_AddModule(const char *name);
PyObject * PyImport_ImportModule(const char *name);
PyObject * PyImport_ImportModuleNoBlock(const char *);
PyObject * PyImport_ImportModuleLevel(char *name,
 PyObject *globals, PyObject *locals, PyObject *fromlist, int level);




PyObject * PyImport_GetImporter(PyObject *path);
PyObject * PyImport_Import(PyObject *name);
PyObject * PyImport_ReloadModule(PyObject *m);
void PyImport_Cleanup(void);
int PyImport_ImportFrozenModule(char *);


void _PyImport_AcquireLock(void);
int _PyImport_ReleaseLock(void);





struct filedescr * _PyImport_FindModule(
 const char *, PyObject *, char *, size_t, FILE **, PyObject **);
int _PyImport_IsScript(struct filedescr *);
void _PyImport_ReInitLock(void);

PyObject * _PyImport_FindExtension(char *, char *);
PyObject * _PyImport_FixupExtension(char *, char *);

struct _inittab {
    char *name;
    void (*initfunc)(void);
};

extern PyTypeObject PyNullImporter_Type;
extern struct _inittab * PyImport_Inittab;

int PyImport_AppendInittab(const char *name, void (*initfunc)(void));
int PyImport_ExtendInittab(struct _inittab *newtab);

struct _frozen {
    char *name;
    unsigned char *code;
    int size;
};




extern struct _frozen * PyImport_FrozenModules;


}
# 135 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/abstract.h" 1 3



extern "C" {
# 231 "/usr/include/python2.7/abstract.h" 3
     int PyObject_Cmp(PyObject *o1, PyObject *o2, int *result);
# 304 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyObject_Call(PyObject *callable_object,
                                         PyObject *args, PyObject *kw);
# 314 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyObject_CallObject(PyObject *callable_object,
                                               PyObject *args);
# 326 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyObject_CallFunction(PyObject *callable_object,
                                                 char *format, ...);
# 340 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyObject_CallMethod(PyObject *o, char *m,
                                               char *format, ...);
# 352 "/usr/include/python2.7/abstract.h" 3
     PyObject * _PyObject_CallFunction_SizeT(PyObject *callable,
                                                         char *format, ...);
     PyObject * _PyObject_CallMethod_SizeT(PyObject *o,
                                                       char *name,
                                                       char *format, ...);

     PyObject * PyObject_CallFunctionObjArgs(PyObject *callable,
                                                        ...);
# 370 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyObject_CallMethodObjArgs(PyObject *o,
                                                      PyObject *m, ...);
# 413 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyObject_Type(PyObject *o);







     Py_ssize_t PyObject_Size(PyObject *o);
# 433 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PyObject_Length(PyObject *o);


     Py_ssize_t _PyObject_LengthHint(PyObject *o, Py_ssize_t);







     PyObject * PyObject_GetItem(PyObject *o, PyObject *key);
# 453 "/usr/include/python2.7/abstract.h" 3
     int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);







     int PyObject_DelItemString(PyObject *o, char *key);







     int PyObject_DelItem(PyObject *o, PyObject *key);






     int PyObject_AsCharBuffer(PyObject *obj,
                                          const char **buffer,
                                          Py_ssize_t *buffer_len);
# 492 "/usr/include/python2.7/abstract.h" 3
     int PyObject_CheckReadBuffer(PyObject *obj);
# 501 "/usr/include/python2.7/abstract.h" 3
     int PyObject_AsReadBuffer(PyObject *obj,
                                          const void **buffer,
                                          Py_ssize_t *buffer_len);
# 517 "/usr/include/python2.7/abstract.h" 3
     int PyObject_AsWriteBuffer(PyObject *obj,
                                           void **buffer,
                                           Py_ssize_t *buffer_len);
# 542 "/usr/include/python2.7/abstract.h" 3
     int PyObject_GetBuffer(PyObject *obj, Py_buffer *view,
                                        int flags);
# 552 "/usr/include/python2.7/abstract.h" 3
     void * PyBuffer_GetPointer(Py_buffer *view, Py_ssize_t *indices);





     int PyBuffer_SizeFromFormat(const char *);






     int PyBuffer_ToContiguous(void *buf, Py_buffer *view,
                                           Py_ssize_t len, char fort);

     int PyBuffer_FromContiguous(Py_buffer *view, void *buf,
                                             Py_ssize_t len, char fort);
# 588 "/usr/include/python2.7/abstract.h" 3
     int PyObject_CopyData(PyObject *dest, PyObject *src);




     int PyBuffer_IsContiguous(Py_buffer *view, char fort);


     void PyBuffer_FillContiguousStrides(int ndims,
                                                    Py_ssize_t *shape,
                                                    Py_ssize_t *strides,
                                                    int itemsize,
                                                    char fort);







     int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf,
                                       Py_ssize_t len, int readonly,
                                       int flags);







     void PyBuffer_Release(Py_buffer *view);




     PyObject * PyObject_Format(PyObject* obj,
                                            PyObject *format_spec);







     PyObject * PyObject_GetIter(PyObject *);
# 642 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyIter_Next(PyObject *);







     int PyNumber_Check(PyObject *o);
# 660 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Add(PyObject *o1, PyObject *o2);
# 669 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Subtract(PyObject *o1, PyObject *o2);
# 678 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Multiply(PyObject *o1, PyObject *o2);
# 688 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Divide(PyObject *o1, PyObject *o2);
# 697 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
# 707 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
# 717 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Remainder(PyObject *o1, PyObject *o2);
# 727 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Divmod(PyObject *o1, PyObject *o2);
# 737 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Power(PyObject *o1, PyObject *o2,
                                          PyObject *o3);
# 747 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Negative(PyObject *o);







     PyObject * PyNumber_Positive(PyObject *o);







     PyObject * PyNumber_Absolute(PyObject *o);







     PyObject * PyNumber_Invert(PyObject *o);
# 781 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Lshift(PyObject *o1, PyObject *o2);
# 791 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Rshift(PyObject *o1, PyObject *o2);
# 800 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_And(PyObject *o1, PyObject *o2);
# 810 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Xor(PyObject *o1, PyObject *o2);
# 820 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Or(PyObject *o1, PyObject *o2);
# 853 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Index(PyObject *o);






     Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc);
# 871 "/usr/include/python2.7/abstract.h" 3
     PyObject * _PyNumber_ConvertIntegralToInt(
         PyObject *integral,
         const char* error_format);
# 883 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Int(PyObject *o);
# 892 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Long(PyObject *o);
# 901 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_Float(PyObject *o);
# 911 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
# 920 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
# 929 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
# 938 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2);
# 947 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                       PyObject *o2);
# 958 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                      PyObject *o2);
# 969 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
# 978 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                                 PyObject *o3);
# 988 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
# 997 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
# 1006 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
# 1015 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
# 1024 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
# 1034 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyNumber_ToBase(PyObject *n, int base);
# 1045 "/usr/include/python2.7/abstract.h" 3
     int PySequence_Check(PyObject *o);
# 1055 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PySequence_Size(PyObject *o);
# 1064 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PySequence_Length(PyObject *o);



     PyObject * PySequence_Concat(PyObject *o1, PyObject *o2);
# 1077 "/usr/include/python2.7/abstract.h" 3
     PyObject * PySequence_Repeat(PyObject *o, Py_ssize_t count);
# 1086 "/usr/include/python2.7/abstract.h" 3
     PyObject * PySequence_GetItem(PyObject *o, Py_ssize_t i);






     PyObject * PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
# 1102 "/usr/include/python2.7/abstract.h" 3
     int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);







     int PySequence_DelItem(PyObject *o, Py_ssize_t i);







     int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,
                                        PyObject *v);
# 1128 "/usr/include/python2.7/abstract.h" 3
     int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);







     PyObject * PySequence_Tuple(PyObject *o);







     PyObject * PySequence_List(PyObject *o);





     PyObject * PySequence_Fast(PyObject *o, const char* m);
# 1186 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PySequence_Count(PyObject *o, PyObject *value);
# 1195 "/usr/include/python2.7/abstract.h" 3
     int PySequence_Contains(PyObject *seq, PyObject *ob);
# 1204 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t _PySequence_IterSearch(PyObject *seq,
                                        PyObject *obj, int operation);
# 1219 "/usr/include/python2.7/abstract.h" 3
     int PySequence_In(PyObject *o, PyObject *value);
# 1230 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PySequence_Index(PyObject *o, PyObject *value);
# 1240 "/usr/include/python2.7/abstract.h" 3
     PyObject * PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
# 1249 "/usr/include/python2.7/abstract.h" 3
     PyObject * PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
# 1260 "/usr/include/python2.7/abstract.h" 3
     int PyMapping_Check(PyObject *o);
# 1269 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PyMapping_Size(PyObject *o);
# 1279 "/usr/include/python2.7/abstract.h" 3
     Py_ssize_t PyMapping_Length(PyObject *o);
# 1303 "/usr/include/python2.7/abstract.h" 3
     int PyMapping_HasKeyString(PyObject *o, char *key);
# 1313 "/usr/include/python2.7/abstract.h" 3
     int PyMapping_HasKey(PyObject *o, PyObject *key);
# 1356 "/usr/include/python2.7/abstract.h" 3
     PyObject * PyMapping_GetItemString(PyObject *o, char *key);







     int PyMapping_SetItemString(PyObject *o, char *key,
                                            PyObject *value);
# 1374 "/usr/include/python2.7/abstract.h" 3
int PyObject_IsInstance(PyObject *object, PyObject *typeorclass);


int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);



int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls);

int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls);



void _Py_add_one_to_index_F(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);
void _Py_add_one_to_index_C(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);



}
# 137 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/compile.h" 1 3




# 1 "/usr/include/python2.7/code.h" 1 3





extern "C" {



typedef struct {
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
    int co_argcount;
    int co_nlocals;
    int co_stacksize;
    int co_flags;
    PyObject *co_code;
    PyObject *co_consts;
    PyObject *co_names;
    PyObject *co_varnames;
    PyObject *co_freevars;
    PyObject *co_cellvars;

    PyObject *co_filename;
    PyObject *co_name;
    int co_firstlineno;
    PyObject *co_lnotab;

    void *co_zombieframe;
    PyObject *co_weakreflist;
} PyCodeObject;
# 65 "/usr/include/python2.7/code.h" 3
extern PyTypeObject PyCode_Type;





PyCodeObject * PyCode_New(
 int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
 PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *);



PyCodeObject *
PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno);




int PyCode_Addr2Line(PyCodeObject *, int);






typedef struct _addr_pair {
        int ap_lower;
        int ap_upper;
} PyAddrPair;




int _PyCode_CheckLineNumber(PyCodeObject* co,
                                        int lasti, PyAddrPair *bounds);
# 108 "/usr/include/python2.7/code.h" 3
PyObject* _PyCode_ConstantKey(PyObject *obj);

PyObject* PyCode_Optimize(PyObject *code, PyObject* consts,
                                      PyObject *names, PyObject *lineno_obj);


}
# 6 "/usr/include/python2.7/compile.h" 2 3


extern "C" {



struct _node;
PyCodeObject * PyNode_Compile(struct _node *, const char *);



typedef struct {
    int ff_features;
    int ff_lineno;
} PyFutureFeatures;
# 31 "/usr/include/python2.7/compile.h" 3
struct _mod;
PyCodeObject * PyAST_Compile(struct _mod *, const char *,
     PyCompilerFlags *, PyArena *);
PyFutureFeatures * PyFuture_FromAST(struct _mod *, const char *);



}
# 139 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/eval.h" 1 3






extern "C" {


PyObject * PyEval_EvalCode(PyCodeObject *, PyObject *, PyObject *);

PyObject * PyEval_EvalCodeEx(PyCodeObject *co,
     PyObject *globals,
     PyObject *locals,
     PyObject **args, int argc,
     PyObject **kwds, int kwdc,
     PyObject **defs, int defc,
     PyObject *closure);

PyObject * _PyEval_CallTracing(PyObject *func, PyObject *args);


}
# 140 "/usr/include/python2.7/Python.h" 2 3

# 1 "/usr/include/python2.7/pyctype.h" 1 3
# 12 "/usr/include/python2.7/pyctype.h" 3
extern const unsigned int _Py_ctype_table[256];
# 25 "/usr/include/python2.7/pyctype.h" 3
extern const unsigned char _Py_ctype_tolower[256];
extern const unsigned char _Py_ctype_toupper[256];
# 142 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pystrtod.h" 1 3




extern "C" {



double PyOS_ascii_strtod(const char *str, char **ptr);
double PyOS_ascii_atof(const char *str);


char * PyOS_ascii_formatd(char *buffer, size_t buf_len,
                                      const char *format, double d);
double PyOS_string_to_double(const char *str,
                                         char **endptr,
                                         PyObject *overflow_exception);



char * PyOS_double_to_string(double val,
                                         char format_code,
                                         int precision,
                                         int flags,
                                         int *type);

double _Py_parse_inf_or_nan(const char *p, char **endptr);
# 42 "/usr/include/python2.7/pystrtod.h" 3
}
# 143 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/pystrcmp.h" 1 3




extern "C" {


int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t);
int PyOS_mystricmp(const char *, const char *);
# 20 "/usr/include/python2.7/pystrcmp.h" 3
}
# 144 "/usr/include/python2.7/Python.h" 2 3
# 1 "/usr/include/python2.7/dtoa.h" 1 3


extern "C" {


double _Py_dg_strtod(const char *str, char **ptr);
char * _Py_dg_dtoa(double d, int mode, int ndigits,
                        int *decpt, int *sign, char **rve);
void _Py_dg_freedtoa(char *s);



}
# 145 "/usr/include/python2.7/Python.h" 2 3


PyObject* _Py_Mangle(PyObject *p, PyObject *name);
# 159 "/usr/include/python2.7/Python.h" 3
# 1 "/usr/include/python2.7/pyfpe.h" 1 3



extern "C" {
# 174 "/usr/include/python2.7/pyfpe.h" 3
}
# 160 "/usr/include/python2.7/Python.h" 2 3
# 179 "/usr/local/include/boost/python/detail/wrap_python.hpp" 2 3



#pragma GCC diagnostic pop
# 14 "/usr/local/include/boost/python/detail/prefix.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/config.hpp" 1 3
# 15 "/usr/local/include/boost/python/detail/config.hpp" 3
# 1 "/usr/local/include/boost/config.hpp" 1 3
# 30 "/usr/local/include/boost/config.hpp" 3
# 1 "/usr/local/include/boost/config/user.hpp" 1 3
# 31 "/usr/local/include/boost/config.hpp" 2 3




# 1 "/usr/local/include/boost/config/detail/select_compiler_config.hpp" 1 3
# 36 "/usr/local/include/boost/config.hpp" 2 3



# 1 "/usr/local/include/boost/config/compiler/gcc.hpp" 1 3
# 165 "/usr/local/include/boost/config/compiler/gcc.hpp" 3
# 1 "/usr/include/c++/7/cstddef" 1 3
# 42 "/usr/include/c++/7/cstddef" 3
       
# 43 "/usr/include/c++/7/cstddef" 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/usr/include/c++/7/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 166 "/usr/local/include/boost/config/compiler/gcc.hpp" 2 3
# 40 "/usr/local/include/boost/config.hpp" 2 3




# 1 "/usr/local/include/boost/config/detail/select_stdlib_config.hpp" 1 3
# 45 "/usr/local/include/boost/config.hpp" 2 3



# 1 "/usr/local/include/boost/config/stdlib/libstdcpp3.hpp" 1 3
# 49 "/usr/local/include/boost/config.hpp" 2 3




# 1 "/usr/local/include/boost/config/detail/select_platform_config.hpp" 1 3
# 54 "/usr/local/include/boost/config.hpp" 2 3



# 1 "/usr/local/include/boost/config/platform/linux.hpp" 1 3
# 15 "/usr/local/include/boost/config/platform/linux.hpp" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 16 "/usr/local/include/boost/config/platform/linux.hpp" 2 3
# 75 "/usr/local/include/boost/config/platform/linux.hpp" 3
# 1 "/usr/local/include/boost/config/detail/posix_features.hpp" 1 3
# 76 "/usr/local/include/boost/config/platform/linux.hpp" 2 3
# 58 "/usr/local/include/boost/config.hpp" 2 3



# 1 "/usr/local/include/boost/config/detail/suffix.hpp" 1 3
# 34 "/usr/local/include/boost/config/detail/suffix.hpp" 3
       
# 35 "/usr/local/include/boost/config/detail/suffix.hpp" 3
# 484 "/usr/local/include/boost/config/detail/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}



namespace boost{

   __extension__ typedef __int128 int128_type;
   __extension__ typedef unsigned __int128 uint128_type;




}



namespace boost {

   __extension__ typedef __float128 float128_type;



}
# 543 "/usr/local/include/boost/config/detail/suffix.hpp" 3
# 1 "/usr/local/include/boost/config/helper_macros.hpp" 1 3
# 544 "/usr/local/include/boost/config/detail/suffix.hpp" 2 3
# 62 "/usr/local/include/boost/config.hpp" 2 3


       
# 16 "/usr/local/include/boost/python/detail/config.hpp" 2 3
# 1 "/usr/local/include/boost/detail/workaround.hpp" 1 3







# 1 "/usr/local/include/boost/config/workaround.hpp" 1 3
# 9 "/usr/local/include/boost/detail/workaround.hpp" 2 3
# 17 "/usr/local/include/boost/python/detail/config.hpp" 2 3
# 15 "/usr/local/include/boost/python/detail/prefix.hpp" 2 3
# 9 "/usr/local/include/boost/python/args.hpp" 2 3

# 1 "/usr/local/include/boost/python/args_fwd.hpp" 1 3
# 10 "/usr/local/include/boost/python/args_fwd.hpp" 3
# 1 "/usr/local/include/boost/python/handle.hpp" 1 3
# 10 "/usr/local/include/boost/python/handle.hpp" 3
# 1 "/usr/local/include/boost/python/cast.hpp" 1 3
# 9 "/usr/local/include/boost/python/cast.hpp" 3
# 1 "/usr/local/include/boost/python/detail/type_traits.hpp" 1 3
# 28 "/usr/local/include/boost/python/detail/type_traits.hpp" 3
# 1 "/usr/include/c++/7/type_traits" 1 3
# 32 "/usr/include/c++/7/type_traits" 3
       
# 33 "/usr/include/c++/7/type_traits" 3
# 42 "/usr/include/c++/7/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/usr/include/c++/7/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 192 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 324 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 936 "/usr/include/c++/7/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;

  template<typename _Tp, typename... _Args>
    struct is_constructible;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>,
       __not_<is_constructible<__dst_t, _From>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<wchar_t> : __make_unsigned<int>
    { };



  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1771 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1860 "/usr/include/c++/7/type_traits" 3
  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };



  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1890 "/usr/include/c++/7/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2036 "/usr/include/c++/7/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2075 "/usr/include/c++/7/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;



  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2553 "/usr/include/c++/7/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;






  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3108 "/usr/include/c++/7/type_traits" 3

}
# 29 "/usr/local/include/boost/python/detail/type_traits.hpp" 2 3


# 1 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 3
# 1 "/usr/local/include/boost/type_traits/intrinsics.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/intrinsics.hpp" 3
# 1 "/usr/local/include/boost/type_traits/detail/config.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/detail/config.hpp" 3
# 1 "/usr/local/include/boost/version.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/detail/config.hpp" 2 3
# 17 "/usr/local/include/boost/type_traits/intrinsics.hpp" 2 3
# 13 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/integral_constant.hpp" 1 3
# 31 "/usr/local/include/boost/type_traits/integral_constant.hpp" 3
namespace mpl_{

   template <bool B> struct bool_;
   template <class I, I val> struct integral_c;
   struct integral_c_tag;
}

namespace boost
{
   namespace mpl
   {
      using ::mpl_::bool_;
      using ::mpl_::integral_c;
      using ::mpl_::integral_c_tag;
   }
}



namespace boost{

   template <class T, T val>
   struct integral_constant
   {
      typedef mpl::integral_c_tag tag;
      typedef T value_type;
      typedef integral_constant<T, val> type;
      static const T value = val;

      operator const mpl::integral_c<T, val>& ()const
      {
         static const char data[sizeof(long)] = { 0 };
         static const void* pdata = data;
         return *(reinterpret_cast<const mpl::integral_c<T, val>*>(pdata));
      }
      constexpr operator T()const { return val; }
   };

   template <class T, T val>
   T const integral_constant<T, val>::value;

   template <bool val>
   struct integral_constant<bool, val>
   {
      typedef mpl::integral_c_tag tag;
      typedef bool value_type;
      typedef integral_constant<bool, val> type;
      static const bool value = val;

      operator const mpl::bool_<val>& ()const
      {
         static const char data[sizeof(long)] = { 0 };
         static const void* pdata = data;
         return *(reinterpret_cast<const mpl::bool_<val>*>(pdata));
      }
      constexpr operator bool()const { return val; }
   };

   template <bool val>
   bool const integral_constant<bool, val>::value;

   typedef integral_constant<bool, true> true_type;
   typedef integral_constant<bool, false> false_type;

}
# 14 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 2 3







# 1 "/usr/local/include/boost/type_traits/remove_cv.hpp" 1 3
# 18 "/usr/local/include/boost/type_traits/remove_cv.hpp" 3
namespace boost {


template <class T> struct remove_cv{ typedef T type; };
template <class T> struct remove_cv<T const>{ typedef T type; };
template <class T> struct remove_cv<T volatile>{ typedef T type; };
template <class T> struct remove_cv<T const volatile>{ typedef T type; };


template <class T, std::size_t N> struct remove_cv<T const[N]>{ typedef T type[N]; };
template <class T, std::size_t N> struct remove_cv<T const volatile[N]>{ typedef T type[N]; };
template <class T, std::size_t N> struct remove_cv<T volatile[N]>{ typedef T type[N]; };

template <class T> struct remove_cv<T const[]>{ typedef T type[]; };
template <class T> struct remove_cv<T const volatile[]>{ typedef T type[]; };
template <class T> struct remove_cv<T volatile[]>{ typedef T type[]; };





   template <class T> using remove_cv_t = typename remove_cv<T>::type;



}
# 22 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_same.hpp" 1 3
# 26 "/usr/local/include/boost/type_traits/is_same.hpp" 3
namespace boost {


   template <class T, class U> struct is_same : public false_type {};
   template <class T> struct is_same<T,T> : public true_type {};







}
# 23 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 2 3

namespace boost {

namespace detail {
# 220 "/usr/local/include/boost/type_traits/is_base_and_derived.hpp" 3
template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;

    static const bool value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value);
};

}

template <class Base, class Derived> struct is_base_and_derived
   : public integral_constant<bool, (::boost::detail::is_base_and_derived_impl<Base, Derived>::value)> {};

template <class Base, class Derived> struct is_base_and_derived<Base&, Derived> : public false_type{};
template <class Base, class Derived> struct is_base_and_derived<Base, Derived&> : public false_type{};
template <class Base, class Derived> struct is_base_and_derived<Base&, Derived&> : public false_type{};





}
# 32 "/usr/local/include/boost/python/detail/type_traits.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/alignment_traits.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/alignment_traits.hpp" 3
# 1 "/usr/local/include/boost/type_traits/alignment_of.hpp" 1 3
# 26 "/usr/local/include/boost/type_traits/alignment_of.hpp" 3
namespace boost {

template <typename T> struct alignment_of;


namespace detail {





template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};




template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{
# 82 "/usr/local/include/boost/type_traits/alignment_of.hpp" 3
   static const std::size_t value = __alignof__(T);

};

}

template <class T> struct alignment_of : public integral_constant<std::size_t, ::boost::detail::alignment_of_impl<T>::value>{};



template <typename T> struct alignment_of<T&> : public alignment_of<T*>{};
# 102 "/usr/local/include/boost/type_traits/alignment_of.hpp" 3
template<> struct alignment_of<void> : integral_constant<std::size_t, 0>{};

template<> struct alignment_of<void const> : integral_constant<std::size_t, 0>{};
template<> struct alignment_of<void const volatile> : integral_constant<std::size_t, 0>{};
template<> struct alignment_of<void volatile> : integral_constant<std::size_t, 0>{};


}
# 13 "/usr/local/include/boost/type_traits/alignment_traits.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/type_with_alignment.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/type_with_alignment.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_pod.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/is_pod.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_void.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/is_void.hpp" 3
namespace boost {

template <class T>
struct is_void : public false_type {};

template<> struct is_void<void> : public true_type {};
template<> struct is_void<const void> : public true_type{};
template<> struct is_void<const volatile void> : public true_type{};
template<> struct is_void<volatile void> : public true_type{};

}
# 15 "/usr/local/include/boost/type_traits/is_pod.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_scalar.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/is_scalar.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_arithmetic.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/is_arithmetic.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_integral.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/is_integral.hpp" 3
namespace boost {






template <class T> struct is_integral : public false_type {};
template <class T> struct is_integral<const T> : public is_integral<T> {};
template <class T> struct is_integral<volatile const T> : public is_integral<T>{};
template <class T> struct is_integral<volatile T> : public is_integral<T>{};




template<> struct is_integral<unsigned char> : public true_type {};
template<> struct is_integral<unsigned short> : public true_type{};
template<> struct is_integral<unsigned int> : public true_type{};
template<> struct is_integral<unsigned long> : public true_type{};

template<> struct is_integral<signed char> : public true_type{};
template<> struct is_integral<short> : public true_type{};
template<> struct is_integral<int> : public true_type{};
template<> struct is_integral<long> : public true_type{};

template<> struct is_integral<char> : public true_type{};
template<> struct is_integral<bool> : public true_type{};





template<> struct is_integral<wchar_t> : public true_type{};
# 67 "/usr/local/include/boost/type_traits/is_integral.hpp" 3
template<> struct is_integral< ::boost::ulong_long_type> : public true_type{};
template<> struct is_integral< ::boost::long_long_type> : public true_type{};






template<> struct is_integral<boost::int128_type> : public true_type{};
template<> struct is_integral<boost::uint128_type> : public true_type{};


template<> struct is_integral<char16_t> : public true_type{};


template<> struct is_integral<char32_t> : public true_type{};




}
# 13 "/usr/local/include/boost/type_traits/is_arithmetic.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_floating_point.hpp" 1 3
# 13 "/usr/local/include/boost/type_traits/is_floating_point.hpp" 3
namespace boost {


   template <class T> struct is_floating_point : public false_type{};
   template <class T> struct is_floating_point<const T> : public is_floating_point<T>{};
   template <class T> struct is_floating_point<volatile const T> : public is_floating_point<T>{};
   template <class T> struct is_floating_point<volatile T> : public is_floating_point<T>{};
   template<> struct is_floating_point<float> : public true_type{};
   template<> struct is_floating_point<double> : public true_type{};
   template<> struct is_floating_point<long double> : public true_type{};


   template<> struct is_floating_point<__float128> : public true_type{};


}
# 14 "/usr/local/include/boost/type_traits/is_arithmetic.hpp" 2 3

namespace boost {

template <class T>
struct is_arithmetic : public integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

}
# 13 "/usr/local/include/boost/type_traits/is_scalar.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_enum.hpp" 1 3
# 32 "/usr/local/include/boost/type_traits/is_enum.hpp" 3
namespace boost {
# 160 "/usr/local/include/boost/type_traits/is_enum.hpp" 3
template <class T> struct is_enum : public integral_constant<bool, __is_enum(T)> {};



}
# 14 "/usr/local/include/boost/type_traits/is_scalar.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_pointer.hpp" 1 3
# 26 "/usr/local/include/boost/type_traits/is_pointer.hpp" 3
namespace boost {




template <class T> struct is_pointer : public false_type{};
template <class T> struct is_pointer<T*> : public true_type{};
template <class T> struct is_pointer<T*const> : public true_type{};
template <class T> struct is_pointer<T*const volatile> : public true_type{};
template <class T> struct is_pointer<T*volatile> : public true_type{};
# 45 "/usr/local/include/boost/type_traits/is_pointer.hpp" 3
}
# 15 "/usr/local/include/boost/type_traits/is_scalar.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_member_pointer.hpp" 1 3
# 25 "/usr/local/include/boost/type_traits/is_member_pointer.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_member_function_pointer.hpp" 1 3
# 18 "/usr/local/include/boost/type_traits/is_member_function_pointer.hpp" 3
# 1 "/usr/local/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 3
namespace boost {
# 25 "/usr/local/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 3
   template <class T>
   struct is_member_function_pointer : public false_type {};
   template <class T>
   struct is_member_function_pointer<T const> : public is_member_function_pointer<T> {};
   template <class T>
   struct is_member_function_pointer<T volatile> : public is_member_function_pointer<T> {};
   template <class T>
   struct is_member_function_pointer<T const volatile> : public is_member_function_pointer<T> {};
# 47 "/usr/local/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 3
   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)> : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret (C::*)(Args..., ...)> : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)const > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile > : public true_type {};



   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)& > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)& > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)const & > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const & > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile & > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile & > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile & > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile & > : public true_type {};



   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...) && > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...) && > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)const && > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const && > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile && > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile && > : public true_type {};

   template <class Ret, class C, class...Args >
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile && > : public true_type {};
   template <class Ret, class C, class ...Args >
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile && > : public true_type {};
# 670 "/usr/local/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 3
}
# 19 "/usr/local/include/boost/type_traits/is_member_function_pointer.hpp" 2 3
# 26 "/usr/local/include/boost/type_traits/is_member_pointer.hpp" 2 3

namespace boost {




template <class T> struct is_member_pointer : public integral_constant<bool, ::boost::is_member_function_pointer<T>::value>{};
template <class T, class U> struct is_member_pointer<U T::* > : public true_type{};


template <class T, class U> struct is_member_pointer<U T::*const> : public true_type{};
template <class T, class U> struct is_member_pointer<U T::*const volatile> : public true_type{};
template <class T, class U> struct is_member_pointer<U T::*volatile> : public true_type{};




}
# 16 "/usr/local/include/boost/type_traits/is_scalar.hpp" 2 3


namespace boost {

template <typename T>
struct is_scalar
   : public integral_constant<bool, ::boost::is_arithmetic<T>::value || ::boost::is_enum<T>::value || ::boost::is_pointer<T>::value || ::boost::is_member_pointer<T>::value>
{};

}
# 16 "/usr/local/include/boost/type_traits/is_pod.hpp" 2 3
# 30 "/usr/local/include/boost/type_traits/is_pod.hpp" 3
namespace boost {


template< typename T > struct is_POD;

template <typename T> struct is_pod
: public integral_constant<bool, ::boost::is_scalar<T>::value || ::boost::is_void<T>::value || __is_pod(T)>
{};


template <typename T, std::size_t sz> struct is_pod<T[sz]> : public is_pod<T>{};




template<> struct is_pod<void> : public true_type{};


template<> struct is_pod<void const> : public true_type{};
template<> struct is_pod<void const volatile> : public true_type{};
template<> struct is_pod<void volatile> : public true_type{};


template<class T> struct is_POD : public is_pod<T>{};

}
# 13 "/usr/local/include/boost/type_traits/type_with_alignment.hpp" 2 3
# 1 "/usr/local/include/boost/static_assert.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/type_with_alignment.hpp" 2 3
# 27 "/usr/local/include/boost/type_traits/type_with_alignment.hpp" 3
namespace boost {

   namespace detail{

      union max_align
      {
         char c;
         short s;
         int i;
         long l;

         boost::long_long_type ll;


         boost::int128_type i128;

         float f;
         double d;
         long double ld;

         __float128 f128;

      };

template <std::size_t Target, bool check> struct long_double_alignment{ typedef long double type; };
template <std::size_t Target> struct long_double_alignment<Target, false>{ typedef boost::detail::max_align type; };

template <std::size_t Target, bool check> struct double_alignment{ typedef double type; };
template <std::size_t Target> struct double_alignment<Target, false>{ typedef typename long_double_alignment<Target, boost::alignment_of<long double>::value >= Target>::type type; };


template <std::size_t Target, bool check> struct long_long_alignment{ typedef boost::long_long_type type; };
template <std::size_t Target> struct long_long_alignment<Target, false>{ typedef typename double_alignment<Target, boost::alignment_of<double>::value >= Target>::type type; };


template <std::size_t Target, bool check> struct long_alignment{ typedef long type; };

template <std::size_t Target> struct long_alignment<Target, false>{ typedef typename long_long_alignment<Target, boost::alignment_of<boost::long_long_type>::value >= Target>::type type; };




template <std::size_t Target, bool check> struct int_alignment{ typedef int type; };
template <std::size_t Target> struct int_alignment<Target, false>{ typedef typename long_alignment<Target, boost::alignment_of<long>::value >= Target>::type type; };

template <std::size_t Target, bool check> struct short_alignment{ typedef short type; };
template <std::size_t Target> struct short_alignment<Target, false>{ typedef typename int_alignment<Target, boost::alignment_of<int>::value >= Target>::type type; };

template <std::size_t Target, bool check> struct char_alignment{ typedef char type; };
template <std::size_t Target> struct char_alignment<Target, false>{ typedef typename short_alignment<Target, boost::alignment_of<short>::value >= Target>::type type; };

}

template <std::size_t Align>
struct type_with_alignment
{
   typedef typename boost::detail::char_alignment<Align, boost::alignment_of<char>::value >= Align>::type type;
};


namespace tt_align_ns {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
struct __attribute__((__aligned__(64))) a64 {};
struct __attribute__((__aligned__(128))) a128 {};
}

template<> struct type_with_alignment<1> { public: typedef char type; };
template<> struct type_with_alignment<2> { public: typedef tt_align_ns::a2 type; };
template<> struct type_with_alignment<4> { public: typedef tt_align_ns::a4 type; };
template<> struct type_with_alignment<8> { public: typedef tt_align_ns::a8 type; };
template<> struct type_with_alignment<16> { public: typedef tt_align_ns::a16 type; };
template<> struct type_with_alignment<32> { public: typedef tt_align_ns::a32 type; };
template<> struct type_with_alignment<64> { public: typedef tt_align_ns::a64 type; };
template<> struct type_with_alignment<128> { public: typedef tt_align_ns::a128 type; };

template<> struct is_pod< ::boost::tt_align_ns::a2> : public true_type{};
template<> struct is_pod< ::boost::tt_align_ns::a4> : public true_type{};
template<> struct is_pod< ::boost::tt_align_ns::a8> : public true_type{};
template<> struct is_pod< ::boost::tt_align_ns::a16> : public true_type{};
template<> struct is_pod< ::boost::tt_align_ns::a32> : public true_type{};
template<> struct is_pod< ::boost::tt_align_ns::a64> : public true_type{};
template<> struct is_pod< ::boost::tt_align_ns::a128> : public true_type{};
# 252 "/usr/local/include/boost/type_traits/type_with_alignment.hpp" 3
}
# 14 "/usr/local/include/boost/type_traits/alignment_traits.hpp" 2 3
# 33 "/usr/local/include/boost/python/detail/type_traits.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/has_trivial_copy.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/has_trivial_copy.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_reference.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/is_reference.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_lvalue_reference.hpp" 1 3
# 26 "/usr/local/include/boost/type_traits/is_lvalue_reference.hpp" 3
namespace boost {





   template <class T> struct is_lvalue_reference : public false_type{};
   template <class T> struct is_lvalue_reference<T&> : public true_type{};
# 47 "/usr/local/include/boost/type_traits/is_lvalue_reference.hpp" 3
}
# 16 "/usr/local/include/boost/type_traits/is_reference.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_rvalue_reference.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/is_rvalue_reference.hpp" 3
namespace boost {

template <class T> struct is_rvalue_reference : public false_type {};

template <class T> struct is_rvalue_reference<T&&> : public true_type {};


}
# 17 "/usr/local/include/boost/type_traits/is_reference.hpp" 2 3

namespace boost {

template <class T> struct is_reference
   : public
   integral_constant<
      bool,
      ::boost::is_lvalue_reference<T>::value || ::boost::is_rvalue_reference<T>::value>
{};

}
# 16 "/usr/local/include/boost/type_traits/has_trivial_copy.hpp" 2 3


# 1 "/usr/local/include/boost/type_traits/is_copy_constructible.hpp" 1 3
# 17 "/usr/local/include/boost/type_traits/is_copy_constructible.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_constructible.hpp" 1 3
# 17 "/usr/local/include/boost/type_traits/is_constructible.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_destructible.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/is_destructible.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_complete.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/is_complete.hpp" 3
# 1 "/usr/local/include/boost/type_traits/declval.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/declval.hpp" 3
# 1 "/usr/local/include/boost/type_traits/add_rvalue_reference.hpp" 1 3
# 31 "/usr/local/include/boost/type_traits/add_rvalue_reference.hpp" 3
namespace boost {

namespace type_traits_detail {

    template <typename T, bool b>
    struct add_rvalue_reference_helper
    { typedef T type; };


    template <typename T>
    struct add_rvalue_reference_helper<T, true>
    {
        typedef T&& type;
    };


    template <typename T>
    struct add_rvalue_reference_imp
    {
       typedef typename boost::type_traits_detail::add_rvalue_reference_helper
                  <T, (is_void<T>::value == false && is_reference<T>::value == false) >::type type;
    };

}

template <class T> struct add_rvalue_reference
{
   typedef typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type type;
};



   template <class T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;



}
# 16 "/usr/local/include/boost/type_traits/declval.hpp" 2 3
# 37 "/usr/local/include/boost/type_traits/declval.hpp" 3
namespace boost {

    template <typename T>
    typename add_rvalue_reference<T>::type declval() noexcept;

}
# 13 "/usr/local/include/boost/type_traits/is_complete.hpp" 2 3

# 1 "/usr/local/include/boost/type_traits/remove_reference.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/remove_reference.hpp" 3
namespace boost {


namespace detail{




template <class T>
struct remove_rvalue_ref
{
   typedef T type;
};

template <class T>
struct remove_rvalue_ref<T&&>
{
   typedef T type;
};


}

template <class T> struct remove_reference{ typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template <class T> struct remove_reference<T&>{ typedef T type; };
# 53 "/usr/local/include/boost/type_traits/remove_reference.hpp" 3
   template <class T> using remove_reference_t = typename remove_reference<T>::type;



}
# 15 "/usr/local/include/boost/type_traits/is_complete.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_function.hpp" 1 3
# 19 "/usr/local/include/boost/type_traits/is_function.hpp" 3
# 1 "/usr/local/include/boost/type_traits/detail/is_function_cxx_11.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/detail/is_function_cxx_11.hpp" 3
namespace boost {

   template <class T>
   struct is_function : public false_type {};
# 35 "/usr/local/include/boost/type_traits/detail/is_function_cxx_11.hpp" 3
   template <class Ret, class...Args >
   struct is_function<Ret (Args...)> : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)> : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)const > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)const > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)volatile > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)volatile > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)const volatile > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)const volatile > : public true_type {};



   template <class Ret, class...Args >
   struct is_function<Ret (Args...)& > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)& > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)const & > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)const & > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)volatile & > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)volatile & > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)const volatile & > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)const volatile & > : public true_type {};



   template <class Ret, class...Args >
   struct is_function<Ret (Args...)&& > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)&& > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)const && > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)const && > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)volatile && > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)volatile && > : public true_type {};

   template <class Ret, class...Args >
   struct is_function<Ret (Args...)const volatile && > : public true_type {};
   template <class Ret, class ...Args >
   struct is_function<Ret(Args..., ...)const volatile && > : public true_type {};
# 566 "/usr/local/include/boost/type_traits/detail/is_function_cxx_11.hpp" 3
}
# 20 "/usr/local/include/boost/type_traits/is_function.hpp" 2 3
# 16 "/usr/local/include/boost/type_traits/is_complete.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/detail/yes_no_type.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/detail/yes_no_type.hpp" 3
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 17 "/usr/local/include/boost/type_traits/is_complete.hpp" 2 3
# 31 "/usr/local/include/boost/type_traits/is_complete.hpp" 3
namespace boost {
# 41 "/usr/local/include/boost/type_traits/is_complete.hpp" 3
   namespace detail{

      template <unsigned N>
      struct ok_tag { double d; char c[N]; };

      template <class T>
      ok_tag<sizeof(T)> check_is_complete(int);
      template <class T>
      char check_is_complete(...);
   }

   template <class T> struct is_complete
      : public integral_constant<bool, ::boost::is_function<typename boost::remove_reference<T>::type>::value || (sizeof(boost::detail::check_is_complete<T>(0)) != sizeof(char))> {};
# 90 "/usr/local/include/boost/type_traits/is_complete.hpp" 3
}
# 16 "/usr/local/include/boost/type_traits/is_destructible.hpp" 2 3







namespace boost{

   namespace detail{

      struct is_destructible_imp
      {
         template<typename T, typename = decltype(boost::declval<T&>().~T())>
         static boost::type_traits::yes_type test(int);
         template<typename>
         static boost::type_traits::no_type test(...);
      };

   }

   template <class T> struct is_destructible : public integral_constant<bool, sizeof(boost::detail::is_destructible_imp::test<T>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(boost::is_complete<T>::value, "Arguments to is_destructible must be complete types");
   };
# 56 "/usr/local/include/boost/type_traits/is_destructible.hpp" 3
   template <> struct is_destructible<void> : public false_type{};
   template <> struct is_destructible<void const> : public false_type{};
   template <> struct is_destructible<void volatile> : public false_type{};
   template <> struct is_destructible<void const volatile> : public false_type{};
   template <class T> struct is_destructible<T&> : public is_destructible<T>{};

   template <class T> struct is_destructible<T&&> : public is_destructible<T>{};

   template <class T, std::size_t N> struct is_destructible<T[N]> : public is_destructible<T>{};
   template <class T> struct is_destructible<T[]> : public is_destructible<T>{};

}
# 18 "/usr/local/include/boost/type_traits/is_constructible.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_default_constructible.hpp" 1 3
# 29 "/usr/local/include/boost/type_traits/is_default_constructible.hpp" 3
namespace boost{

   namespace detail{

      struct is_default_constructible_imp
      {
         template<typename _Tp, typename = decltype(_Tp())>
         static boost::type_traits::yes_type test(int);

         template<typename>
         static boost::type_traits::no_type test(...);
      };
# 53 "/usr/local/include/boost/type_traits/is_default_constructible.hpp" 3
   }







   template <class T> struct is_default_constructible : public integral_constant<bool, sizeof(boost::detail::is_default_constructible_imp::test<T>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(boost::is_complete<T>::value, "Arguments to is_default_constructible must be complete types");
   };

   template <class T, std::size_t N> struct is_default_constructible<T[N]> : public is_default_constructible<T>{};
   template <class T> struct is_default_constructible<T[]> : public is_default_constructible<T>{};
   template <class T> struct is_default_constructible<T&> : public integral_constant<bool, false>{};




   template <class T> struct is_default_constructible<T&&> : public integral_constant<bool, false>{};

   template <> struct is_default_constructible<void> : public integral_constant<bool, false>{};
   template <> struct is_default_constructible<void const> : public integral_constant<bool, false>{};
   template <> struct is_default_constructible<void volatile> : public integral_constant<bool, false>{};
   template <> struct is_default_constructible<void const volatile> : public integral_constant<bool, false>{};
# 96 "/usr/local/include/boost/type_traits/is_default_constructible.hpp" 3
}
# 19 "/usr/local/include/boost/type_traits/is_constructible.hpp" 2 3







namespace boost{

   namespace detail{

      struct is_constructible_imp
      {
         template<typename T, typename ...TheArgs, typename = decltype(T(boost::declval<TheArgs>()...))>
         static boost::type_traits::yes_type test(int);
         template<typename, typename...>
         static boost::type_traits::no_type test(...);

         template<typename T, typename Arg, typename = decltype(::new T(boost::declval<Arg>()))>
         static boost::type_traits::yes_type test1(int);
         template<typename, typename>
         static boost::type_traits::no_type test1(...);

         template <typename T>
         static boost::type_traits::yes_type ref_test(T);
         template <typename T>
         static boost::type_traits::no_type ref_test(...);
      };

   }

   template <class T, class ...Args> struct is_constructible : public integral_constant<bool, sizeof(detail::is_constructible_imp::test<T, Args...>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(::boost::is_complete<T>::value, "The target type must be complete in order to test for constructibility");
   };
   template <class T, class Arg> struct is_constructible<T, Arg> : public integral_constant<bool, is_destructible<T>::value && sizeof(boost::detail::is_constructible_imp::test1<T, Arg>(0)) == sizeof(boost::type_traits::yes_type)>
   {
      static_assert(::boost::is_complete<T>::value, "The target type must be complete in order to test for constructibility");
   };
   template <class Ref, class Arg> struct is_constructible<Ref&, Arg> : public integral_constant<bool, sizeof(detail::is_constructible_imp::ref_test<Ref&>(boost::declval<Arg>())) == sizeof(boost::type_traits::yes_type)>{};
   template <class Ref, class Arg> struct is_constructible<Ref&&, Arg> : public integral_constant<bool, sizeof(detail::is_constructible_imp::ref_test<Ref&&>(boost::declval<Arg>())) == sizeof(boost::type_traits::yes_type)>{};

   template <> struct is_constructible<void> : public false_type{};
   template <> struct is_constructible<void const> : public false_type{};
   template <> struct is_constructible<void const volatile> : public false_type{};
   template <> struct is_constructible<void volatile> : public false_type{};

   template <class T> struct is_constructible<T> : public is_default_constructible<T>{};
# 88 "/usr/local/include/boost/type_traits/is_constructible.hpp" 3
}
# 18 "/usr/local/include/boost/type_traits/is_copy_constructible.hpp" 2 3



namespace boost {

template <class T> struct is_copy_constructible : public boost::is_constructible<T, const T&>{};

template <> struct is_copy_constructible<void> : public false_type{};
template <> struct is_copy_constructible<void const> : public false_type{};
template <> struct is_copy_constructible<void const volatile> : public false_type{};
template <> struct is_copy_constructible<void volatile> : public false_type{};

}
# 19 "/usr/local/include/boost/type_traits/has_trivial_copy.hpp" 2 3
# 29 "/usr/local/include/boost/type_traits/has_trivial_copy.hpp" 3
namespace boost {

template <typename T> struct has_trivial_copy
: public integral_constant<bool,

   ((__has_trivial_copy(T) ) && !is_reference<T>::value) && is_copy_constructible<T>::value



>{};

template <typename T, std::size_t N> struct has_trivial_copy<T[N]> : public false_type{};
template <typename T> struct has_trivial_copy<T[]> : public false_type{};

template <typename T> struct has_trivial_copy<T volatile> : public false_type{};

template <> struct has_trivial_copy<void> : public false_type{};

template <> struct has_trivial_copy<void const> : public false_type{};
template <> struct has_trivial_copy<void volatile> : public false_type{};
template <> struct has_trivial_copy<void const volatile> : public false_type{};


template <class T> struct has_trivial_copy<T&> : public false_type{};

template <class T> struct has_trivial_copy<T&&> : public false_type{};


template <class T> struct has_trivial_copy_constructor : public has_trivial_copy<T>{};



}
# 34 "/usr/local/include/boost/python/detail/type_traits.hpp" 2 3


namespace boost { namespace python { namespace detail {
# 72 "/usr/local/include/boost/python/detail/type_traits.hpp" 3
    using std::alignment_of;
    using std::add_const;
    using std::add_cv;
    using std::add_lvalue_reference;
    using std::add_pointer;

    using std::is_array;
    using std::is_class;
    using std::is_const;
    using std::is_convertible;
    using std::is_enum;
    using std::is_function;
    using std::is_integral;
    using std::is_lvalue_reference;
    using std::is_member_function_pointer;
    using std::is_member_pointer;
    using std::is_pointer;
    using std::is_polymorphic;
    using std::is_reference;
    using std::is_same;
    using std::is_scalar;
    using std::is_union;
    using std::is_void;
    using std::is_volatile;

    using std::remove_reference;
    using std::remove_pointer;
    using std::remove_cv;
    using std::remove_const;

    typedef std::integral_constant<bool, true> true_;
    typedef std::integral_constant<bool, false> false_;

    using boost::is_base_and_derived;
    using boost::type_with_alignment;
    using boost::has_trivial_copy;
}}}
# 10 "/usr/local/include/boost/python/cast.hpp" 2 3

# 1 "/usr/local/include/boost/type.hpp" 1 3
# 9 "/usr/local/include/boost/type.hpp" 3
namespace boost {



  template <class T>
  struct type {};

}
# 12 "/usr/local/include/boost/python/cast.hpp" 2 3
# 1 "/usr/local/include/boost/python/base_type_traits.hpp" 1 3
# 10 "/usr/local/include/boost/python/base_type_traits.hpp" 3
namespace boost { namespace python {

namespace detail
{
  struct unspecialized {};
}



template <class T> struct base_type_traits
  : detail::unspecialized
{};

template <>
struct base_type_traits<PyObject>
{
    typedef PyObject type;
};

template <>
struct base_type_traits<PyTypeObject>
{
    typedef PyObject type;
};

template <>
struct base_type_traits<PyMethodObject>
{
    typedef PyObject type;
};

}}
# 13 "/usr/local/include/boost/python/cast.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/convertible.hpp" 1 3
# 15 "/usr/local/include/boost/python/detail/convertible.hpp" 3
namespace boost { namespace python { namespace detail {

typedef char* yes_convertible;
typedef int* no_convertible;

template <class Target>
struct convertible
{

    static inline no_convertible check(...) { return 0; }
    static inline yes_convertible check(Target) { return 0; }
# 34 "/usr/local/include/boost/python/detail/convertible.hpp" 3
};

}}}
# 14 "/usr/local/include/boost/python/cast.hpp" 2 3

namespace boost { namespace python {

namespace detail
{
  template <class Source, class Target> inline Target* upcast_impl(Source*, Target*);

  template <class Source, class Target>
  inline Target* upcast(Source* p, yes_convertible, no_convertible, Target*)
  {
      return p;
  }

  template <class Source, class Target>
  inline Target* upcast(Source* p, no_convertible, no_convertible, Target*)
  {
      typedef typename base_type_traits<Source>::type base;

      return detail::upcast_impl((base*)p, (Target*)0);
  }

  template <bool is_same = true>
  struct upcaster
  {
      template <class T>
      static inline T* execute(T* x, T*) { return x; }
  };

  template <>
  struct upcaster<false>
  {
      template <class Source, class Target>
      static inline Target* execute(Source* x, Target*)
      {
          return detail::upcast(
              x, detail::convertible<Target*>::check(x)
              , detail::convertible<Source*>::check((Target*)0)
              , (Target*)0);
      }
  };


  template <class Target, class Source>
  inline Target* downcast(Source* p, yes_convertible)
  {
      return static_cast<Target*>(p);
  }

  template <class Target, class Source>
  inline Target* downcast(Source* p, no_convertible, boost::type<Target>* = 0)
  {
      typedef typename base_type_traits<Source>::type base;
      return (Target*)detail::downcast<base>(p, convertible<Source*>::check((base*)0));
  }

  template <class T>
  inline void assert_castable(boost::type<T>* = 0)
  {
      typedef char must_be_a_complete_type[sizeof(T)] __attribute__((__unused__));
  }

  template <class Source, class Target>
  inline Target* upcast_impl(Source* x, Target*)
  {
      typedef typename detail::add_cv<Source>::type src_t;
      typedef typename detail::add_cv<Target>::type target_t;
      bool const same = detail::is_same<src_t,target_t>::value;

      return detail::upcaster<same>::execute(x, (Target*)0);
  }
}

template <class Target, class Source>
inline Target* upcast(Source* x, Target* = 0)
{
    detail::assert_castable<Source>();
    detail::assert_castable<Target>();
    return detail::upcast_impl(x, (Target*)0);

}

template <class Target, class Source>
inline Target* downcast(Source* x, Target* = 0)
{
    detail::assert_castable<Source>();
    detail::assert_castable<Target>();
    return detail::downcast<Target>(x, detail::convertible<Source*>::check((Target*)0));
}

}}
# 11 "/usr/local/include/boost/python/handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/errors.hpp" 1 3
# 13 "/usr/local/include/boost/python/errors.hpp" 3
# 1 "/usr/local/include/boost/function/function0.hpp" 1 3
# 11 "/usr/local/include/boost/function/function0.hpp" 3
# 1 "/usr/local/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/usr/local/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/include/boost/function/function_template.hpp" 1 3
# 13 "/usr/local/include/boost/function/function_template.hpp" 3
# 1 "/usr/local/include/boost/function/detail/prologue.hpp" 1 3
# 12 "/usr/local/include/boost/function/detail/prologue.hpp" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 13 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/include/c++/7/algorithm" 1 3
# 58 "/usr/include/c++/7/algorithm" 3
       
# 59 "/usr/include/c++/7/algorithm" 3

# 1 "/usr/include/c++/7/utility" 1 3
# 58 "/usr/include/c++/7/utility" 3
       
# 59 "/usr/include/c++/7/utility" 3
# 69 "/usr/include/c++/7/utility" 3
# 1 "/usr/include/c++/7/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/7/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/7/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "/usr/include/c++/7/utility" 2 3
# 1 "/usr/include/c++/7/bits/stl_pair.h" 1 3
# 59 "/usr/include/c++/7/bits/stl_pair.h" 3
# 1 "/usr/include/c++/7/bits/move.h" 1 3
# 34 "/usr/include/c++/7/bits/move.h" 3
# 1 "/usr/include/c++/7/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/7/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/7/bits/concept_check.h" 3
# 35 "/usr/include/c++/7/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 115 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 135 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 166 "/usr/include/c++/7/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 181 "/usr/include/c++/7/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/include/c++/7/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/7/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };







  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 252 "/usr/include/c++/7/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 280 "/usr/include/c++/7/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 521 "/usr/include/c++/7/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 540 "/usr/include/c++/7/bits/stl_pair.h" 3

}
# 71 "/usr/include/c++/7/utility" 2 3





# 1 "/usr/include/c++/7/initializer_list" 1 3
# 33 "/usr/include/c++/7/initializer_list" 3
       
# 34 "/usr/include/c++/7/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/usr/include/c++/7/utility" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp, typename = void>
    struct __tuple_size_cv_impl { };

  template<typename _Tp>
    struct __tuple_size_cv_impl<_Tp, __void_t<decltype(tuple_size<_Tp>::value)>>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };



  template<typename _Tp>
    struct tuple_size<const _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp> : __tuple_size_cv_impl<_Tp> { };
# 128 "/usr/include/c++/7/utility" 3
  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 402 "/usr/include/c++/7/utility" 3

}
# 61 "/usr/include/c++/7/algorithm" 2 3
# 1 "/usr/include/c++/7/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/7/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/7/bits/functexcept.h" 1 3
# 40 "/usr/include/c++/7/bits/functexcept.h" 3
# 1 "/usr/include/c++/7/bits/exception_defines.h" 1 3
# 41 "/usr/include/c++/7/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/7/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/7/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/7/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/7/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/7/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/7/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "/usr/include/c++/7/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/7/debug/assertions.h" 1 3
# 66 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 195 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/7/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_iterator.h" 1 3
# 66 "/usr/include/c++/7/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/7/bits/ptr_traits.h" 1 3
# 37 "/usr/include/c++/7/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "/usr/include/c++/7/bits/stl_iterator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 100 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 126 "/usr/include/c++/7/bits/stl_iterator.h" 3
     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 168 "/usr/include/c++/7/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
# 182 "/usr/include/c++/7/bits/stl_iterator.h" 3
      pointer
      operator->() const
      { return std::__addressof(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 300 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 390 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 454 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 489 "/usr/include/c++/7/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 531 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 546 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 580 "/usr/include/c++/7/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 622 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 641 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 692 "/usr/include/c++/7/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 736 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 760 "/usr/include/c++/7/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 860 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 1012 "/usr/include/c++/7/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/7/debug/debug.h" 1 3
# 48 "/usr/include/c++/7/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/7/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/7/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/7/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 118 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "/usr/include/c++/7/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1039 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "/usr/include/c++/7/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 62 "/usr/include/c++/7/algorithm" 2 3
# 1 "/usr/include/c++/7/bits/stl_algo.h" 1 3
# 59 "/usr/include/c++/7/bits/stl_algo.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 60 "/usr/include/c++/7/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/7/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/7/bits/algorithmfwd.h" 3
       
# 34 "/usr/include/c++/7/bits/algorithmfwd.h" 3
# 42 "/usr/include/c++/7/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 195 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);
# 224 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 565 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 594 "/usr/include/c++/7/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "/usr/include/c++/7/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/7/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 187 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 269 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 302 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 358 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 384 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 420 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 447 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 475 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 503 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 527 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 540 "/usr/include/c++/7/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {

     

      ;
      ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/usr/include/c++/7/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/7/bits/stl_tempbuf.h" 1 3
# 60 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
# 1 "/usr/include/c++/7/bits/stl_construct.h" 1 3
# 59 "/usr/include/c++/7/bits/stl_construct.h" 3
# 1 "/usr/include/c++/7/new" 1 3
# 37 "/usr/include/c++/7/new" 3
       
# 38 "/usr/include/c++/7/new" 3


# 1 "/usr/include/c++/7/exception" 1 3
# 33 "/usr/include/c++/7/exception" 3
       
# 34 "/usr/include/c++/7/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/7/bits/exception.h" 1 3
# 34 "/usr/include/c++/7/bits/exception.h" 3
       
# 35 "/usr/include/c++/7/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/7/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/7/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "/usr/include/c++/7/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 132 "/usr/include/c++/7/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/7/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/7/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/7/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/7/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/7/typeinfo" 1 3
# 32 "/usr/include/c++/7/typeinfo" 3
       
# 33 "/usr/include/c++/7/typeinfo" 3



# 1 "/usr/include/c++/7/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/7/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/7/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/7/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/7/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/7/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/include/c++/7/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/7/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/7/new" 1 3
# 41 "/usr/include/c++/7/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/usr/include/c++/7/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/usr/include/c++/7/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 208 "/usr/include/c++/7/bits/exception_ptr.h" 3
    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 143 "/usr/include/c++/7/exception" 2 3
# 1 "/usr/include/c++/7/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/7/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "/usr/include/c++/7/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 144 "/usr/include/c++/7/exception" 2 3
# 41 "/usr/include/c++/7/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "/usr/include/c++/7/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 168 "/usr/include/c++/7/new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 216 "/usr/include/c++/7/new" 3
#pragma GCC visibility pop
# 60 "/usr/include/c++/7/bits/stl_construct.h" 2 3

# 1 "/usr/include/c++/7/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/7/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/7/ext/alloc_traits.h" 3



# 1 "/usr/include/c++/7/bits/alloc_traits.h" 1 3
# 35 "/usr/include/c++/7/bits/alloc_traits.h" 3
# 1 "/usr/include/c++/7/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/7/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/7/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/7/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 36 "/usr/include/c++/7/bits/alloc_traits.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 299 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 314 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 326 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 341 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 354 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 366 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 377 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 434 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 448 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 460 "/usr/include/c++/7/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 472 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 484 "/usr/include/c++/7/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "/usr/include/c++/7/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "/usr/include/c++/7/ext/alloc_traits.h" 3
  };


}
# 62 "/usr/include/c++/7/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "/usr/include/c++/7/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
# 232 "/usr/include/c++/7/bits/stl_construct.h" 3

}
# 61 "/usr/include/c++/7/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/include/c++/7/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "/usr/include/c++/7/bits/stl_algo.h" 2 3



# 1 "/usr/include/c++/7/bits/uniform_int_dist.h" 1 3
# 35 "/usr/include/c++/7/bits/uniform_int_dist.h" 3
# 1 "/usr/include/c++/7/limits" 1 3
# 40 "/usr/include/c++/7/limits" 3
       
# 41 "/usr/include/c++/7/limits" 3
# 158 "/usr/include/c++/7/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/7/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/7/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/7/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "/usr/include/c++/7/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1570 "/usr/include/c++/7/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1593 "/usr/include/c++/7/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "/usr/include/c++/7/bits/uniform_int_dist.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {


    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };

  }








  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 267 "/usr/include/c++/7/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 351 "/usr/include/c++/7/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/usr/include/c++/7/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 601 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 668 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 700 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 734 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 797 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 825 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 894 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 927 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 993 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1023 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1178 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1205 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1432 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1469 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1546 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1649 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1735 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1749 "/usr/include/c++/7/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1784 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1800 "/usr/include/c++/7/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2021 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2075 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2105 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2176 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2212 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2245 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2278 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2572 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2613 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2785 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2824 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2868 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2903 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2952 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2984 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3052 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3084 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3134 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3168 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3207 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3221 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3250 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3274 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3299 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3320 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3400 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3428 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3540 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3571 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3664 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3691 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3767 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3789 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







# 3876 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3897 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3921 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3952 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3992 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4024 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4049 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4074 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4097 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4137 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4176 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4211 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4244 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4292 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4329 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4362 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4394 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4426 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4457 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 4493 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4533 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4566 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4601 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4641 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4674 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4712 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4748 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4787 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4824 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4854 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4915 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4965 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5029 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5063 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5131 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5180 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5250 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5298 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5370 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5420 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5498 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5548 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5601 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5626 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5665 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5690 "/usr/include/c++/7/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
           typename _Size, typename _UniformRandomBitGenerator>
    _RandomAccessIterator
    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      __distrib_type __d{};
      _Size __sample_sz = 0;
      while (__first != __last && __sample_sz != __n)
 {
   __out[__sample_sz++] = *__first;
   ++__first;
 }
      for (auto __pop_sz = __sample_sz; __first != __last;
   ++__first, (void) ++__pop_sz)
 {
   const auto __k = __d(__g, __param_type{0, __pop_sz});
   if (__k < __n)
     __out[__k] = *__first;
 }
      return __out + __sample_sz;
    }


  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
           typename _Size, typename _UniformRandomBitGenerator>
    _OutputIterator
    __sample(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag,
      _OutputIterator __out, _Cat,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      using _USize = make_unsigned_t<_Size>;
      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

      __distrib_type __d{};
      _Size __unsampled_sz = std::distance(__first, __last);
      __n = std::min(__n, __unsampled_sz);




      const __uc_type __urngrange = __g.max() - __g.min();
      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))


        {
   while (__n != 0 && __unsampled_sz >= 2)
     {
       const pair<_Size, _Size> __p =
  __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

       --__unsampled_sz;
       if (__p.first < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;

       if (__n == 0) break;

       --__unsampled_sz;
       if (__p.second < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;
     }
        }



      for (; __n != 0; ++__first)
 if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
   {
     *__out++ = *__first;
     --__n;
   }
      return __out;
    }
# 5833 "/usr/include/c++/7/bits/stl_algo.h" 3

}
# 63 "/usr/include/c++/7/algorithm" 2 3
# 14 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/include/boost/config/no_tr1/functional.hpp" 1 3
# 21 "/usr/local/include/boost/config/no_tr1/functional.hpp" 3
# 1 "/usr/include/c++/7/functional" 1 3
# 46 "/usr/include/c++/7/functional" 3
       
# 47 "/usr/include/c++/7/functional" 3


# 1 "/usr/include/c++/7/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/7/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/include/c++/7/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "/usr/include/c++/7/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/7/backward/binders.h" 1 3
# 60 "/usr/include/c++/7/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/7/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "/usr/include/c++/7/bits/stl_function.h" 2 3
# 50 "/usr/include/c++/7/functional" 2 3




# 1 "/usr/include/c++/7/tuple" 1 3
# 32 "/usr/include/c++/7/tuple" 3
       
# 33 "/usr/include/c++/7/tuple" 3






# 1 "/usr/include/c++/7/array" 1 3
# 32 "/usr/include/c++/7/array" 3
       
# 33 "/usr/include/c++/7/array" 3






# 1 "/usr/include/c++/7/stdexcept" 1 3
# 36 "/usr/include/c++/7/stdexcept" 3
       
# 37 "/usr/include/c++/7/stdexcept" 3


# 1 "/usr/include/c++/7/string" 1 3
# 36 "/usr/include/c++/7/string" 3
       
# 37 "/usr/include/c++/7/string" 3


# 1 "/usr/include/c++/7/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/7/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/7/bits/stringfwd.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/7/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/7/bits/char_traits.h" 3


# 1 "/usr/include/c++/7/bits/postypes.h" 1 3
# 38 "/usr/include/c++/7/bits/postypes.h" 3
       
# 39 "/usr/include/c++/7/bits/postypes.h" 3

# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3
# 62 "/usr/include/c++/7/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/7/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/usr/include/c++/7/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/include/c++/7/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/include/c++/7/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/7/bits/postypes.h" 2 3
# 68 "/usr/include/c++/7/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/7/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/7/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/7/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/7/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/7/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3
# 42 "/usr/include/c++/7/bits/char_traits.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 61 "/usr/include/c++/7/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/usr/include/c++/7/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 268 "/usr/include/c++/7/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 else
   return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {





   return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 else
   return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/usr/include/c++/7/cstdint" 1 3
# 32 "/usr/include/c++/7/cstdint" 3
       
# 33 "/usr/include/c++/7/cstdint" 3
# 46 "/usr/include/c++/7/cstdint" 3
namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 502 "/usr/include/c++/7/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/allocator.h" 1 3
# 46 "/usr/include/c++/7/bits/allocator.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 1 3
# 33 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 3
# 1 "/usr/include/c++/7/ext/new_allocator.h" 1 3
# 40 "/usr/include/c++/7/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/7/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
# 111 "/usr/include/c++/7/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {







 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }
# 151 "/usr/include/c++/7/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/7/bits/allocator.h" 2 3
# 57 "/usr/include/c++/7/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }

    };
# 107 "/usr/include/c++/7/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
 allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/include/c++/7/string" 2 3

# 1 "/usr/include/c++/7/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/7/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/7/bits/localefwd.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 3
       
# 40 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 3

# 1 "/usr/include/c++/7/clocale" 1 3
# 39 "/usr/include/c++/7/clocale" 3
       
# 40 "/usr/include/c++/7/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/7/clocale" 2 3
# 51 "/usr/include/c++/7/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/7/bits/localefwd.h" 2 3
# 1 "/usr/include/c++/7/iosfwd" 1 3
# 36 "/usr/include/c++/7/iosfwd" 3
       
# 37 "/usr/include/c++/7/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/7/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 42 "/usr/include/c++/7/bits/localefwd.h" 2 3
# 1 "/usr/include/c++/7/cctype" 1 3
# 39 "/usr/include/c++/7/cctype" 3
       
# 40 "/usr/include/c++/7/cctype" 3
# 62 "/usr/include/c++/7/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/7/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/7/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 44 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/7/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/7/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/7/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/7/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/7/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/7/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/7/string" 2 3






# 1 "/usr/include/c++/7/bits/range_access.h" 1 3
# 33 "/usr/include/c++/7/bits/range_access.h" 3
       
# 34 "/usr/include/c++/7/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 323 "/usr/include/c++/7/bits/range_access.h" 3

}
# 52 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/7/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/7/bits/basic_string.h" 3

# 1 "/usr/include/c++/7/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/7/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/7/ext/atomicity.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 1 3
# 30 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 1 3
# 35 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
{
  int sched_priority;
};

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 743 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1160 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 2 3
# 47 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/7/ext/atomicity.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/atomic_word.h" 1 3
# 32 "/usr/include/x86_64-linux-gnu/c++/7/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/7/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/7/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/7/bits/basic_string.h" 2 3
# 52 "/usr/include/c++/7/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;
# 139 "/usr/include/c++/7/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 298 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 450 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 481 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 499 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 531 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 599 "/usr/include/c++/7/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 646 "/usr/include/c++/7/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 703 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 721 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 815 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 944 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 957 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1006 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1035 "/usr/include/c++/7/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1052 "/usr/include/c++/7/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1073 "/usr/include/c++/7/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1094 "/usr/include/c++/7/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1157 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1210 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1227 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1269 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1293 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1338 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1369 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1392 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1408 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1424 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1441 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1454 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1522 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1564 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1600 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1620 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1643 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1666 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1685 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1709 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1727 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1787 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1806 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1825 "/usr/include/c++/7/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1869 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1891 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1916 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1941 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1965 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1983 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2003 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2025 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2046 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2071 "/usr/include/c++/7/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2103 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2162 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2221 "/usr/include/c++/7/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2259 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2269 "/usr/include/c++/7/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2279 "/usr/include/c++/7/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2291 "/usr/include/c++/7/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2310 "/usr/include/c++/7/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2326 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2340 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2372 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2389 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2402 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2436 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2450 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2467 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2481 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2516 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2530 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2550 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2565 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2600 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2614 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2634 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2648 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2683 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2697 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2715 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2730 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2765 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2779 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2797 "/usr/include/c++/7/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2813 "/usr/include/c++/7/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2832 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2925 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2951 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2969 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 2993 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3020 "/usr/include/c++/7/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5886 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6007 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6054 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6092 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6130 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6168 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6206 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6244 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6264 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6282 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6305 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6322 "/usr/include/c++/7/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/7/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/7/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/7/ext/string_conversions.h" 3
# 41 "/usr/include/c++/7/ext/string_conversions.h" 3
# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 42 "/usr/include/c++/7/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3
# 43 "/usr/include/c++/7/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 96 "/usr/include/c++/7/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/7/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/7/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/7/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/7/cerrno" 1 3
# 39 "/usr/include/c++/7/cerrno" 3
       
# 40 "/usr/include/c++/7/cerrno" 3
# 45 "/usr/include/c++/7/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6362 "/usr/include/c++/7/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/usr/include/c++/7/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/7/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/7/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/7/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/include/c++/7/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 187 "/usr/include/c++/7/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6588 "/usr/include/c++/7/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };








  inline namespace literals
  {
  inline namespace string_literals
  {


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }



  }
  }



}
# 53 "/usr/include/c++/7/string" 2 3
# 1 "/usr/include/c++/7/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/7/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/7/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1155 "/usr/include/c++/7/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1607 "/usr/include/c++/7/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/include/c++/7/string" 2 3
# 40 "/usr/include/c++/7/stdexcept" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/7/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 40 "/usr/include/c++/7/array" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/include/c++/7/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/usr/include/c++/7/array" 3
  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/7/tuple" 2 3
# 1 "/usr/include/c++/7/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/7/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),
          __ptr, std::forward<_Args>(__args)...);
    }


}
# 41 "/usr/include/c++/7/tuple" 2 3
# 1 "/usr/include/c++/7/bits/invoke.h" 1 3
# 33 "/usr/include/c++/7/bits/invoke.h" 3
       
# 34 "/usr/include/c++/7/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/7/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "/usr/include/c++/7/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "/usr/include/c++/7/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };
# 889 "/usr/include/c++/7/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1278 "/usr/include/c++/7/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1695 "/usr/include/c++/7/tuple" 3

}
# 55 "/usr/include/c++/7/functional" 2 3



# 1 "/usr/include/c++/7/bits/std_function.h" 1 3
# 33 "/usr/include/c++/7/bits/std_function.h" 3
       
# 34 "/usr/include/c++/7/bits/std_function.h" 3
# 44 "/usr/include/c++/7/bits/std_function.h" 3
# 1 "/usr/include/c++/7/bits/refwrap.h" 1 3
# 33 "/usr/include/c++/7/bits/refwrap.h" 3
       
# 34 "/usr/include/c++/7/bits/refwrap.h" 3
# 43 "/usr/include/c++/7/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes...) >
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes......) >
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) >
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const
      >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile
      >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile
      >
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile >
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    >
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile >
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg1
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg1<_Tp,
         __void_t<typename _Tp::argument_type>>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg2
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg2<_Tp,
         __void_t<typename _Tp::first_argument_type,
           typename _Tp::second_argument_type>>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(_T1) >
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(*)(_T1) >
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() >
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) >
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() const >
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const >
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile >
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile >
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile >
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile >
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }




}
# 45 "/usr/include/c++/7/bits/std_function.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };







  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { ::new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      template<typename _Func,
        typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 432 "/usr/include/c++/7/bits/std_function.h" 3
      function(const function& __x);
# 441 "/usr/include/c++/7/bits/std_function.h" 3
      function(function&& __x) noexcept : _Function_base()
      {
 __x.swap(*this);
      }
# 462 "/usr/include/c++/7/bits/std_function.h" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 479 "/usr/include/c++/7/bits/std_function.h" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 497 "/usr/include/c++/7/bits/std_function.h" 3
      function&
      operator=(function&& __x) noexcept
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 511 "/usr/include/c++/7/bits/std_function.h" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 539 "/usr/include/c++/7/bits/std_function.h" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 565 "/usr/include/c++/7/bits/std_function.h" 3
      void swap(function& __x) noexcept
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 582 "/usr/include/c++/7/bits/std_function.h" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 595 "/usr/include/c++/7/bits/std_function.h" 3
      _Res operator()(_ArgTypes... __args) const;
# 608 "/usr/include/c++/7/bits/std_function.h" 3
      const type_info& target_type() const noexcept;
# 621 "/usr/include/c++/7/bits/std_function.h" 3
      template<typename _Functor> _Functor* target() noexcept;

      template<typename _Functor> const _Functor* target() const noexcept;



    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };
# 670 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 const function* __const_this = this;
 const _Functor* __func = __const_this->template target<_Functor>();
 return const_cast<_Functor*>(__func);
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return nullptr;
      }
# 762 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 780 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 801 "/usr/include/c++/7/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
    { __x.swap(__y); }


}
# 59 "/usr/include/c++/7/functional" 2 3
# 67 "/usr/include/c++/7/functional" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 85 "/usr/include/c++/7/functional" 3
  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 134 "/usr/include/c++/7/functional" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
# 147 "/usr/include/c++/7/functional" 3
  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _MemberPointer>
    struct _Mem_fn;

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 219 "/usr/include/c++/7/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 234 "/usr/include/c++/7/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 245 "/usr/include/c++/7/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };
# 260 "/usr/include/c++/7/functional" 3
  template<int _Num> struct _Placeholder { };

 





  namespace placeholders
  {
 




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
 
  }

 






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
# 342 "/usr/include/c++/7/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::get<_Indexes>(std::move(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return
     ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }

      template<typename _BoundArg, typename _CallArgs>
 using _Mu_type = decltype(
     _Mu<typename remove_cv<_BoundArg>::type>()(
       std::declval<_BoundArg&>(), std::declval<_CallArgs&>()) );

      template<typename _Fn, typename _CallArgs, typename... _BArgs>
 using _Res_type_impl
   = typename result_of< _Fn&(_Mu_type<_BArgs, _CallArgs>&&...) >::type;

      template<typename _CallArgs>
 using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

      template<typename _CallArgs>
 using __dependent = typename
   enable_if<bool(tuple_size<_CallArgs>::value+1), _Functor>::type;

      template<typename _CallArgs, template<class> class __cv_quals>
 using _Res_type_cv = _Res_type_impl<
   typename __cv_quals<__dependent<_CallArgs>>::type,
   _CallArgs,
   typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args,
        typename _Result = _Res_type<tuple<_Args...>>>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
# 572 "/usr/include/c++/7/functional" 3
      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>

 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_cv>>

 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 using __enable_if_void
   = typename enable_if<is_void<_Res>{}>::type;

      template<typename _Res>
 using __disable_if_void
   = typename enable_if<!is_void<_Res>{}, _Result>::type;


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };






  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }



  template<typename _Fn>
    class _Not_fn
    {
      template<typename _Fn2, typename... _Args>
 using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

      template<typename _Tp>
 static decltype(!std::declval<_Tp>())
 _S_not() noexcept(noexcept(!std::declval<_Tp>()));

    public:
      template<typename _Fn2>
 _Not_fn(_Fn2&& __fn, int)
 : _M_fn(std::forward<_Fn2>(__fn)) { }

      _Not_fn(const _Not_fn& __fn) = default;
      _Not_fn(_Not_fn&& __fn) = default;
      ~_Not_fn() = default;
# 940 "/usr/include/c++/7/functional" 3
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &, _Args...>>()) operator()(_Args&&... __args) & noexcept(__is_nothrow_invocable<_Fn &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) { return !std::__invoke(std::forward< _Fn & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>()) operator()(_Args&&... __args) const & noexcept(__is_nothrow_invocable<_Fn const &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) { return !std::__invoke(std::forward< _Fn const & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>()) operator()(_Args&&... __args) && noexcept(__is_nothrow_invocable<_Fn &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn && >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>()) operator()(_Args&&... __args) const && noexcept(__is_nothrow_invocable<_Fn const &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn const && >(_M_fn), std::forward<_Args>(__args)...); }


    private:
      _Fn _M_fn;
    };
# 1245 "/usr/include/c++/7/functional" 3

}
# 22 "/usr/local/include/boost/config/no_tr1/functional.hpp" 2 3
# 15 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/include/boost/throw_exception.hpp" 1 3
# 36 "/usr/local/include/boost/throw_exception.hpp" 3
# 1 "/usr/local/include/boost/exception/exception.hpp" 1 3
# 15 "/usr/local/include/boost/exception/exception.hpp" 3
namespace boost { template <class T> class shared_ptr; }
namespace boost { namespace exception_detail { using boost::shared_ptr; } }



       
# 21 "/usr/local/include/boost/exception/exception.hpp" 3





namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    class
    __attribute__((__visibility__("default")))
    exception;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

            protected:

            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        template <class>
        struct set_info_rv;

        template <>
        struct set_info_rv<throw_function>;

        template <>
        struct set_info_rv<throw_file>;

        template <>
        struct set_info_rv<throw_line>;

        char const * get_diagnostic_information( exception const &, char const * );

        void copy_boost_exception( exception *, exception const * );

        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );

        template <class E>
        E const & set_info( E const &, throw_function const & );

        template <class E>
        E const & set_info( E const &, throw_file const & );

        template <class E>
        E const & set_info( E const &, throw_line const & );
        }

    class
    __attribute__((__visibility__("default")))
    exception
        {

        public:
        template <class Tag> void set( typename Tag::type const & );
        template <class Tag> typename Tag::type const * get() const;


        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
# 245 "/usr/local/include/boost/exception/exception.hpp" 3
        virtual ~exception() throw()

            = 0

            ;




        private:

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );

        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );

        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        template <class>
        friend struct exception_detail::set_info_rv;
        friend struct exception_detail::set_info_rv<throw_function>;
        friend struct exception_detail::set_info_rv<throw_file>;
        friend struct exception_detail::set_info_rv<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };

    inline
    exception::
    ~exception() throw()
        {
        }

    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }



    namespace
    exception_detail
        {
        template <class T>
        struct
        __attribute__((__visibility__("default")))
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };

        struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );

        struct small_size { };
        small_size dispatch_boost_exception( void const * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {
        class
        __attribute__((__visibility__("default")))
        clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };

        inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        __attribute__((__visibility__("default")))
        clone_impl:
            public T,
            public virtual clone_base
            {
            struct clone_tag { };
            clone_impl( clone_impl const & x, clone_tag ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this,clone_tag());
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }

    template <class T>
    struct
    __attribute__((__visibility__("default")))
    wrapexcept:
        public exception_detail::clone_impl<typename exception_detail::enable_error_info_return_type<T>::type>
        {
        typedef exception_detail::clone_impl<typename exception_detail::enable_error_info_return_type<T>::type> base_type;
        public:
        explicit
        wrapexcept( typename exception_detail::enable_error_info_return_type<T>::type const & x ):
            base_type( x )
            {
            }

        ~wrapexcept() throw()
            {
            }
        };

    namespace
    exception_detail
        {
        template <class T>
        struct
        remove_error_info_injector
            {
            typedef T type;
            };

        template <class T>
        struct
        remove_error_info_injector< error_info_injector<T> >
            {
            typedef T type;
            };

        template <class T>
        inline
        wrapexcept<typename remove_error_info_injector<T>::type>
        enable_both( T const & x )
            {
            return wrapexcept<typename remove_error_info_injector<T>::type>( enable_error_info( x ) );
            }
        }
    }
# 37 "/usr/local/include/boost/throw_exception.hpp" 2 3

# 1 "/usr/local/include/boost/current_function.hpp" 1 3
# 22 "/usr/local/include/boost/current_function.hpp" 3
namespace boost
{

namespace detail
{

inline void current_function_helper()
{
# 69 "/usr/local/include/boost/current_function.hpp" 3
}

}

}
# 39 "/usr/local/include/boost/throw_exception.hpp" 2 3
# 47 "/usr/local/include/boost/throw_exception.hpp" 3
       
# 48 "/usr/local/include/boost/throw_exception.hpp" 3





namespace boost
{






inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__ ((__noreturn__)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw exception_detail::enable_both( e );



}




    namespace
    exception_detail
    {
        template <class E>
        __attribute__ ((__noreturn__))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }

}
# 16 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3

# 1 "/usr/local/include/boost/function/function_base.hpp" 1 3
# 16 "/usr/local/include/boost/function/function_base.hpp" 3
# 1 "/usr/include/c++/7/memory" 1 3
# 46 "/usr/include/c++/7/memory" 3
       
# 47 "/usr/include/c++/7/memory" 3
# 65 "/usr/include/c++/7/memory" 3
# 1 "/usr/include/c++/7/bits/stl_uninitialized.h" 1 3
# 67 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 179 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 242 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 378 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 810 "/usr/include/c++/7/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 882 "/usr/include/c++/7/bits/stl_uninitialized.h" 3

}
# 66 "/usr/include/c++/7/memory" 2 3

# 1 "/usr/include/c++/7/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/include/c++/7/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }




      raw_storage_iterator&
      operator=(_Tp&& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), std::move(__element));
 return *this;
      }


      raw_storage_iterator&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator
      operator++(int)
      {
 raw_storage_iterator __tmp = *this;
 ++_M_iter;
 return __tmp;
      }



      _OutputIterator base() const { return _M_iter; }
    };


}
# 68 "/usr/include/c++/7/memory" 2 3






# 1 "/usr/include/c++/7/ext/concurrence.h" 1 3
# 32 "/usr/include/c++/7/ext/concurrence.h" 3
       
# 33 "/usr/include/c++/7/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;
# 67 "/usr/include/c++/7/ext/concurrence.h" 3
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 147 "/usr/include/c++/7/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 202 "/usr/include/c++/7/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 280 "/usr/include/c++/7/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 75 "/usr/include/c++/7/memory" 2 3





# 1 "/usr/include/c++/7/bits/unique_ptr.h" 1 3
# 41 "/usr/include/c++/7/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 101 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };

  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <class _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                __not_<is_array<_Up>>,
                __or_<__and_<is_reference<deleter_type>,
                             is_same<deleter_type, _Ep>>,
                      __and_<__not_<is_reference<deleter_type>>,
                             is_convertible<_Ep, deleter_type>>
                >
              >;




      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 212 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 224 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 280 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 295 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(_M_t._M_ptr(), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _Up_up = unique_ptr<_Up, _Ep>,
        typename _Up_element_type = typename _Up_up::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<typename _Up_up::pointer, _Up_element_type*>,
          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
                __and_<__not_<is_reference<deleter_type>>,
                       is_convertible<_Ep, deleter_type>>>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 464 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 482 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 498 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion_up<_Up, _Ep>>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 539 "/usr/include/c++/7/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 554 "/usr/include/c++/7/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 pointer __ptr = __p;
 using std::swap;
 swap(_M_t._M_ptr(), __ptr);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
    private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
# 81 "/usr/include/c++/7/memory" 2 3
# 1 "/usr/include/c++/7/bits/shared_ptr.h" 1 3
# 52 "/usr/include/c++/7/bits/shared_ptr.h" 3
# 1 "/usr/include/c++/7/bits/shared_ptr_base.h" 1 3
# 55 "/usr/include/c++/7/bits/shared_ptr_base.h" 3
# 1 "/usr/include/c++/7/bits/allocated_ptr.h" 1 3
# 40 "/usr/include/c++/7/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return _S_raw_ptr(_M_ptr); }

    private:
      static value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }

      template<typename _Ptr>
 static auto
 _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))
 { return _S_raw_ptr(__ptr.operator->()); }

      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 56 "/usr/include/c++/7/bits/shared_ptr_base.h" 2 3


# 1 "/usr/include/c++/7/ext/aligned_buffer.h" 1 3
# 32 "/usr/include/c++/7/ext/aligned_buffer.h" 3
       
# 33 "/usr/include/c++/7/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {



      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };






  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };

}
# 59 "/usr/include/c++/7/bits/shared_ptr_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename> class auto_ptr;






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const* what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
            ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
  __atomic_thread_fence (4);
       }


            ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
            ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


  __atomic_thread_fence (4);
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, std::move(__d), _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, std::move(__d), __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag { };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;

      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }


      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {

 if (__ti == typeid(_Sp_make_shared_tag))
   return const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());

 return nullptr;
      }

    private:
      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  struct __sp_array_delete
  {
    template<typename _Yp>
      void operator()(_Yp* __p) const { delete[] __p; }
  };

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr>
 __shared_count(_Ptr __p, false_type)
 : __shared_count(__p)
 { }

      template<typename _Ptr>
 __shared_count(_Ptr __p, true_type)
 : __shared_count(__p, __sp_array_delete{}, allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
         _Args&&... __args)
 : _M_pi(0)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   ::new (__mem) _Sp_cp_type(std::move(__a),
        std::forward<_Args>(__args)...);
   _M_pi = __mem;
   __guard = nullptr;
 }



      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {


   if (__r.get() == nullptr)
     return;

   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }







  template<typename _Yp_ptr, typename _Tp_ptr>
    struct __sp_compatible_with
    : false_type
    { };

  template<typename _Yp, typename _Tp>
    struct __sp_compatible_with<_Yp*, _Tp*>
    : is_convertible<_Yp*, _Tp*>::type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
    : true_type
    { };


  template<typename _Up, size_t _Nm, typename _Yp, typename = void>
    struct __sp_is_constructible_arrN
    : false_type
    { };

  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type
    { };


  template<typename _Up, typename _Yp, typename = void>
    struct __sp_is_constructible_arr
    : false_type
    { };

  template<typename _Up, typename _Yp>
    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
    : is_convertible<_Yp(*)[], _Up(*)[]>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible;


  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible<_Up[_Nm], _Yp>
    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type
    { };


  template<typename _Up, typename _Yp>
    struct __sp_is_constructible<_Up[], _Yp>
    : __sp_is_constructible_arr<_Up, _Yp>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible
    : is_convertible<_Yp*, _Tp*>::type
    { };



  template<typename _Tp, _Lock_policy _Lp,
    bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
    class __shared_ptr_access
    {
    public:
      using element_type = _Tp;

      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, false, true>
    {
    public:
      using element_type = _Tp;

      element_type*
      operator->() const noexcept
      {
 auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();
 ;
 return __ptr;
      }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, true, false>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;


      [[__deprecated__("shared_ptr<T[]>::operator* is absent from C++17")]]
      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      [[__deprecated__("shared_ptr<T[]>::operator-> is absent from C++17")]]
      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }


      element_type&
      operator[](ptrdiff_t __i) const
      {
 ;
 ;
 return _M_get()[__i];
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    : public __shared_ptr_access<_Tp, _Lp>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;

    private:

      template<typename _Yp>
 using _SafeConv
   = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;


      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __shared_ptr&>;


      template<typename _Yp, typename _Del, typename _Res = void,
        typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
 using _UniqCompatible = typename enable_if<__and_<
   __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>
   >::value, _Res>::type;


      template<typename _Yp, typename _Del>
 using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;

    public:





      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Yp, typename = _SafeConv<_Yp>>
 explicit
 __shared_ptr(_Yp* __p)
 : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 {
   static_assert( !is_void<_Yp>::value, "incomplete type" );
   static_assert( sizeof(_Yp) > 0, "incomplete type" );
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, std::move(__d))
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
 { }

      template<typename _Yp>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Yp, typename = _Compatible<_Yp>>
 explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {


   _M_ptr = __r._M_ptr;
 }


      template<typename _Yp, typename _Del,
        typename = _UniqCompatible<_Yp, _Del>>
 __shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = _S_raw_ptr(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }


    protected:

      template<typename _Tp1, typename _Del,
        typename enable_if<__and_<
   __not_<is_array<_Tp>>, is_array<_Tp1>,
          is_convertible<typename unique_ptr<_Tp1, _Del>::pointer, _Tp*>
        >::value, bool>::type = true>
 __shared_ptr(unique_ptr<_Tp1, _Del>&& __r, __sp_array_delete)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = _S_raw_ptr(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }
    public:




      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(auto_ptr<_Yp>&& __r);


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


      template<typename _Yp>
 _Assignable<_Yp>
 operator=(auto_ptr<_Yp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Yp>
 _Assignable<_Yp>
 operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Yp, typename _Del>
 _UniqAssignable<_Yp, _Del>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Yp>
 _SafeConv<_Yp>
 reset(_Yp* __p)
 {

   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Yp, typename _Deleter>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d)
 { __shared_ptr(__p, std::move(__d)).swap(*this); }

      template<typename _Yp, typename _Deleter, typename _Alloc>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      element_type*
      get() const noexcept
      { return _M_ptr; }

      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }

      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
       _Args&&... __args)
 : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
 {


   void* __p = _M_refcount._M_get_deleter(typeid(__tag));
   _M_ptr = static_cast<_Tp*>(__p);
   _M_enable_shared_from_this_with(_M_ptr);
 }
# 1337 "/usr/include/c++/7/bits/shared_ptr_base.h" 3
      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:

      template<typename _Yp>
 using __esft_base_t = decltype(__enable_shared_from_this_base(
       std::declval<const __shared_count<_Lp>&>(),
       std::declval<_Yp*>()));


      template<typename _Yp, typename = void>
 struct __has_esft_base
 : false_type { };

      template<typename _Yp>
 struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
 : __not_<is_array<_Tp>> { };

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp* __p) noexcept
 {
   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
     __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
 }

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<!__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp*) noexcept
 { }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1>
 static _Tp1*
 _S_raw_ptr(_Tp1* __ptr)
 { return __ptr; }

      template<typename _Tp1>
 static auto
 _S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))
 { return std::__addressof(*__ptr); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      element_type* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Up, _Lp>& __b) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept
      {
 typedef typename _Sp::element_type element_type;
 return std::less<element_type*>()(__lhs.get(), __rhs.get());
      }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1543 "/usr/include/c++/7/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }
# 1589 "/usr/include/c++/7/bits/shared_ptr_base.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __weak_ptr&>;

    public:
      using element_type = typename remove_extent<_Tp>::type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
# 1625 "/usr/include/c++/7/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 if (use_count() == 0)
   {
     _M_ptr = __ptr;
     _M_refcount = __refcount;
   }
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      element_type* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }
    };

  template<>
    struct _Sp_owner_less<void, void>
    {
      template<typename _Tp, typename _Up>
 auto
 operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept
 -> decltype(__lhs.owner_before(__rhs))
 { return __lhs.owner_before(__rhs); }

      using is_transparent = void;
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }


      __weak_ptr<_Tp, _Lp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      __weak_ptr<const _Tp, _Lp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      friend const __enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<_Lp>&,
         const __enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      {
 return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(
     __s.get());
      }
    };


}
# 53 "/usr/include/c++/7/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }


  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 92 "/usr/include/c++/7/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename... _Args>
 using _Constructible = typename enable_if<
   is_constructible<__shared_ptr<_Tp>, _Args...>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&
 >::type;

    public:

      using element_type = typename __shared_ptr<_Tp>::element_type;
# 117 "/usr/include/c++/7/bits/shared_ptr.h" 3
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Yp, typename = _Constructible<_Yp*>>
 explicit
 shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
# 144 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter,
        typename = _Constructible<_Yp*, _Deleter>>
 shared_ptr(_Yp* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 162 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 181 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _Constructible<_Yp*, _Deleter, _Alloc>>
 shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 201 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 223 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 234 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
 shared_ptr(shared_ptr<_Yp>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 264 "/usr/include/c++/7/bits/shared_ptr.h" 3
      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 explicit shared_ptr(const weak_ptr<_Yp>& __r)
 : __shared_ptr<_Tp>(__r) { }


      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
 shared_ptr(auto_ptr<_Yp>&& __r);




      template<typename _Yp, typename _Del,
        typename = _Constructible<unique_ptr<_Yp, _Del>>>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }





      template<typename _Yp, typename _Del,
  _Constructible<unique_ptr<_Yp, _Del>, __sp_array_delete>* = 0>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r), __sp_array_delete()) { }






      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


      template<typename _Yp>
 _Assignable<auto_ptr<_Yp>>
 operator=(auto_ptr<_Yp>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Yp>
 _Assignable<shared_ptr<_Yp>>
 operator=(shared_ptr<_Yp>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Yp, typename _Del>
 _Assignable<unique_ptr<_Yp, _Del>>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
     _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
 { }

      template<typename _Yp, typename _Alloc, typename... _Args>
 friend shared_ptr<_Yp>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };
# 366 "/usr/include/c++/7/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Up>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }

  template<typename _Tp, typename _Up>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      using _Up_elt = typename shared_ptr<_Up>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp, typename _Up>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, typename _Up>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp, typename _Up>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
    { };


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }

  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }

  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }
# 519 "/usr/include/c++/7/bits/shared_ptr.h" 3
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Arg>
 using _Constructible = typename enable_if<
   is_constructible<__weak_ptr<_Tp>, _Arg>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
 >::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 weak_ptr(const shared_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 weak_ptr(const weak_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
 weak_ptr(weak_ptr<_Yp>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<const weak_ptr<_Yp>&>
 operator=(const weak_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<weak_ptr<_Yp>>
 operator=(weak_ptr<_Yp>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };







  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp = void>
    struct owner_less;


  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }



      weak_ptr<_Tp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      weak_ptr<const _Tp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }


      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
         const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 686 "/usr/include/c++/7/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }
# 701 "/usr/include/c++/7/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      {
 return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());
      }
    };




}
# 82 "/usr/include/c++/7/memory" 2 3
# 1 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 1 3
# 33 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3
# 1 "/usr/include/c++/7/bits/atomic_base.h" 1 3
# 33 "/usr/include/c++/7/bits/atomic_base.h" 3
       
# 34 "/usr/include/c++/7/bits/atomic_base.h" 3



# 1 "/usr/include/c++/7/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/7/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/7/bits/atomic_lockfree_defines.h" 3
# 38 "/usr/include/c++/7/bits/atomic_base.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/7/bits/atomic_base.h" 3
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;

  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(__m | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(__m & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | (__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(__m); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(__m); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }



  template<typename _IntTp>
    struct __atomic_base;




  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
# 148 "/usr/include/c++/7/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, __m);
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
# 237 "/usr/include/c++/7/bits/atomic_base.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, __m);
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, __m); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;

 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, __m);
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }
    };




}
# 34 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };







  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
# 96 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
# 132 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
# 169 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
# 218 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }





}
# 83 "/usr/include/c++/7/memory" 2 3

# 1 "/usr/include/c++/7/backward/auto_ptr.h" 1 3
# 36 "/usr/include/c++/7/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/include/c++/7/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));
# 86 "/usr/include/c++/7/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 112 "/usr/include/c++/7/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 124 "/usr/include/c++/7/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 135 "/usr/include/c++/7/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 152 "/usr/include/c++/7/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 170 "/usr/include/c++/7/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 180 "/usr/include/c++/7/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 210 "/usr/include/c++/7/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 224 "/usr/include/c++/7/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 239 "/usr/include/c++/7/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 264 "/usr/include/c++/7/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1, typename>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {
     
      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__tmp);
    }

  template<typename _Tp>
  template<typename _Tp1, typename>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }



}
# 85 "/usr/include/c++/7/memory" 2 3
# 93 "/usr/include/c++/7/memory" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 113 "/usr/include/c++/7/memory" 3
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{
  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if ((__size + __diff) > __space)
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}



enum class pointer_safety { relaxed, preferred, strict };

inline void
declare_reachable(void*) { }

template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }

inline void
declare_no_pointers(char*, size_t) { }

inline void
undeclare_no_pointers(char*, size_t) { }

inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }


}
# 17 "/usr/local/include/boost/function/function_base.hpp" 2 3


# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 20 "/usr/local/include/boost/function/function_base.hpp" 2 3
# 1 "/usr/local/include/boost/integer.hpp" 1 3
# 18 "/usr/local/include/boost/integer.hpp" 3
# 1 "/usr/local/include/boost/integer_fwd.hpp" 1 3
# 12 "/usr/local/include/boost/integer_fwd.hpp" 3
# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 13 "/usr/local/include/boost/integer_fwd.hpp" 2 3



# 1 "/usr/local/include/boost/limits.hpp" 1 3
# 17 "/usr/local/include/boost/integer_fwd.hpp" 2 3
# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 46 "/usr/local/include/boost/cstdint.hpp" 3
       
# 47 "/usr/local/include/boost/cstdint.hpp" 3
# 114 "/usr/local/include/boost/cstdint.hpp" 3
namespace boost
{

  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;

  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;

  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;



  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;



  using ::intmax_t;
  using ::uintmax_t;

}
# 387 "/usr/local/include/boost/cstdint.hpp" 3
namespace boost {
    using ::intptr_t;
    using ::uintptr_t;
}
# 18 "/usr/local/include/boost/integer_fwd.hpp" 2 3


namespace boost
{







     typedef boost::uintmax_t static_min_max_unsigned_type;
     typedef boost::intmax_t static_min_max_signed_type;
     typedef boost::uintmax_t static_log2_argument_type;
     typedef int static_log2_result_type;
# 42 "/usr/local/include/boost/integer_fwd.hpp" 3
template < class T >
    class integer_traits;

template < >
    class integer_traits< bool >;

template < >
    class integer_traits< char >;

template < >
    class integer_traits< signed char >;

template < >
    class integer_traits< unsigned char >;


template < >
    class integer_traits< wchar_t >;


template < >
    class integer_traits< short >;

template < >
    class integer_traits< unsigned short >;

template < >
    class integer_traits< int >;

template < >
    class integer_traits< unsigned int >;

template < >
    class integer_traits< long >;

template < >
    class integer_traits< unsigned long >;


template < >
class integer_traits< ::boost::long_long_type>;

template < >
class integer_traits< ::boost::ulong_long_type >;
# 97 "/usr/local/include/boost/integer_fwd.hpp" 3
template < typename LeastInt >
    struct int_fast_t;

template< int Bits >
    struct int_t;

template< int Bits >
    struct uint_t;


    template< boost::long_long_type MaxValue >



    struct int_max_value_t;


  template< boost::long_long_type MinValue >



    struct int_min_value_t;


  template< boost::ulong_long_type MaxValue >



    struct uint_value_t;




template < std::size_t Bit >
    struct high_bit_mask_t;

template < std::size_t Bits >
    struct low_bits_mask_t;

template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits >;



template <static_log2_argument_type Value >
    struct static_log2;

template <> struct static_log2<0u>;




template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;

template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;


namespace integer
{





     typedef boost::uintmax_t static_gcd_type;


template < static_gcd_type Value1, static_gcd_type Value2 >
    struct static_gcd;
template < static_gcd_type Value1, static_gcd_type Value2 >
    struct static_lcm;




template < typename IntegerType >
    class gcd_evaluator;
template < typename IntegerType >
    class lcm_evaluator;

}

}
# 19 "/usr/local/include/boost/integer.hpp" 2 3

# 1 "/usr/local/include/boost/integer_traits.hpp" 1 3
# 23 "/usr/local/include/boost/integer_traits.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 24 "/usr/local/include/boost/integer_traits.hpp" 2 3
# 39 "/usr/local/include/boost/integer_traits.hpp" 3
       
# 40 "/usr/local/include/boost/integer_traits.hpp" 3


namespace boost {
template<class T>
class integer_traits : public std::numeric_limits<T>
{
public:
  static const bool is_integral = false;
};

namespace detail {
template<class T, T min_val, T max_val>
class integer_traits_base
{
public:
  static const bool is_integral = true;
  static const T const_min = min_val;
  static const T const_max = max_val;
};



template<class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;


}

template<>
class integer_traits<bool>
  : public std::numeric_limits<bool>,
    public detail::integer_traits_base<bool, false, true>
{ };

template<>
class integer_traits<char>
  : public std::numeric_limits<char>,
    public detail::integer_traits_base<char, (-0x7f - 1), 0x7f>
{ };

template<>
class integer_traits<signed char>
  : public std::numeric_limits<signed char>,
    public detail::integer_traits_base<signed char, (-0x7f - 1), 0x7f>
{ };

template<>
class integer_traits<unsigned char>
  : public std::numeric_limits<unsigned char>,
    public detail::integer_traits_base<unsigned char, 0, (0x7f * 2 + 1)>
{ };


template<>
class integer_traits<wchar_t>
  : public std::numeric_limits<wchar_t>,



    public detail::integer_traits_base<wchar_t, (-0x7fffffff - 1), 0x7fffffff>
# 125 "/usr/local/include/boost/integer_traits.hpp" 3
{ };


template<>
class integer_traits<short>
  : public std::numeric_limits<short>,
    public detail::integer_traits_base<short, (-0x7fff - 1), 0x7fff>
{ };

template<>
class integer_traits<unsigned short>
  : public std::numeric_limits<unsigned short>,
    public detail::integer_traits_base<unsigned short, 0, (0x7fff * 2 + 1)>
{ };

template<>
class integer_traits<int>
  : public std::numeric_limits<int>,
    public detail::integer_traits_base<int, (-0x7fffffff - 1), 0x7fffffff>
{ };

template<>
class integer_traits<unsigned int>
  : public std::numeric_limits<unsigned int>,
    public detail::integer_traits_base<unsigned int, 0, (0x7fffffff * 2U + 1U)>
{ };

template<>
class integer_traits<long>
  : public std::numeric_limits<long>,
    public detail::integer_traits_base<long, (-0x7fffffffffffffffL - 1L), 0x7fffffffffffffffL>
{ };

template<>
class integer_traits<unsigned long>
  : public std::numeric_limits<unsigned long>,
    public detail::integer_traits_base<unsigned long, 0, (0x7fffffffffffffffL * 2UL + 1UL)>
{ };




template<>
class integer_traits< ::boost::long_long_type>
  : public std::numeric_limits< ::boost::long_long_type>,
    public detail::integer_traits_base< ::boost::long_long_type, (-0x7fffffffffffffffLL -1), 0x7fffffffffffffffLL>
{ };

template<>
class integer_traits< ::boost::ulong_long_type>
  : public std::numeric_limits< ::boost::ulong_long_type>,
    public detail::integer_traits_base< ::boost::ulong_long_type, 0, (0x7fffffffffffffffLL * 2ULL + 1)>
{ };
# 251 "/usr/local/include/boost/integer_traits.hpp" 3
}
# 21 "/usr/local/include/boost/integer.hpp" 2 3

# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 23 "/usr/local/include/boost/integer.hpp" 2 3
# 34 "/usr/local/include/boost/integer.hpp" 3
       
# 35 "/usr/local/include/boost/integer.hpp" 3


namespace boost
{





  template< typename LeastInt >
  struct int_fast_t
  {
     typedef LeastInt fast;
     typedef fast type;
  };

  namespace detail{


  template< int Category > struct int_least_helper {};
  template< int Category > struct uint_least_helper {};





  template<> struct int_least_helper<1> { typedef boost::long_long_type least; };



  template<> struct int_least_helper<2> { typedef long least; };
  template<> struct int_least_helper<3> { typedef int least; };
  template<> struct int_least_helper<4> { typedef short least; };
  template<> struct int_least_helper<5> { typedef signed char least; };

  template<> struct uint_least_helper<1> { typedef boost::ulong_long_type least; };



  template<> struct uint_least_helper<2> { typedef unsigned long least; };
  template<> struct uint_least_helper<3> { typedef unsigned int least; };
  template<> struct uint_least_helper<4> { typedef unsigned short least; };
  template<> struct uint_least_helper<5> { typedef unsigned char least; };

  template <int Bits>
  struct exact_signed_base_helper{};
  template <int Bits>
  struct exact_unsigned_base_helper{};

  template <> struct exact_signed_base_helper<sizeof(signed char)* 8> { typedef signed char exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned char)* 8> { typedef unsigned char exact; };

  template <> struct exact_signed_base_helper<sizeof(short)* 8> { typedef short exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned short)* 8> { typedef unsigned short exact; };


  template <> struct exact_signed_base_helper<sizeof(int)* 8> { typedef int exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned int)* 8> { typedef unsigned int exact; };



  template <> struct exact_signed_base_helper<sizeof(long)* 8> { typedef long exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned long)* 8> { typedef unsigned long exact; };
# 109 "/usr/local/include/boost/integer.hpp" 3
  }




  template< int Bits >
  struct int_t : public boost::detail::exact_signed_base_helper<Bits>
  {
      static_assert(Bits <= (int)(sizeof(boost::intmax_t) * 8), "No suitable signed integer type with the requested number of bits is available.")
                                                                                           ;
      typedef typename boost::detail::int_least_helper
        <

          (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits-1 <= ::std::numeric_limits<long>::digits) +
          (Bits-1 <= ::std::numeric_limits<int>::digits) +
          (Bits-1 <= ::std::numeric_limits<short>::digits) +
          (Bits-1 <= ::std::numeric_limits<signed char>::digits)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< int Bits >
  struct uint_t : public boost::detail::exact_unsigned_base_helper<Bits>
  {
     static_assert(Bits <= (int)(sizeof(boost::uintmax_t) * 8), "No suitable unsigned integer type with the requested number of bits is available.")
                                                                                             ;
# 150 "/usr/local/include/boost/integer.hpp" 3
      typedef typename boost::detail::uint_least_helper
        <

          (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits <= ::std::numeric_limits<unsigned long>::digits) +
          (Bits <= ::std::numeric_limits<unsigned int>::digits) +
          (Bits <= ::std::numeric_limits<unsigned short>::digits) +
          (Bits <= ::std::numeric_limits<unsigned char>::digits)
        >::least least;

      typedef typename int_fast_t<least>::type fast;

  };





  template< boost::long_long_type MaxValue >



  struct int_max_value_t
  {
      typedef typename boost::detail::int_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::long_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<long>::const_max) +
          (MaxValue <= ::boost::integer_traits<int>::const_max) +
          (MaxValue <= ::boost::integer_traits<short>::const_max) +
          (MaxValue <= ::boost::integer_traits<signed char>::const_max)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< boost::long_long_type MinValue >



  struct int_min_value_t
  {
      typedef typename boost::detail::int_least_helper
        <

          (MinValue >= ::boost::integer_traits<boost::long_long_type>::const_min) +



          (MinValue >= ::boost::integer_traits<long>::const_min) +
          (MinValue >= ::boost::integer_traits<int>::const_min) +
          (MinValue >= ::boost::integer_traits<short>::const_min) +
          (MinValue >= ::boost::integer_traits<signed char>::const_min)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };



  template< boost::ulong_long_type MaxValue >



  struct uint_value_t
  {
# 243 "/usr/local/include/boost/integer.hpp" 3
      typedef typename boost::detail::uint_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::ulong_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<unsigned long>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned int>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned short>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned char>::const_max)
        >::least least;

      typedef typename int_fast_t<least>::type fast;
  };


}
# 21 "/usr/local/include/boost/function/function_base.hpp" 2 3
# 1 "/usr/local/include/boost/type_index.hpp" 1 3
# 20 "/usr/local/include/boost/type_index.hpp" 3
        
# 29 "/usr/local/include/boost/type_index.hpp" 3
# 1 "/usr/local/include/boost/type_index/stl_type_index.hpp" 1 3
# 22 "/usr/local/include/boost/type_index/stl_type_index.hpp" 3
# 1 "/usr/local/include/boost/type_index/type_index_facade.hpp" 1 3
# 13 "/usr/local/include/boost/type_index/type_index_facade.hpp" 3
# 1 "/usr/local/include/boost/container_hash/hash_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/container_hash/hash_fwd.hpp" 3
       



namespace boost
{
    template <class T> struct hash;

    template <class T> void hash_combine(std::size_t& seed, T const& v);

    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);





}
# 14 "/usr/local/include/boost/type_index/type_index_facade.hpp" 2 3

# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 71 "/usr/include/c++/7/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 120 "/usr/include/c++/7/cstring" 3

}
# 16 "/usr/local/include/boost/type_index/type_index_facade.hpp" 2 3
# 26 "/usr/local/include/boost/type_index/type_index_facade.hpp" 3
        


namespace boost { namespace typeindex {
# 61 "/usr/local/include/boost/type_index/type_index_facade.hpp" 3
template <class Derived, class TypeInfo>
class type_index_facade {
private:

    constexpr const Derived & derived() const noexcept {
      return *static_cast<Derived const*>(this);
    }

public:
    typedef TypeInfo type_info_t;



    inline const char* name() const noexcept {
        return derived().raw_name();
    }



    inline std::string pretty_name() const {
        return derived().name();
    }



    inline bool equal(const Derived& rhs) const noexcept {
        const char* const left = derived().raw_name();
        const char* const right = rhs.raw_name();
        return left == right || !std::strcmp(left, right);
    }



    inline bool before(const Derived& rhs) const noexcept {
        const char* const left = derived().raw_name();
        const char* const right = rhs.raw_name();
        return left != right && std::strcmp(left, right) < 0;
    }





    inline std::size_t hash_code() const noexcept {
        const char* const name_raw = derived().raw_name();
        return boost::hash_range(name_raw, name_raw + std::strlen(name_raw));
    }
# 150 "/usr/local/include/boost/type_index/type_index_facade.hpp" 3
};


template <class Derived, class TypeInfo>
constexpr inline bool operator == (const type_index_facade<Derived, TypeInfo>& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return static_cast<Derived const&>(lhs).equal(static_cast<Derived const&>(rhs));
}

template <class Derived, class TypeInfo>
constexpr inline bool operator < (const type_index_facade<Derived, TypeInfo>& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return static_cast<Derived const&>(lhs).before(static_cast<Derived const&>(rhs));
}



template <class Derived, class TypeInfo>
constexpr inline bool operator > (const type_index_facade<Derived, TypeInfo>& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return rhs < lhs;
}

template <class Derived, class TypeInfo>
constexpr inline bool operator <= (const type_index_facade<Derived, TypeInfo>& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return !(lhs > rhs);
}

template <class Derived, class TypeInfo>
constexpr inline bool operator >= (const type_index_facade<Derived, TypeInfo>& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return !(lhs < rhs);
}

template <class Derived, class TypeInfo>
constexpr inline bool operator != (const type_index_facade<Derived, TypeInfo>& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return !(lhs == rhs);
}


template <class Derived, class TypeInfo>
inline bool operator == (const TypeInfo& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return Derived(lhs) == rhs;
}

template <class Derived, class TypeInfo>
inline bool operator < (const TypeInfo& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return Derived(lhs) < rhs;
}

template <class Derived, class TypeInfo>
inline bool operator > (const TypeInfo& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return rhs < Derived(lhs);
}

template <class Derived, class TypeInfo>
inline bool operator <= (const TypeInfo& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return !(Derived(lhs) > rhs);
}

template <class Derived, class TypeInfo>
inline bool operator >= (const TypeInfo& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return !(Derived(lhs) < rhs);
}

template <class Derived, class TypeInfo>
inline bool operator != (const TypeInfo& lhs, const type_index_facade<Derived, TypeInfo>& rhs) noexcept {
    return !(Derived(lhs) == rhs);
}


template <class Derived, class TypeInfo>
inline bool operator == (const type_index_facade<Derived, TypeInfo>& lhs, const TypeInfo& rhs) noexcept {
    return lhs == Derived(rhs);
}

template <class Derived, class TypeInfo>
inline bool operator < (const type_index_facade<Derived, TypeInfo>& lhs, const TypeInfo& rhs) noexcept {
    return lhs < Derived(rhs);
}

template <class Derived, class TypeInfo>
inline bool operator > (const type_index_facade<Derived, TypeInfo>& lhs, const TypeInfo& rhs) noexcept {
    return Derived(rhs) < lhs;
}

template <class Derived, class TypeInfo>
inline bool operator <= (const type_index_facade<Derived, TypeInfo>& lhs, const TypeInfo& rhs) noexcept {
    return !(lhs > Derived(rhs));
}

template <class Derived, class TypeInfo>
inline bool operator >= (const type_index_facade<Derived, TypeInfo>& lhs, const TypeInfo& rhs) noexcept {
    return !(lhs < Derived(rhs));
}

template <class Derived, class TypeInfo>
inline bool operator != (const type_index_facade<Derived, TypeInfo>& lhs, const TypeInfo& rhs) noexcept {
    return !(lhs == Derived(rhs));
}
# 276 "/usr/local/include/boost/type_index/type_index_facade.hpp" 3
template <class CharT, class TriatT, class Derived, class TypeInfo>
inline std::basic_ostream<CharT, TriatT>& operator<<(
    std::basic_ostream<CharT, TriatT>& ostr,
    const type_index_facade<Derived, TypeInfo>& ind)
{
    ostr << static_cast<Derived const&>(ind).pretty_name();
    return ostr;
}





template <class Derived, class TypeInfo>
inline std::size_t hash_value(const type_index_facade<Derived, TypeInfo>& lhs) noexcept {
    return static_cast<Derived const&>(lhs).hash_code();
}

}}
# 23 "/usr/local/include/boost/type_index/stl_type_index.hpp" 2 3







# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 31 "/usr/local/include/boost/type_index/stl_type_index.hpp" 2 3



# 1 "/usr/local/include/boost/core/demangle.hpp" 1 3
# 17 "/usr/local/include/boost/core/demangle.hpp" 3
        
# 32 "/usr/local/include/boost/core/demangle.hpp" 3
# 1 "/usr/include/c++/7/cxxabi.h" 1 3
# 44 "/usr/include/c++/7/cxxabi.h" 3
       
# 45 "/usr/include/c++/7/cxxabi.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/7/cxxabi.h" 2 3

# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/cxxabi_tweaks.h" 1 3
# 34 "/usr/include/x86_64-linux-gnu/c++/7/bits/cxxabi_tweaks.h" 3
namespace __cxxabiv1
{
  extern "C"
  {
# 46 "/usr/include/x86_64-linux-gnu/c++/7/bits/cxxabi_tweaks.h" 3
  __extension__ typedef int __guard __attribute__((mode (__DI__)));


  typedef void __cxa_vec_ctor_return_type;


  typedef void __cxa_cdtor_return_type;


  }
}
# 51 "/usr/include/c++/7/cxxabi.h" 2 3




namespace __cxxabiv1
{
  extern "C"
  {


  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);


  void*
  __cxa_vec_new(size_t __element_count, size_t __element_size,
  size_t __padding_size, __cxa_cdtor_type __constructor,
  __cxa_cdtor_type __destructor);

  void*
  __cxa_vec_new2(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*));

  void*
  __cxa_vec_new3(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*, size_t));


  __cxa_vec_ctor_return_type
  __cxa_vec_ctor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor);

  __cxa_vec_ctor_return_type
  __cxa_vec_cctor(void* __dest_array, void* __src_array,
    size_t __element_count, size_t __element_size,
    __cxa_cdtor_return_type (*__constructor) (void*, void*),
    __cxa_cdtor_type __destructor);


  void
  __cxa_vec_dtor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_cleanup(void* __array_address, size_t __element_count, size_t __s,
      __cxa_cdtor_type __destructor) noexcept;


  void
  __cxa_vec_delete(void* __array_address, size_t __element_size,
     size_t __padding_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_delete2(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*));

  void
  __cxa_vec_delete3(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*, size_t));

  int
  __cxa_guard_acquire(__guard*);

  void
  __cxa_guard_release(__guard*) noexcept;

  void
  __cxa_guard_abort(__guard*) noexcept;


  int
  __cxa_atexit(void (*)(void*), void*, void*) noexcept;

  int
  __cxa_finalize(void*);


  int
  __cxa_thread_atexit(void (*)(void*), void*, void *) noexcept;


  void
  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));

  void
  __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));


  void
  __cxa_bad_cast() __attribute__((__noreturn__));

  void
  __cxa_bad_typeid() __attribute__((__noreturn__));

  void
  __cxa_throw_bad_array_new_length() __attribute__((__noreturn__));
# 194 "/usr/include/c++/7/cxxabi.h" 3
  char*
  __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   size_t* __length, int* __status);


  }
}






namespace __cxxabiv1
{

  class __fundamental_type_info : public std::type_info
  {
  public:
    explicit
    __fundamental_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__fundamental_type_info();
  };


  class __array_type_info : public std::type_info
  {
  public:
    explicit
    __array_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__array_type_info();
  };


  class __function_type_info : public std::type_info
  {
  public:
    explicit
    __function_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__function_type_info();

  protected:

    virtual bool
    __is_function_p() const;
  };


  class __enum_type_info : public std::type_info
  {
  public:
    explicit
    __enum_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__enum_type_info();
  };


  class __pbase_type_info : public std::type_info
  {
  public:
    unsigned int __flags;
    const std::type_info* __pointee;

    explicit
    __pbase_type_info(const char* __n, int __quals,
        const std::type_info* __type)
    : std::type_info(__n), __flags(__quals), __pointee(__type)
    { }

    virtual
    ~__pbase_type_info();


    enum __masks
      {
 __const_mask = 0x1,
 __volatile_mask = 0x2,
 __restrict_mask = 0x4,
 __incomplete_mask = 0x8,
 __incomplete_class_mask = 0x10,
 __transaction_safe_mask = 0x20,
 __noexcept_mask = 0x40
      };

  protected:
    __pbase_type_info(const __pbase_type_info&);

    __pbase_type_info&
    operator=(const __pbase_type_info&);


    virtual bool
    __do_catch(const std::type_info* __thr_type, void** __thr_obj,
        unsigned int __outer) const;

    inline virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  inline bool __pbase_type_info::
  __pointer_catch (const __pbase_type_info *thrown_type,
     void **thr_obj,
     unsigned outer) const
  {
    return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);
  }


  class __pointer_type_info : public __pbase_type_info
  {
  public:
    explicit
    __pointer_type_info(const char* __n, int __quals,
   const std::type_info* __type)
    : __pbase_type_info (__n, __quals, __type) { }


    virtual
    ~__pointer_type_info();

  protected:

    virtual bool
    __is_pointer_p() const;

    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  class __class_type_info;


  class __pointer_to_member_type_info : public __pbase_type_info
  {
  public:
    __class_type_info* __context;

    explicit
    __pointer_to_member_type_info(const char* __n, int __quals,
      const std::type_info* __type,
      __class_type_info* __klass)
    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }

    virtual
    ~__pointer_to_member_type_info();

  protected:
    __pointer_to_member_type_info(const __pointer_to_member_type_info&);

    __pointer_to_member_type_info&
    operator=(const __pointer_to_member_type_info&);


    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __base_class_type_info
  {
  public:
    const __class_type_info* __base_type;



    long __offset_flags;


    enum __offset_flags_masks
      {
 __virtual_mask = 0x1,
 __public_mask = 0x2,
 __hwm_bit = 2,
 __offset_shift = 8
      };


    bool
    __is_virtual_p() const
    { return __offset_flags & __virtual_mask; }

    bool
    __is_public_p() const
    { return __offset_flags & __public_mask; }

    ptrdiff_t
    __offset() const
    {



      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
    }
  };


  class __class_type_info : public std::type_info
  {
  public:
    explicit
    __class_type_info (const char *__n) : type_info(__n) { }

    virtual
    ~__class_type_info ();






    enum __sub_kind
      {

 __unknown = 0,



 __not_contained,


 __contained_ambig,


 __contained_virtual_mask = __base_class_type_info::__virtual_mask,


 __contained_public_mask = __base_class_type_info::__public_mask,


 __contained_mask = 1 << __base_class_type_info::__hwm_bit,

 __contained_private = __contained_mask,
 __contained_public = __contained_mask | __contained_public_mask
      };

    struct __upcast_result;
    struct __dyncast_result;

  protected:

    virtual bool
    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;

    virtual bool
    __do_catch(const type_info* __thr_type, void** __thr_obj,
        unsigned __outer) const;

  public:


    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;







    inline __sub_kind
    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
        const __class_type_info* __src_type,
        const void* __src_ptr) const;
# 477 "/usr/include/c++/7/cxxabi.h" 3
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;





    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
  };


  class __si_class_type_info : public __class_type_info
  {
  public:
    const __class_type_info* __base_type;

    explicit
    __si_class_type_info(const char *__n, const __class_type_info *__base)
    : __class_type_info(__n), __base_type(__base) { }

    virtual
    ~__si_class_type_info();

  protected:
    __si_class_type_info(const __si_class_type_info&);

    __si_class_type_info&
    operator=(const __si_class_type_info&);


    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __sub_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info*__dst, const void*__obj,
  __upcast_result& __restrict __result) const;
  };


  class __vmi_class_type_info : public __class_type_info
  {
  public:
    unsigned int __flags;
    unsigned int __base_count;




    __base_class_type_info __base_info[1];

    explicit
    __vmi_class_type_info(const char* __n, int ___flags)
    : __class_type_info(__n), __flags(___flags), __base_count(0) { }

    virtual
    ~__vmi_class_type_info();


    enum __flags_masks
      {
 __non_diamond_repeat_mask = 0x1,
 __diamond_shaped_mask = 0x2,
 __flags_unknown_mask = 0x10
      };

  protected:

    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;
  };


  struct __cxa_exception;
  struct __cxa_refcounted_exception;
  struct __cxa_dependent_exception;
  struct __cxa_eh_globals;

  extern "C"
  {
# 590 "/usr/include/c++/7/cxxabi.h" 3
  void*
  __dynamic_cast(const void* __src_ptr,
   const __class_type_info* __src_type,
   const __class_type_info* __dst_type,
   ptrdiff_t __src2dst);
# 603 "/usr/include/c++/7/cxxabi.h" 3
  __cxa_eh_globals*
  __cxa_get_globals() noexcept __attribute__ ((__const__));

  __cxa_eh_globals*
  __cxa_get_globals_fast() noexcept __attribute__ ((__const__));


  void
  __cxa_free_exception(void*) noexcept;


  void
  __cxa_throw(void*, std::type_info*, void ( *) (void *))
  __attribute__((__noreturn__));


  void*
  __cxa_get_exception_ptr(void*) noexcept __attribute__ ((__pure__));

  void*
  __cxa_begin_catch(void*) noexcept;

  void
  __cxa_end_catch();

  void
  __cxa_rethrow() __attribute__((__noreturn__));



  std::type_info*
  __cxa_current_exception_type() noexcept __attribute__ ((__pure__));




  __cxa_dependent_exception*
  __cxa_allocate_dependent_exception() noexcept;


  void
  __cxa_free_dependent_exception(__cxa_dependent_exception*) noexcept;

  }



  class __foreign_exception
  {
    virtual ~__foreign_exception() throw();
    virtual void __pure_dummy() = 0;
  };

}
# 678 "/usr/include/c++/7/cxxabi.h" 3
namespace abi = __cxxabiv1;

namespace __gnu_cxx
{
# 694 "/usr/include/c++/7/cxxabi.h" 3
  class recursive_init_error: public std::exception
  {
  public:
    recursive_init_error() throw() { }
    virtual ~recursive_init_error() throw ();
  };
}


#pragma GCC visibility pop
# 33 "/usr/local/include/boost/core/demangle.hpp" 2 3






# 1 "/usr/include/c++/7/cstdlib" 1 3
# 39 "/usr/include/c++/7/cstdlib" 3
       
# 40 "/usr/include/c++/7/cstdlib" 3
# 40 "/usr/local/include/boost/core/demangle.hpp" 2 3




namespace boost
{

namespace core
{

inline char const * demangle_alloc( char const * name ) noexcept;
inline void demangle_free( char const * name ) noexcept;

class scoped_demangled_name
{
private:
    char const * m_p;

public:
    explicit scoped_demangled_name( char const * name ) noexcept :
        m_p( demangle_alloc( name ) )
    {
    }

    ~scoped_demangled_name() noexcept
    {
        demangle_free( m_p );
    }

    char const * get() const noexcept
    {
        return m_p;
    }

    scoped_demangled_name( scoped_demangled_name const& ) = delete;
    scoped_demangled_name& operator= ( scoped_demangled_name const& ) = delete;
};




inline char const * demangle_alloc( char const * name ) noexcept
{
    int status = 0;
    std::size_t size = 0;
    return abi::__cxa_demangle( name, __null, &size, &status );
}

inline void demangle_free( char const * name ) noexcept
{
    std::free( const_cast< char* >( name ) );
}

inline std::string demangle( char const * name )
{
    scoped_demangled_name demangled_name( name );
    char const * p = demangled_name.get();
    if( !p )
        p = name;
    return p;
}
# 120 "/usr/local/include/boost/core/demangle.hpp" 3
}

}
# 35 "/usr/local/include/boost/type_index/stl_type_index.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/conditional.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/conditional.hpp" 3
namespace boost {

template <bool b, class T, class U> struct conditional { typedef T type; };
template <class T, class U> struct conditional<false, T, U> { typedef U type; };



   template <bool b, class T, class U> using conditional_t = typename conditional<b, T, U>::type;



}
# 36 "/usr/local/include/boost/type_index/stl_type_index.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_const.hpp" 1 3
# 27 "/usr/local/include/boost/type_traits/is_const.hpp" 3
namespace boost {
# 36 "/usr/local/include/boost/type_traits/is_const.hpp" 3
   template <class T>
   struct is_const : public false_type {};
   template <class T> struct is_const<T const> : public true_type{};
   template <class T, std::size_t N> struct is_const<T const[N]> : public true_type{};
   template <class T> struct is_const<T const[]> : public true_type{};



}
# 37 "/usr/local/include/boost/type_index/stl_type_index.hpp" 2 3

# 1 "/usr/local/include/boost/type_traits/is_volatile.hpp" 1 3
# 27 "/usr/local/include/boost/type_traits/is_volatile.hpp" 3
namespace boost {
# 36 "/usr/local/include/boost/type_traits/is_volatile.hpp" 3
   template <class T>
   struct is_volatile : public false_type {};
   template <class T> struct is_volatile<T volatile> : public true_type{};
   template <class T, std::size_t N> struct is_volatile<T volatile[N]> : public true_type{};
   template <class T> struct is_volatile<T volatile[]> : public true_type{};



}
# 39 "/usr/local/include/boost/type_index/stl_type_index.hpp" 2 3
# 58 "/usr/local/include/boost/type_index/stl_type_index.hpp" 3
        


namespace boost { namespace typeindex {






class stl_type_index
    : public type_index_facade<
        stl_type_index,



            std::type_info

    >
{
public:



    typedef std::type_info type_info_t;


private:
    const type_info_t* data_;

public:
    inline stl_type_index() noexcept
        : data_(&typeid(void))
    {}

    inline stl_type_index(const type_info_t& data) noexcept
        : data_(&data)
    {}

    inline const type_info_t& type_info() const noexcept;

    inline const char* raw_name() const noexcept;
    inline const char* name() const noexcept;
    inline std::string pretty_name() const;

    inline std::size_t hash_code() const noexcept;
    inline bool equal(const stl_type_index& rhs) const noexcept;
    inline bool before(const stl_type_index& rhs) const noexcept;

    template <class T>
    inline static stl_type_index type_id() noexcept;

    template <class T>
    inline static stl_type_index type_id_with_cvr() noexcept;

    template <class T>
    inline static stl_type_index type_id_runtime(const T& value) noexcept;
};

inline const stl_type_index::type_info_t& stl_type_index::type_info() const noexcept {
    return *data_;
}


inline const char* stl_type_index::raw_name() const noexcept {



    return data_->name();

}

inline const char* stl_type_index::name() const noexcept {
    return data_->name();
}

inline std::string stl_type_index::pretty_name() const {
    static const char cvr_saver_name[] = "boost::typeindex::detail::cvr_saver<";
    static constexpr std::string::size_type cvr_saver_name_len = sizeof(cvr_saver_name) - 1;



    const boost::core::scoped_demangled_name demangled_name(data_->name());

    const char* begin = demangled_name.get();
    if (!begin) {
        boost::throw_exception(std::runtime_error("Type name demangling failed"));
    }

    const std::string::size_type len = std::strlen(begin);
    const char* end = begin + len;

    if (len > cvr_saver_name_len) {
        const char* b = std::strstr(begin, cvr_saver_name);
        if (b) {
            b += cvr_saver_name_len;


            while (*b == ' ') {
                ++ b;
            }


            const char* e = end - 1;
            while (e > b && *e != '>') {
                -- e;
            }


            while (e > b && *(e - 1) == ' ') {
                -- e;
            }

            if (b < e) {

                begin = b;
                end = e;
            }
        }
    }

    return std::string(begin, end);
}


inline std::size_t stl_type_index::hash_code() const noexcept {

    return data_->hash_code();



}
# 206 "/usr/local/include/boost/type_index/stl_type_index.hpp" 3
inline bool stl_type_index::equal(const stl_type_index& rhs) const noexcept {



    return !!(*data_ == *rhs.data_);

}

inline bool stl_type_index::before(const stl_type_index& rhs) const noexcept {



    return !!data_->before(*rhs.data_);

}




template <class T>
inline stl_type_index stl_type_index::type_id() noexcept {
    typedef typename boost::remove_reference<T>::type no_ref_t;
    typedef typename boost::remove_cv<no_ref_t>::type no_cvr_prefinal_t;
# 243 "/usr/local/include/boost/type_index/stl_type_index.hpp" 3
        typedef no_cvr_prefinal_t no_cvr_t;


    return typeid(no_cvr_t);
}

namespace detail {
    template <class T> class cvr_saver{};
}

template <class T>
inline stl_type_index stl_type_index::type_id_with_cvr() noexcept {
    typedef typename boost::conditional<
        boost::is_reference<T>::value || boost::is_const<T>::value || boost::is_volatile<T>::value,
        detail::cvr_saver<T>,
        T
    >::type type;

    return typeid(type);
}


template <class T>
inline stl_type_index stl_type_index::type_id_runtime(const T& value) noexcept {



    return typeid(value);

}

}}
# 30 "/usr/local/include/boost/type_index.hpp" 2 3
# 52 "/usr/local/include/boost/type_index.hpp" 3
namespace boost { namespace typeindex {
# 132 "/usr/local/include/boost/type_index.hpp" 3
    typedef boost::typeindex::stl_type_index type_index;
# 144 "/usr/local/include/boost/type_index.hpp" 3
typedef type_index::type_info_t type_info;
# 210 "/usr/local/include/boost/type_index.hpp" 3
template <class T>
inline type_index type_id() noexcept {
    return type_index::type_id<T>();
}
# 230 "/usr/local/include/boost/type_index.hpp" 3
template <class T>
inline type_index type_id_with_cvr() noexcept {
    return type_index::type_id_with_cvr<T>();
}
# 255 "/usr/local/include/boost/type_index.hpp" 3
template <class T>
inline type_index type_id_runtime(const T& runtime_val) noexcept {
    return type_index::type_id_runtime(runtime_val);
}

}}
# 22 "/usr/local/include/boost/function/function_base.hpp" 2 3

# 1 "/usr/local/include/boost/type_traits/has_trivial_destructor.hpp" 1 3
# 28 "/usr/local/include/boost/type_traits/has_trivial_destructor.hpp" 3
namespace boost {

template <typename T> struct has_trivial_destructor : public integral_constant<bool, (__has_trivial_destructor(T) && is_destructible<T>::value)>{};
# 39 "/usr/local/include/boost/type_traits/has_trivial_destructor.hpp" 3
template <> struct has_trivial_destructor<void> : public false_type{};

template <> struct has_trivial_destructor<void const> : public false_type{};
template <> struct has_trivial_destructor<void const volatile> : public false_type{};
template <> struct has_trivial_destructor<void volatile> : public false_type{};


}
# 24 "/usr/local/include/boost/function/function_base.hpp" 2 3



# 1 "/usr/local/include/boost/type_traits/composite_traits.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/composite_traits.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_array.hpp" 1 3
# 20 "/usr/local/include/boost/type_traits/is_array.hpp" 3
namespace boost {




   template <class T> struct is_array : public false_type {};

   template <class T, std::size_t N> struct is_array<T[N]> : public true_type {};
   template <class T, std::size_t N> struct is_array<T const[N]> : public true_type{};
   template <class T, std::size_t N> struct is_array<T volatile[N]> : public true_type{};
   template <class T, std::size_t N> struct is_array<T const volatile[N]> : public true_type{};

   template <class T> struct is_array<T[]> : public true_type{};
   template <class T> struct is_array<T const[]> : public true_type{};
   template <class T> struct is_array<T const volatile[]> : public true_type{};
   template <class T> struct is_array<T volatile[]> : public true_type{};





}
# 17 "/usr/local/include/boost/type_traits/composite_traits.hpp" 2 3





# 1 "/usr/local/include/boost/type_traits/is_union.hpp" 1 3
# 17 "/usr/local/include/boost/type_traits/is_union.hpp" 3
namespace boost {


template <class T> struct is_union : public integral_constant<bool, __is_union(T)> {};




template <class T> struct is_union<T const> : public is_union<T>{};
template <class T> struct is_union<T volatile const> : public is_union<T>{};
template <class T> struct is_union<T volatile> : public is_union<T>{};

}
# 23 "/usr/local/include/boost/type_traits/composite_traits.hpp" 2 3
# 28 "/usr/local/include/boost/function/function_base.hpp" 2 3
# 1 "/usr/local/include/boost/ref.hpp" 1 3
# 15 "/usr/local/include/boost/ref.hpp" 3
# 1 "/usr/local/include/boost/core/ref.hpp" 1 3
# 12 "/usr/local/include/boost/core/ref.hpp" 3
# 1 "/usr/local/include/boost/core/addressof.hpp" 1 3
# 34 "/usr/local/include/boost/core/addressof.hpp" 3
namespace boost {

template<class T>
constexpr inline T*
addressof(T& o) noexcept
{
    return __builtin_addressof(o);
}

}
# 266 "/usr/local/include/boost/core/addressof.hpp" 3
namespace boost {

template<class T>
const T* addressof(const T&&) = delete;

}
# 13 "/usr/local/include/boost/core/ref.hpp" 2 3
# 40 "/usr/local/include/boost/core/ref.hpp" 3
namespace boost
{
# 60 "/usr/local/include/boost/core/ref.hpp" 3
template<class T> class reference_wrapper
{
public:



    typedef T type;







    inline __attribute__ ((__always_inline__)) explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}
# 86 "/usr/local/include/boost/core/ref.hpp" 3
    reference_wrapper(T&& t) = delete;
public:






    inline __attribute__ ((__always_inline__)) operator T& () const { return *t_; }





    inline __attribute__ ((__always_inline__)) T& get() const { return *t_; }






    inline __attribute__ ((__always_inline__)) T* get_pointer() const { return t_; }

private:

    T* t_;
};
# 132 "/usr/local/include/boost/core/ref.hpp" 3
template<class T> inline __attribute__ ((__always_inline__)) reference_wrapper<T> const ref( T & t )
{






    return reference_wrapper<T>( t );


}







template<class T> inline __attribute__ ((__always_inline__)) reference_wrapper<T const> const cref( T const & t )
{
    return reference_wrapper<T const>(t);
}
# 175 "/usr/local/include/boost/core/ref.hpp" 3
template<class T> void ref(T const&&) = delete;




template<class T> void cref(T const&&) = delete;
# 195 "/usr/local/include/boost/core/ref.hpp" 3
template<typename T> struct is_reference_wrapper
{
    static const bool value = false;
};




template<typename T> struct is_reference_wrapper< reference_wrapper<T> >
{
    static const bool value = true;
};



template<typename T> struct is_reference_wrapper< reference_wrapper<T> const >
{
    static const bool value = true;
};

template<typename T> struct is_reference_wrapper< reference_wrapper<T> volatile >
{
    static const bool value = true;
};

template<typename T> struct is_reference_wrapper< reference_wrapper<T> const volatile >
{
    static const bool value = true;
};
# 240 "/usr/local/include/boost/core/ref.hpp" 3
template<typename T> struct unwrap_reference
{
    typedef T type;
};




template<typename T> struct unwrap_reference< reference_wrapper<T> >
{
    typedef T type;
};



template<typename T> struct unwrap_reference< reference_wrapper<T> const >
{
    typedef T type;
};

template<typename T> struct unwrap_reference< reference_wrapper<T> volatile >
{
    typedef T type;
};

template<typename T> struct unwrap_reference< reference_wrapper<T> const volatile >
{
    typedef T type;
};
# 282 "/usr/local/include/boost/core/ref.hpp" 3
template<class T> inline __attribute__ ((__always_inline__)) typename unwrap_reference<T>::type& unwrap_ref( T & t )
{
    return t;
}






template<class T> inline __attribute__ ((__always_inline__)) T* get_pointer( reference_wrapper<T> const & r )
{
    return r.get_pointer();
}




}
# 16 "/usr/local/include/boost/ref.hpp" 2 3
# 29 "/usr/local/include/boost/function/function_base.hpp" 2 3




# 1 "/usr/local/include/boost/type_traits/enable_if.hpp" 1 3
# 20 "/usr/local/include/boost/type_traits/enable_if.hpp" 3
namespace boost {

template<bool B, class T = void>
struct enable_if_ {
    typedef T type;
};

template<class T>
struct enable_if_<false, T> { };


template<bool B, class T = void>
using enable_if_t = typename enable_if_<B, T>::type;


}
# 34 "/usr/local/include/boost/function/function_base.hpp" 2 3



# 1 "/usr/local/include/boost/function_equal.hpp" 1 3
# 13 "/usr/local/include/boost/function_equal.hpp" 3
namespace boost {

template<typename F, typename G>
  bool function_equal_impl(const F& f, const G& g, long)
  { return f == g; }




template<typename F, typename G>
  bool function_equal(const F& f, const G& g)
  { return function_equal_impl(f, g, 0); }

}
# 38 "/usr/local/include/boost/function/function_base.hpp" 2 3
# 1 "/usr/local/include/boost/function/function_fwd.hpp" 1 3
# 27 "/usr/local/include/boost/function/function_fwd.hpp" 3
namespace boost {
  class bad_function_call;



  template<typename Signature> class function;

  template<typename Signature>
  inline void swap(function<Signature>& f1, function<Signature>& f2)
  {
    f1.swap(f2);
  }



  template<typename R> class function0;
  template<typename R, typename T1> class function1;
  template<typename R, typename T1, typename T2> class function2;
  template<typename R, typename T1, typename T2, typename T3> class function3;
  template<typename R, typename T1, typename T2, typename T3, typename T4>
    class function4;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5>
    class function5;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6>
    class function6;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7>
    class function7;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7, typename T8>
    class function8;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7, typename T8, typename T9>
    class function9;
  template<typename R, typename T1, typename T2, typename T3, typename T4,
           typename T5, typename T6, typename T7, typename T8, typename T9,
           typename T10>
    class function10;
}
# 39 "/usr/local/include/boost/function/function_base.hpp" 2 3
# 57 "/usr/local/include/boost/function/function_base.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      class X;







      union function_buffer_members
      {

        typedef void* obj_ptr_t;
        mutable obj_ptr_t obj_ptr;


        struct type_t {

          const boost::typeindex::type_info* type;


          bool const_qualified;

          bool volatile_qualified;
        } type;


        typedef void (*func_ptr_t)();
        mutable func_ptr_t func_ptr;


        struct bound_memfunc_ptr_t {
          void (X::*memfunc_ptr)(int);
          void* obj_ptr;
        } bound_memfunc_ptr;



        struct obj_ref_t {
          mutable void* obj_ptr;
          bool is_const_qualified;
          bool is_volatile_qualified;
        } obj_ref;
      };

      union __attribute__((__visibility__("default"))) function_buffer
      {

        mutable function_buffer_members members;


        mutable char data[sizeof(function_buffer_members)];
      };







      struct unusable
      {
        unusable() {}
        template<typename T> unusable(const T&) {}
      };





      template<typename T> struct function_return_type { typedef T type; };

      template<>
      struct function_return_type<void>
      {
        typedef unusable type;
      };


      enum functor_manager_operation_type {
        clone_functor_tag,
        move_functor_tag,
        destroy_functor_tag,
        check_functor_type_tag,
        get_functor_type_tag
      };


      struct function_ptr_tag {};
      struct function_obj_tag {};
      struct member_ptr_tag {};
      struct function_obj_ref_tag {};

      template<typename F>
      class get_function_tag
      {
        typedef typename conditional<(is_pointer<F>::value),
                                   function_ptr_tag,
                                   function_obj_tag>::type ptr_or_obj_tag;

        typedef typename conditional<(is_member_pointer<F>::value),
                                   member_ptr_tag,
                                   ptr_or_obj_tag>::type ptr_or_obj_or_mem_tag;

        typedef typename conditional<(is_reference_wrapper<F>::value),
                                   function_obj_ref_tag,
                                   ptr_or_obj_or_mem_tag>::type or_ref_tag;

      public:
        typedef or_ref_tag type;
      };



      template<typename F>
      struct reference_manager
      {
        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          switch (op) {
          case clone_functor_tag:
            out_buffer.members.obj_ref = in_buffer.members.obj_ref;
            return;

          case move_functor_tag:
            out_buffer.members.obj_ref = in_buffer.members.obj_ref;
            in_buffer.members.obj_ref.obj_ptr = 0;
            return;

          case destroy_functor_tag:
            out_buffer.members.obj_ref.obj_ptr = 0;
            return;

          case check_functor_type_tag:
            {


              if (*out_buffer.members.type.type == boost::typeindex::type_id<F>()
                  && (!in_buffer.members.obj_ref.is_const_qualified
                      || out_buffer.members.type.const_qualified)
                  && (!in_buffer.members.obj_ref.is_volatile_qualified
                      || out_buffer.members.type.volatile_qualified))
                out_buffer.members.obj_ptr = in_buffer.members.obj_ref.obj_ptr;
              else
                out_buffer.members.obj_ptr = 0;
            }
            return;

          case get_functor_type_tag:
            out_buffer.members.type.type = &boost::typeindex::type_id<F>().type_info();
            out_buffer.members.type.const_qualified = in_buffer.members.obj_ref.is_const_qualified;
            out_buffer.members.type.volatile_qualified = in_buffer.members.obj_ref.is_volatile_qualified;
            return;
          }
        }
      };





      template<typename F>
      struct function_allows_small_object_optimization
      {
        static const bool value = ((sizeof(F) <= sizeof(function_buffer) && (alignment_of<function_buffer>::value % alignment_of<F>::value == 0)))



                                                       ;
      };

      template <typename F,typename A>
      struct functor_wrapper: public F, public A
      {
        functor_wrapper( F f, A a ):
          F(f),
          A(a)
        {
        }

        functor_wrapper(const functor_wrapper& f) :
          F(static_cast<const F&>(f)),
          A(static_cast<const A&>(f))
        {
        }
      };





      template<typename Functor>
      struct functor_manager_common
      {
        typedef Functor functor_type;


        static inline void
        manage_ptr(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op)
        {
          if (op == clone_functor_tag)
            out_buffer.members.func_ptr = in_buffer.members.func_ptr;
          else if (op == move_functor_tag) {
            out_buffer.members.func_ptr = in_buffer.members.func_ptr;
            in_buffer.members.func_ptr = 0;
          } else if (op == destroy_functor_tag)
            out_buffer.members.func_ptr = 0;
          else if (op == check_functor_type_tag) {
            if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())
              out_buffer.members.obj_ptr = &in_buffer.members.func_ptr;
            else
              out_buffer.members.obj_ptr = 0;
          } else {
            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();
            out_buffer.members.type.const_qualified = false;
            out_buffer.members.type.volatile_qualified = false;
          }
        }


        static inline void
        manage_small(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op)
        {
          if (op == clone_functor_tag || op == move_functor_tag) {
            const functor_type* in_functor =
              reinterpret_cast<const functor_type*>(in_buffer.data);
            new (reinterpret_cast<void*>(out_buffer.data)) functor_type(*in_functor);

            if (op == move_functor_tag) {
              functor_type* f = reinterpret_cast<functor_type*>(in_buffer.data);
              (void)f;
              f->~Functor();
            }
          } else if (op == destroy_functor_tag) {

             functor_type* f = reinterpret_cast<functor_type*>(out_buffer.data);
             (void)f;
             f->~Functor();
          } else if (op == check_functor_type_tag) {
             if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())
              out_buffer.members.obj_ptr = in_buffer.data;
            else
              out_buffer.members.obj_ptr = 0;
          } else {
            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();
            out_buffer.members.type.const_qualified = false;
            out_buffer.members.type.volatile_qualified = false;
          }
        }
      };

      template<typename Functor>
      struct functor_manager
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, true_type)
        {
          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, false_type)
        {
          if (op == clone_functor_tag) {





            const functor_type* f =
              static_cast<const functor_type*>(in_buffer.members.obj_ptr);
            functor_type* new_f = new functor_type(*f);
            out_buffer.members.obj_ptr = new_f;
          } else if (op == move_functor_tag) {
            out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;
            in_buffer.members.obj_ptr = 0;
          } else if (op == destroy_functor_tag) {

            functor_type* f =
              static_cast<functor_type*>(out_buffer.members.obj_ptr);
            delete f;
            out_buffer.members.obj_ptr = 0;
          } else if (op == check_functor_type_tag) {
            if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())
              out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;
            else
              out_buffer.members.obj_ptr = 0;
          } else {
            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();
            out_buffer.members.type.const_qualified = false;
            out_buffer.members.type.volatile_qualified = false;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  integral_constant<bool, (function_allows_small_object_optimization<functor_type>::value)>());
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, member_ptr_tag)
        {
          manager(in_buffer, out_buffer, op, true_type());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.members.type.type = &boost::typeindex::type_id<functor_type>().type_info();
            out_buffer.members.type.const_qualified = false;
            out_buffer.members.type.volatile_qualified = false;
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };

      template<typename Functor, typename Allocator>
      struct functor_manager_a
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, true_type)
        {
          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, false_type)
        {
          typedef functor_wrapper<Functor,Allocator> functor_wrapper_type;





          using wrapper_allocator_type = typename std::allocator_traits<Allocator>::template rebind_alloc<functor_wrapper_type>;
          using wrapper_allocator_pointer_type = typename std::allocator_traits<wrapper_allocator_type>::pointer;


          if (op == clone_functor_tag) {



            const functor_wrapper_type* f =
              static_cast<const functor_wrapper_type*>(in_buffer.members.obj_ptr);
            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*f));
            wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);



            std::allocator_traits<wrapper_allocator_type>::construct(wrapper_allocator, copy, *f);



            functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
            out_buffer.members.obj_ptr = new_f;
          } else if (op == move_functor_tag) {
            out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;
            in_buffer.members.obj_ptr = 0;
          } else if (op == destroy_functor_tag) {

            functor_wrapper_type* victim =
              static_cast<functor_wrapper_type*>(in_buffer.members.obj_ptr);
            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*victim));



            std::allocator_traits<wrapper_allocator_type>::destroy(wrapper_allocator, victim);

            wrapper_allocator.deallocate(victim,1);
            out_buffer.members.obj_ptr = 0;
          } else if (op == check_functor_type_tag) {
            if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())
              out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;
            else
              out_buffer.members.obj_ptr = 0;
          } else {
            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();
            out_buffer.members.type.const_qualified = false;
            out_buffer.members.type.volatile_qualified = false;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  integral_constant<bool, (function_allows_small_object_optimization<functor_type>::value)>());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.members.type.type = &boost::typeindex::type_id<functor_type>().type_info();
            out_buffer.members.type.const_qualified = false;
            out_buffer.members.type.volatile_qualified = false;
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };


      struct useless_clear_type {};
# 593 "/usr/local/include/boost/function/function_base.hpp" 3
      struct vtable_base
      {
        void (*manager)(const function_buffer& in_buffer,
                        function_buffer& out_buffer,
                        functor_manager_operation_type op);
      };
    }
  }







class function_base
{
public:
  function_base() : vtable(0) { }


  bool empty() const { return !vtable; }



  const boost::typeindex::type_info& target_type() const
  {
    if (!vtable) return boost::typeindex::type_id<void>().type_info();

    detail::function::function_buffer type;
    get_vtable()->manager(functor, type, detail::function::get_functor_type_tag);
    return *type.members.type.type;
  }

  template<typename Functor>
    Functor* target()
    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.members.type.type = &boost::typeindex::type_id<Functor>().type_info();
      type_result.members.type.const_qualified = is_const<Functor>::value;
      type_result.members.type.volatile_qualified = is_volatile<Functor>::value;
      get_vtable()->manager(functor, type_result,
                      detail::function::check_functor_type_tag);
      return static_cast<Functor*>(type_result.members.obj_ptr);
    }

  template<typename Functor>
    const Functor* target() const
    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.members.type.type = &boost::typeindex::type_id<Functor>().type_info();
      type_result.members.type.const_qualified = true;
      type_result.members.type.volatile_qualified = is_volatile<Functor>::value;
      get_vtable()->manager(functor, type_result,
                      detail::function::check_functor_type_tag);


      return static_cast<const Functor*>(type_result.members.obj_ptr);
    }

  template<typename F>
    bool contains(const F& f) const
    {
      if (const F* fp = this->template target<F>())
      {
        return function_equal(*fp, f);
      } else {
        return false;
      }
    }
# 691 "/usr/local/include/boost/function/function_base.hpp" 3
public:
  detail::function::vtable_base* get_vtable() const {
    return reinterpret_cast<detail::function::vtable_base*>(
             reinterpret_cast<std::size_t>(vtable) & ~static_cast<std::size_t>(0x01));
  }

  bool has_trivial_copy_and_destroy() const {
    return reinterpret_cast<std::size_t>(vtable) & 0x01;
  }

  detail::function::vtable_base* vtable;
  mutable detail::function::function_buffer functor;
};
# 713 "/usr/local/include/boost/function/function_base.hpp" 3
class __attribute__((__visibility__("default"))) bad_function_call : public std::runtime_error
{
public:
  bad_function_call() : std::runtime_error("call to empty boost::function") {}
};





inline bool operator==(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return f.empty();
}

inline bool operator!=(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return !f.empty();
}

inline bool operator==(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return f.empty();
}

inline bool operator!=(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return !f.empty();
}
# 783 "/usr/local/include/boost/function/function_base.hpp" 3
template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator==(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(*fp, g);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator==(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(g, *fp);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator!=(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(*fp, g);
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator!=(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(g, *fp);
    else return true;
  }


template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator==(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp == g.get_pointer();
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator==(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() == fp;
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator!=(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp != g.get_pointer();
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_< !(::boost::is_integral<Functor>::value), bool>::type
  operator!=(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() != fp;
    else return true;
  }



namespace detail {
  namespace function {
    inline bool has_empty_target(const function_base* f)
    {
      return f->empty();
    }







    inline bool has_empty_target(...)
    {
      return false;
    }

  }
}
}
# 18 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/include/boost/mem_fn.hpp" 1 3
# 22 "/usr/local/include/boost/mem_fn.hpp" 3
# 1 "/usr/local/include/boost/bind/mem_fn.hpp" 1 3
# 25 "/usr/local/include/boost/bind/mem_fn.hpp" 3
# 1 "/usr/local/include/boost/get_pointer.hpp" 1 3
# 14 "/usr/local/include/boost/get_pointer.hpp" 3
# 1 "/usr/local/include/boost/config/no_tr1/memory.hpp" 1 3
# 15 "/usr/local/include/boost/get_pointer.hpp" 2 3

namespace boost {



template<class T> T * get_pointer(T * p)
{
    return p;
}
# 43 "/usr/local/include/boost/get_pointer.hpp" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"



template<class T> T * get_pointer(std::auto_ptr<T> const& p)
{
    return p.get();
}


#pragma GCC diagnostic pop







template<class T> T * get_pointer( std::unique_ptr<T> const& p )
{
    return p.get();
}

template<class T> T * get_pointer( std::shared_ptr<T> const& p )
{
    return p.get();
}



}
# 26 "/usr/local/include/boost/bind/mem_fn.hpp" 2 3


namespace boost
{
# 207 "/usr/local/include/boost/bind/mem_fn.hpp" 3
namespace _mfi
{






# 1 "/usr/local/include/boost/bind/mem_fn_template.hpp" 1 3
# 21 "/usr/local/include/boost/bind/mem_fn_template.hpp" 3
template<class R, class T > class mf0
{
public:

    typedef R result_type;
    typedef T * argument_type;

private:

    typedef R ( T::*F) ();
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit mf0(F f): f_(f) {}

    R operator()(T * p) const
    {
        return (p->*f_)();
    }

    template<class U> R operator()(U & u) const
    {
        U const * p = 0;
        return call(u, p);
    }



    template<class U> R operator()(U const & u) const
    {
        U const * p = 0;
        return call(u, p);
    }



    R operator()(T & t) const
    {
        return (t.*f_)();
    }

    bool operator==(mf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T > class cmf0
{
public:

    typedef R result_type;
    typedef T const * argument_type;

private:

    typedef R ( T::*F) () const;
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit cmf0(F f): f_(f) {}

    template<class U> R operator()(U const & u) const
    {
        U const * p = 0;
        return call(u, p);
    }

    R operator()(T const & t) const
    {
        return (t.*f_)();
    }

    bool operator==(cmf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class mf1
{
public:

    typedef R result_type;
    typedef T * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1);
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit mf1(F f): f_(f) {}

    R operator()(T * p, A1 a1) const
    {
        return (p->*f_)(a1);
    }

    template<class U> R operator()(U & u, A1 a1) const
    {
        U const * p = 0;
        return call(u, p, a1);
    }



    template<class U> R operator()(U const & u, A1 a1) const
    {
        U const * p = 0;
        return call(u, p, a1);
    }



    R operator()(T & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(mf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class cmf1
{
public:

    typedef R result_type;
    typedef T const * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1) const;
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit cmf1(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1) const
    {
        U const * p = 0;
        return call(u, p, a1);
    }

    R operator()(T const & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(cmf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class mf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2);
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit mf2(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2) const
    {
        return (p->*f_)(a1, a2);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2) const
    {
        U const * p = 0;
        return call(u, p, a1, a2);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        U const * p = 0;
        return call(u, p, a1, a2);
    }



    R operator()(T & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(mf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class cmf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2) const;
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit cmf2(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        U const * p = 0;
        return call(u, p, a1, a2);
    }

    R operator()(T const & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(cmf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class mf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3);
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit mf3(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3) const
    {
        return (p->*f_)(a1, a2, a3);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(mf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class cmf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3) const;
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit cmf3(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(cmf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class mf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4);
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit mf4(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (p->*f_)(a1, a2, a3, a4);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(mf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class cmf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit cmf4(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(cmf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class mf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit mf5(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(mf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class cmf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit cmf5(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(cmf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class mf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit mf6(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(mf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class cmf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit cmf6(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(cmf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class mf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit mf7(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(mf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class cmf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit cmf7(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(cmf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class mf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit mf8(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(mf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class cmf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit cmf8(F f): f_(f) {}

    R operator()(T const * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        U const * p = 0;
        return call(u, p, a1, a2, a3, a4, a5, a6, a7, a8);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(cmf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};
# 216 "/usr/local/include/boost/bind/mem_fn.hpp" 2 3
# 258 "/usr/local/include/boost/bind/mem_fn.hpp" 3
}
# 268 "/usr/local/include/boost/bind/mem_fn.hpp" 3
# 1 "/usr/local/include/boost/bind/mem_fn_cc.hpp" 1 3
# 15 "/usr/local/include/boost/bind/mem_fn_cc.hpp" 3
template<class R, class T> _mfi::mf0<R, T> mem_fn(R ( T::*f) ())
{
    return _mfi::mf0<R, T>(f);
}

template<class R, class T> _mfi::cmf0<R, T> mem_fn(R ( T::*f) () const)
{
    return _mfi::cmf0<R, T>(f);
}

template<class R, class T, class A1> _mfi::mf1<R, T, A1> mem_fn(R ( T::*f) (A1))
{
    return _mfi::mf1<R, T, A1>(f);
}

template<class R, class T, class A1> _mfi::cmf1<R, T, A1> mem_fn(R ( T::*f) (A1) const)
{
    return _mfi::cmf1<R, T, A1>(f);
}

template<class R, class T, class A1, class A2> _mfi::mf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2))
{
    return _mfi::mf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2> _mfi::cmf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2) const)
{
    return _mfi::cmf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::mf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3))
{
    return _mfi::mf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::cmf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3) const)
{
    return _mfi::cmf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::mf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4))
{
    return _mfi::mf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::cmf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4) const)
{
    return _mfi::cmf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::mf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5))
{
    return _mfi::mf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::cmf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5) const)
{
    return _mfi::cmf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6))
{
    return _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6) const)
{
    return _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7))
{
    return _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7) const)
{
    return _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8))
{
    return _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8) const)
{
    return _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}
# 269 "/usr/local/include/boost/bind/mem_fn.hpp" 2 3
# 311 "/usr/local/include/boost/bind/mem_fn.hpp" 3
namespace _mfi
{

template<class R, class T> class dm
{
public:

    typedef R const & result_type;
    typedef T const * argument_type;

private:

    typedef R (T::*F);
    F f_;

    template<class U> R const & call(U & u, T const *) const
    {
        return (u.*f_);
    }

    template<class U> R const & call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_);
    }

public:

    explicit dm(F f): f_(f) {}

    R & operator()(T * p) const
    {
        return (p->*f_);
    }

    R const & operator()(T const * p) const
    {
        return (p->*f_);
    }

    template<class U> R const & operator()(U const & u) const
    {
        return call(u, &u);
    }



    R & operator()(T & t) const
    {
        return (t.*f_);
    }

    R const & operator()(T const & t) const
    {
        return (t.*f_);
    }



    bool operator==(dm const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(dm const & rhs) const
    {
        return f_ != rhs.f_;
    }
};

}

template<class R, class T> _mfi::dm<R, T> mem_fn(R T::*f)
{
    return _mfi::dm<R, T>(f);
}

}
# 23 "/usr/local/include/boost/mem_fn.hpp" 2 3
# 19 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/enum.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/enum.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/cat.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/cat.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/config/config.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/cat.hpp" 2 3
# 18 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/debug/error.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/control/iif.hpp" 1 3
# 22 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 2 3
# 21 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/punctuation/comma_if.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/control/if.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/control/if.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/logical/bool.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/control/if.hpp" 2 3
# 19 "/usr/local/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/facilities/empty.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/punctuation/comma.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/repetition/repeat.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/repetition/repeat.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/eat.hpp" 1 3
# 22 "/usr/local/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 23 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/elem.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/elem.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/facilities/expand.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/tuple/elem.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/facilities/overload.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/facilities/overload.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/variadic/size.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/facilities/overload.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/tuple/elem.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/rem.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/rem.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/tuple/detail/is_single_return.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/tuple/rem.hpp" 2 3
# 23 "/usr/local/include/boost/preprocessor/tuple/elem.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/variadic/elem.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/tuple/elem.hpp" 2 3
# 24 "/usr/local/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 16 "/usr/local/include/boost/preprocessor/enum.hpp" 2 3
# 21 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/enum_params.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/enum_params.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/enum_params.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/enum_params.hpp" 2 3
# 22 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/repeat.hpp" 1 3
# 24 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/inc.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/inc.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/arithmetic/inc.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/inc.hpp" 2 3
# 25 "/usr/local/include/boost/function/detail/prologue.hpp" 2 3
# 14 "/usr/local/include/boost/function/function_template.hpp" 2 3
# 1 "/usr/local/include/boost/core/no_exceptions_support.hpp" 1 3
# 15 "/usr/local/include/boost/function/function_template.hpp" 2 3
# 86 "/usr/local/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R
       
        >
      struct function_invoker0
      {
        static R invoke(function_buffer& function_ptr
                        )
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);
          return f();
        }
      };

      template<
        typename FunctionPtr,
        typename R
       
        >
      struct void_function_invoker0
      {
        static void
        invoke(function_buffer& function_ptr
               )

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);
          f();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_obj_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_obj_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_ref_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_ref_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          (*f)();
        }
      };
# 235 "/usr/local/include/boost/function/function_template.hpp" 3
      template<
        typename FunctionPtr,
        typename R
       
      >
      struct get_function_invoker0
      {
        typedef typename conditional<(is_void<R>::value),
                            void_function_invoker0<
                            FunctionPtr,
                            R
                           
                          >,
                          function_invoker0<
                            FunctionPtr,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_obj_invoker0
      {
        typedef typename conditional<(is_void<R>::value),
                            void_function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_ref_invoker0
      {
        typedef typename conditional<(is_void<R>::value),
                            void_function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };
# 331 "/usr/local/include/boost/function/function_template.hpp" 3
      template<typename Tag>
      struct get_invoker0 { };


      template<>
      struct get_invoker0<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R >
        struct apply
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr, typename Allocator,
                 typename R >
        struct apply_a
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };
# 403 "/usr/local/include/boost/function/function_template.hpp" 3
      template<>
      struct get_invoker0<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R >
        struct apply
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj, typename Allocator,
                 typename R >
        struct apply_a
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker0<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R >
        struct apply
        {
          typedef typename get_function_ref_invoker0<
                             typename RefWrapper::type,
                             R
                            
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper, typename Allocator,
                 typename R >
        struct apply_a
        {
          typedef typename get_function_ref_invoker0<
                             typename RefWrapper::type,
                             R
                            
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 476 "/usr/local/include/boost/function/function_template.hpp" 3
      template<typename R >
      struct basic_vtable0
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                           
                                            );

        template<typename F>
        bool assign_to(F f, function_buffer& functor) const
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a) const
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor) const
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag) const
        {
          this->clear(functor);
          if (f) {


            functor.members.func_ptr = reinterpret_cast<void (*)()>(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag) const
        {
          return assign_to(f,functor,function_ptr_tag());
        }
# 563 "/usr/local/include/boost/function/function_template.hpp" 3
        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, true_type) const
        {
          new (reinterpret_cast<void*>(functor.data)) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, true_type) const
        {
          assign_functor(f,functor,true_type());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, false_type) const
        {
          functor.members.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, false_type) const
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;





          using wrapper_allocator_type = typename std::allocator_traits<Allocator>::template rebind_alloc<functor_wrapper_type>;
          using wrapper_allocator_pointer_type = typename std::allocator_traits<wrapper_allocator_type>::pointer;

          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);



          std::allocator_traits<wrapper_allocator_type>::construct(wrapper_allocator, copy, functor_wrapper_type(f,a));

          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.members.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag) const
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           integral_constant<bool, (function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag) const
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           integral_constant<bool, (function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag) const
        {
          functor.members.obj_ref.obj_ptr = (void *)(f.get_pointer());
          functor.members.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.members.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag) const
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R
   
  >
  class function0 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable0<
              R >
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~static_cast<std::size_t>(0x01));
    }

    struct clear_type {};

  public:
    static const int args = 0;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 701 "/usr/local/include/boost/function/function_template.hpp" 3
    static const int arity = 0;
   

    typedef function0 self_type;

    function0() = default;



    template<typename Functor>
    function0(Functor f

                            ,typename boost::enable_if_<
                             !(is_integral<Functor>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function0(Functor f, Allocator a

                            ,typename boost::enable_if_<
                              !(is_integral<Functor>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function0(clear_type*) : function_base() { }







    function0(const function0& f) : function_base()
    {
      this->assign_to_own(f);
    }


    function0(function0&& f) : function_base()
    {
      this->move_assign(f);
    }


    ~function0() { clear(); }

    result_type operator()() const
    {
      if (this->empty())
        boost::throw_exception(bad_function_call());

      return get_vtable()->invoker
               (this->functor );
    }






    template<typename Functor>

    typename boost::enable_if_<
                  !(is_integral<Functor>::value),
               function0&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function0& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 821 "/usr/local/include/boost/function/function_template.hpp" 3
    function0& operator=(const function0& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }



    function0& operator=(function0&& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->move_assign(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }


    void swap(function0& other)
    {
      if (&other == this)
        return;

      function0 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {}
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function0& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())


          std::memcpy(this->functor.data, f.functor.data, sizeof(boost::detail::function::function_buffer));
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using boost::detail::function::vtable_base;

      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;
      typedef boost::detail::function::get_invoker0<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R
                        >
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static const vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);

        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            boost::detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= static_cast<std::size_t>(0x01);
        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using boost::detail::function::vtable_base;

      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;
      typedef boost::detail::function::get_invoker0<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, Allocator, R
                         >
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static const vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);

        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            boost::detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= static_cast<std::size_t>(0x01);
        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function0& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())


            std::memcpy(this->functor.data, f.functor.data, sizeof(this->functor.data));
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R >
  inline void swap(function0<
                     R
                    
                   >& f1,
                   function0<
                     R
                    
                   >& f2)
  {
    f1.swap(f2);
  }


template<typename R >
  void operator==(const function0<
                          R
                          >&,
                  const function0<
                          R
                          >&);
template<typename R >
  void operator!=(const function0<
                          R
                          >&,
                  const function0<
                          R
                          >& );
# 1046 "/usr/local/include/boost/function/function_template.hpp" 3
template<typename R
         >
class function<R (void)>
  : public function0<R >
{
  typedef function0<R > base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() = default;

  template<typename Functor>
  function(Functor f

           ,typename boost::enable_if_<
                          !(is_integral<Functor>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename boost::enable_if_<
                           !(is_integral<Functor>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}



  function(self_type&& f): base_type(static_cast<base_type&&>(f)){}
  function(base_type&& f): base_type(static_cast<base_type&&>(f)){}


  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(self_type&& f)
  {
    self_type(static_cast<self_type&&>(f)).swap(*this);
    return *this;
  }


  template<typename Functor>

  typename boost::enable_if_<
                         !(is_integral<Functor>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(base_type&& f)
  {
    self_type(static_cast<base_type&&>(f)).swap(*this);
    return *this;
  }

};




}
# 16 "/usr/local/include/boost/function/detail/maybe_include.hpp" 2 3
# 12 "/usr/local/include/boost/function/function0.hpp" 2 3
# 14 "/usr/local/include/boost/python/errors.hpp" 2 3

namespace boost { namespace python {

struct error_already_set
{
  virtual ~error_already_set();
};



 bool handle_exception_impl(function0<void>);

template <class T>
bool handle_exception(T f)
{
    return handle_exception_impl(function0<void>(boost::ref(f)));
}

namespace detail { inline void rethrow() { throw; } }

inline void handle_exception()
{
    handle_exception(detail::rethrow);
}

 void throw_error_already_set();

template <class T>
inline T* expect_non_null(T* x)
{
    if (x == 0)
        throw_error_already_set();
    return x;
}



 PyObject* pytype_check(PyTypeObject* pytype, PyObject* source);

}}
# 12 "/usr/local/include/boost/python/handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/borrowed.hpp" 1 3
# 9 "/usr/local/include/boost/python/borrowed.hpp" 3
# 1 "/usr/local/include/boost/python/detail/borrowed_ptr.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/borrowed_ptr.hpp" 3
# 1 "/usr/local/include/boost/mpl/if.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/if.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/static_cast.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/static_cast.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/workaround.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/static_cast.hpp" 2 3
# 18 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/integral.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/config/integral.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/msvc.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/config/integral.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/eti.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 73 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/usr/local/include/boost/mpl/aux_/value_wknd.hpp" 3
}}}
# 18 "/usr/local/include/boost/mpl/if.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 3
# 1 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 3
# 1 "/usr/local/include/boost/mpl/void_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/void_fwd.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/adl_barrier.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/adl_barrier.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/adl.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/config/adl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/intel.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/gcc.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 18 "/usr/local/include/boost/mpl/aux_/adl_barrier.hpp" 2 3
# 33 "/usr/local/include/boost/mpl/aux_/adl_barrier.hpp" 3
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 18 "/usr/local/include/boost/mpl/void_fwd.hpp" 2 3

namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/na.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/na.hpp" 3
# 1 "/usr/local/include/boost/mpl/bool.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/bool.hpp" 3
# 1 "/usr/local/include/boost/mpl/bool_fwd.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/bool_fwd.hpp" 3
namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/usr/local/include/boost/mpl/bool.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/integral_c_tag.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/integral_c_tag.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/static_constant.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/integral_c_tag.hpp" 2 3

namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 19 "/usr/local/include/boost/mpl/bool.hpp" 2 3


namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    constexpr operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 18 "/usr/local/include/boost/mpl/aux_/na.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/na_fwd.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/na_fwd.hpp" 3
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/usr/local/include/boost/mpl/aux_/na.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/config/ctps.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/na.hpp" 2 3

namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/usr/local/include/boost/mpl/aux_/na.hpp" 3
}}
# 19 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/lambda.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/config/lambda.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/ttp.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/config/lambda.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/int.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/int.hpp" 3
# 1 "/usr/local/include/boost/mpl/int_fwd.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/int_fwd.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/nttp_decl.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/nttp_decl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/nttp.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/nttp_decl.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/int_fwd.hpp" 2 3

namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/usr/local/include/boost/mpl/int.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    constexpr operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/usr/local/include/boost/mpl/int.hpp" 2 3
# 24 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/lambda_arity_param.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/template_arity_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/template_arity_fwd.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 26 "/usr/local/include/boost/mpl/lambda_fwd.hpp" 2 3

namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/aux_/arity.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/arity.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/dtp.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/arity.hpp" 2 3
# 23 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/aux_/preprocessor/params.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/preprocessor/params.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/preprocessor.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 45 "/usr/local/include/boost/mpl/aux_/preprocessor/params.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/comma_if.hpp" 1 3
# 46 "/usr/local/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessor/enum.hpp" 1 3
# 28 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3
# 1 "/usr/local/include/boost/mpl/limits/arity.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3




# 1 "/usr/local/include/boost/preprocessor/logical/and.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/logical/and.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/logical/bitand.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/logical/and.hpp" 2 3
# 23 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/identity.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/identity.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/facilities/identity.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/identity.hpp" 2 3
# 24 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/empty.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 66 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/arithmetic/add.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/arithmetic/add.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/arithmetic/dec.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/arithmetic/add.hpp" 2 3


# 1 "/usr/local/include/boost/preprocessor/control/while.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/control/while.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/control/while.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/list/fold_left.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/list/fold_left.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/control/while.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/list/fold_left.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/list/fold_left.hpp" 2 3
# 41 "/usr/local/include/boost/preprocessor/list/fold_left.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/list/detail/fold_left.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/list/detail/fold_left.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/control/expr_iif.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/list/adt.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/list/adt.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/is_binary.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/detail/is_binary.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/check.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/detail/is_binary.hpp" 2 3
# 19 "/usr/local/include/boost/preprocessor/list/adt.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/logical/compl.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/list/adt.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3
# 42 "/usr/local/include/boost/preprocessor/list/fold_left.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/control/while.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/list/fold_right.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/list/fold_right.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/list/fold_right.hpp" 2 3
# 37 "/usr/local/include/boost/preprocessor/list/fold_right.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/list/detail/fold_right.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/list/detail/fold_right.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/list/reverse.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/list/detail/fold_right.hpp" 2 3
# 38 "/usr/local/include/boost/preprocessor/list/fold_right.hpp" 2 3
# 23 "/usr/local/include/boost/preprocessor/control/while.hpp" 2 3
# 48 "/usr/local/include/boost/preprocessor/control/while.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/control/detail/while.hpp" 1 3
# 49 "/usr/local/include/boost/preprocessor/control/while.hpp" 2 3
# 21 "/usr/local/include/boost/preprocessor/arithmetic/add.hpp" 2 3
# 67 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/arithmetic/sub.hpp" 1 3
# 68 "/usr/local/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 29 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 2 3






# 1 "/usr/local/include/boost/mpl/aux_/config/overload_resolution.hpp" 1 3
# 36 "/usr/local/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/lambda_support.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/if.hpp" 2 3




namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;

   
};
# 131 "/usr/local/include/boost/mpl/if.hpp" 3
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 11 "/usr/local/include/boost/python/detail/borrowed_ptr.hpp" 2 3

# 1 "/usr/local/include/boost/python/tag.hpp" 1 3
# 10 "/usr/local/include/boost/python/tag.hpp" 3
namespace boost { namespace python {



enum tag_t { tag };

}}
# 13 "/usr/local/include/boost/python/detail/borrowed_ptr.hpp" 2 3

namespace boost { namespace python { namespace detail {

template<class T> class borrowed
{
    typedef T type;
};

template<typename T>
struct is_borrowed_ptr
{
    static const bool value = false;
};


template<typename T>
struct is_borrowed_ptr<borrowed<T>*>
{
    static const bool value = true;
};

template<typename T>
struct is_borrowed_ptr<borrowed<T> const*>
{
    static const bool value = true;
};

template<typename T>
struct is_borrowed_ptr<borrowed<T> volatile*>
{
    static const bool value = true;
};

template<typename T>
struct is_borrowed_ptr<borrowed<T> const volatile*>
{
    static const bool value = true;
};
# 70 "/usr/local/include/boost/python/detail/borrowed_ptr.hpp" 3
}

template <class T>
inline T* get_managed_object(detail::borrowed<T> const volatile* p, tag_t)
{
    return (T*)p;
}

}}
# 10 "/usr/local/include/boost/python/borrowed.hpp" 2 3

namespace boost { namespace python {

template <class T>
inline python::detail::borrowed<T>* borrowed(T* p)
{
    return (detail::borrowed<T>*)p;
}

}}
# 13 "/usr/local/include/boost/python/handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/handle_fwd.hpp" 1 3
# 10 "/usr/local/include/boost/python/handle_fwd.hpp" 3
namespace boost { namespace python {

template <class T = PyObject> class handle;

}}
# 14 "/usr/local/include/boost/python/handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/refcount.hpp" 1 3
# 11 "/usr/local/include/boost/python/refcount.hpp" 3
namespace boost { namespace python {

template <class T>
inline T* incref(T* p)
{
    ( ((PyObject*)(python::upcast<PyObject>(p)))->ob_refcnt++);
    return p;
}

template <class T>
inline T* xincref(T* p)
{
    do { if ((python::upcast<PyObject>(p)) == __null) ; else ( ((PyObject*)(python::upcast<PyObject>(p)))->ob_refcnt++); } while (0);
    return p;
}

template <class T>
inline void decref(T* p)
{
    (static_cast <bool> ((((PyObject*)(python::upcast<PyObject>(p)))->ob_refcnt) > 0) ? void (0) : __assert_fail ("Py_REFCNT(python::upcast<PyObject>(p)) > 0", "/usr/local/include/boost/python/refcount.hpp", 30, __extension__ __PRETTY_FUNCTION__));
    do { if ( --((PyObject*)(python::upcast<PyObject>(p)))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(python::upcast<PyObject>(p))))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(python::upcast<PyObject>(p))))); } while (0);
}

template <class T>
inline void xdecref(T* p)
{
    (static_cast <bool> (!p || (((PyObject*)(python::upcast<PyObject>(p)))->ob_refcnt) > 0) ? void (0) : __assert_fail ("!p || Py_REFCNT(python::upcast<PyObject>(p)) > 0", "/usr/local/include/boost/python/refcount.hpp", 37, __extension__ __PRETTY_FUNCTION__));
    do { if ((python::upcast<PyObject>(p)) == __null) ; else do { if ( --((PyObject*)(python::upcast<PyObject>(p)))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(python::upcast<PyObject>(p))))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(python::upcast<PyObject>(p))))); } while (0); } while (0);
}

}}
# 15 "/usr/local/include/boost/python/handle.hpp" 2 3

# 1 "/usr/local/include/boost/python/detail/raw_pyobject.hpp" 1 3







namespace boost { namespace python { namespace detail {
# 19 "/usr/local/include/boost/python/detail/raw_pyobject.hpp" 3
struct new_reference_t;
typedef new_reference_t* new_reference;


struct borrowed_reference_t;
typedef borrowed_reference_t* borrowed_reference;


struct new_non_null_reference_t;
typedef new_non_null_reference_t* new_non_null_reference;

}}}
# 17 "/usr/local/include/boost/python/handle.hpp" 2 3

namespace boost { namespace python {

template <class T> struct null_ok;

template <class T>
inline null_ok<T>* allow_null(T* p)
{
    return (null_ok<T>*)p;
}

namespace detail
{
  template <class T>
  inline T* manage_ptr(detail::borrowed<null_ok<T> >* p, int)
  {
      return python::xincref((T*)p);
  }

  template <class T>
  inline T* manage_ptr(null_ok<detail::borrowed<T> >* p, int)
  {
      return python::xincref((T*)p);
  }

  template <class T>
  inline T* manage_ptr(detail::borrowed<T>* p, long)
  {
      return python::incref(expect_non_null((T*)p));
  }

  template <class T>
  inline T* manage_ptr(null_ok<T>* p, long)
  {
      return (T*)p;
  }

  template <class T>
  inline T* manage_ptr(T* p, ...)
  {
      return expect_non_null(p);
  }
}

template <class T>
class handle
{
    typedef T* (handle::* bool_type )() const;

 public:
    typedef T element_type;

 public:
    handle();
    ~handle();

    template <class Y>
    explicit handle(Y* p)
        : m_p(
            python::upcast<T>(
                detail::manage_ptr(p, 0)
                )
            )
    {
    }

    handle& operator=(handle const& r)
    {
        python::xdecref(m_p);
        m_p = python::xincref(r.m_p);
        return *this;
    }

    template<typename Y>
    handle& operator=(handle<Y> const & r)
    {
        python::xdecref(m_p);
        m_p = python::xincref(python::upcast<T>(r.get()));
        return *this;
    }

    template <typename Y>
    handle(handle<Y> const& r)
        : m_p(python::xincref(python::upcast<T>(r.get())))
    {
    }

    handle(handle const& r)
        : m_p(python::xincref(r.m_p))
    {
    }

    T* operator-> () const;
    T& operator* () const;
    T* get() const;
    T* release();
    void reset();

    operator bool_type() const
    {
        return m_p ? &handle<T>::get : 0;
    }
    bool operator! () const;

 public:

    inline handle(detail::borrowed_reference x)
        : m_p(
            python::incref(
                downcast<T>((PyObject*)x)
                ))
    {
    }

 private:
    T* m_p;
};





template<class T> inline T * get_pointer(python::handle<T> const & p)
{
    return p.get();
}






using boost::get_pointer;



typedef handle<PyTypeObject> type_handle;




template<typename T>
class is_handle
{
 public:
    static const bool value = false;
};

template<typename T>
class is_handle<handle<T> >
{
 public:
    static const bool value = true;
};




template <class T>
inline handle<T>::handle()
    : m_p(0)
{
}

template <class T>
inline handle<T>::~handle()
{
    python::xdecref(m_p);
}

template <class T>
inline T* handle<T>::operator->() const
{
    return m_p;
}

template <class T>
inline T& handle<T>::operator*() const
{
    return *m_p;
}

template <class T>
inline T* handle<T>::get() const
{
    return m_p;
}

template <class T>
inline bool handle<T>::operator!() const
{
    return m_p == 0;
}

template <class T>
inline T* handle<T>::release()
{
    T* result = m_p;
    m_p = 0;
    return result;
}

template <class T>
inline void handle<T>::reset()
{
    python::xdecref(m_p);
    m_p = 0;
}



template <class T>
inline PyObject* get_managed_object(handle<T> const& h, tag_t)
{
    return h.get() ? python::upcast<PyObject>(h.get()) : (&_Py_NoneStruct);
}

}}
# 11 "/usr/local/include/boost/python/args_fwd.hpp" 2 3




namespace boost { namespace python {

namespace detail
{
  struct keyword
  {
      keyword(char const* name_=0)
       : name(name_)
      {}

      char const* name;
      handle<> default_value;
  };

  template <std::size_t nkeywords = 0> struct keywords;

  typedef std::pair<keyword const*, keyword const*> keyword_range;

  template <>
  struct keywords<0>
  {
      static const std::size_t size = 0;
      static keyword_range range() { return keyword_range(); }
  };

  namespace error
  {
    template <int keywords, int function_args>
    struct more_keywords_than_function_arguments
    {
        typedef char too_many_keywords[keywords > function_args ? -1 : 1];
    };
  }
}

}}
# 11 "/usr/local/include/boost/python/args.hpp" 2 3

# 1 "/usr/local/include/boost/python/detail/preprocessor.hpp" 1 3
# 13 "/usr/local/include/boost/python/args.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/type_list.hpp" 1 3
# 28 "/usr/local/include/boost/python/detail/type_list.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/vector20.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/vector/vector20.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/vector10.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/vector/vector10.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/vector0.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/vector0.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 3
# 1 "/usr/local/include/boost/mpl/at_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/at_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct at_impl;
template< typename Sequence, typename N > struct at;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/tag.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/tag.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/typeof.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/vector/aux_/tag.hpp" 2 3


namespace boost { namespace mpl { namespace aux {

struct v_iter_tag;


struct vector_tag;




}}}
# 19 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/long.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/long.hpp" 3
# 1 "/usr/local/include/boost/mpl/long_fwd.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/long_fwd.hpp" 3
namespace mpl_ {

template< long N > struct long_;

}
namespace boost { namespace mpl { using ::mpl_::long_; } }
# 18 "/usr/local/include/boost/mpl/long.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< long N >
struct long_
{
    static const long value = N;





    typedef long_ type;

    typedef long value_type;
    typedef integral_c_tag tag;
# 72 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;






    constexpr operator long() const { return static_cast<long>(this->value); }
};


template< long N >
long const mpl_::long_< N >::value;


}
# 21 "/usr/local/include/boost/mpl/long.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/void.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/void.hpp" 3
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 21 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/type_wrapper.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/type_wrapper.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}
# 23 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 2 3




namespace boost { namespace mpl {



template< typename Vector, long n_ >
struct v_at_impl
{
    typedef long_< (Vector::lower_bound_::value + n_) > index_;
    typedef __typeof__( Vector::item_(index_()) ) type;
};


template< typename Vector, long n_ >
struct v_at
    : aux::wrapped_type< typename v_at_impl<Vector,n_>::type >
{
};

template<>
struct at_impl< aux::vector_tag >
{
    template< typename Vector, typename N > struct apply
        : v_at<
              Vector
            , N::value
            >
    {
    };
};
# 114 "/usr/local/include/boost/mpl/vector/aux_/at.hpp" 3
}}
# 18 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/front.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/front.hpp" 3
# 1 "/usr/local/include/boost/mpl/front_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/front_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct front_impl;
template< typename Sequence > struct front;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/front.hpp" 2 3






namespace boost { namespace mpl {



template<>
struct front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<Vector,0>
    {
    };
};
# 54 "/usr/local/include/boost/mpl/vector/aux_/front.hpp" 3
}}
# 19 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/push_front.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/push_front.hpp" 3
# 1 "/usr/local/include/boost/mpl/push_front_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/push_front_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/push_front.hpp" 2 3




# 1 "/usr/local/include/boost/mpl/vector/aux_/item.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/vector/aux_/item.hpp" 3
# 1 "/usr/local/include/boost/mpl/next_prior.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/next_prior.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/common_name_wknd.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/next_prior.hpp" 2 3



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/vector/aux_/item.hpp" 2 3




namespace boost { namespace mpl {



template<
      typename T
    , typename Base
    , int at_front = 0
    >
struct v_item
    : Base
{
    typedef typename Base::upper_bound_ index_;
    typedef typename next<index_>::type upper_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;



    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};

template<
      typename T
    , typename Base
    >
struct v_item<T,Base,1>
    : Base
{
    typedef typename prior<typename Base::lower_bound_>::type index_;
    typedef index_ lower_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;

    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};


template<
      typename Base
    , int at_front
    >
struct v_mask
    : Base
{
    typedef typename prior<typename Base::upper_bound_>::type index_;
    typedef index_ upper_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};

template<
      typename Base
    >
struct v_mask<Base,1>
    : Base
{
    typedef typename Base::lower_bound_ index_;
    typedef typename next<index_>::type lower_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};



}}
# 23 "/usr/local/include/boost/mpl/vector/aux_/push_front.hpp" 2 3


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,1> type;
    };
};

}}
# 20 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/pop_front.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/pop_front.hpp" 3
# 1 "/usr/local/include/boost/mpl/pop_front_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/pop_front_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/pop_front.hpp" 2 3







namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,1> type;
    };
};

}}
# 21 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/push_back.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/push_back.hpp" 3
# 1 "/usr/local/include/boost/mpl/push_back_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/push_back_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/push_back.hpp" 2 3







namespace boost { namespace mpl {

template<>
struct push_back_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,0> type;
    };
};

}}
# 22 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/pop_back.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/pop_back.hpp" 3
# 1 "/usr/local/include/boost/mpl/pop_back_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/pop_back_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct pop_back_impl;
template< typename Sequence > struct pop_back;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/pop_back.hpp" 2 3







namespace boost { namespace mpl {

template<>
struct pop_back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,0> type;
    };
};

}}
# 23 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/back.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/back.hpp" 3
# 1 "/usr/local/include/boost/mpl/back_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/back_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct back_impl;
template< typename Sequence > struct back;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/back.hpp" 2 3






namespace boost { namespace mpl {



template<>
struct back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<
              Vector
            , prior<typename Vector::size>::type::value
            >
    {
    };
};
# 57 "/usr/local/include/boost/mpl/vector/aux_/back.hpp" 3
}}
# 24 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/clear.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/clear.hpp" 3
# 1 "/usr/local/include/boost/mpl/clear_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/clear_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/clear.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/vector0.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/vector/aux_/vector0.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 3
# 1 "/usr/local/include/boost/mpl/iterator_tags.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/iterator_tags.hpp" 3
namespace boost { namespace mpl {

struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };

}}
# 19 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/plus.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/plus.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/integral_c.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/integral_c.hpp" 3
# 1 "/usr/local/include/boost/mpl/integral_c_fwd.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/integral_c_fwd.hpp" 3
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/usr/local/include/boost/mpl/integral_c.hpp" 2 3
# 32 "/usr/local/include/boost/mpl/integral_c.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/usr/local/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    constexpr operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/usr/local/include/boost/mpl/integral_c.hpp" 2 3




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 18 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/largest_int.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/largest_int.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct integral_rank;

template<> struct integral_rank<bool> : int_<1> {};
template<> struct integral_rank<signed char> : int_<2> {};
template<> struct integral_rank<char> : int_<3> {};
template<> struct integral_rank<unsigned char> : int_<4> {};

template<> struct integral_rank<wchar_t> : int_<5> {};

template<> struct integral_rank<short> : int_<6> {};
template<> struct integral_rank<unsigned short> : int_<7> {};
template<> struct integral_rank<int> : int_<8> {};
template<> struct integral_rank<unsigned int> : int_<9> {};
template<> struct integral_rank<long> : int_<10> {};
template<> struct integral_rank<unsigned long> : int_<11> {};


template<> struct integral_rank<long_long_type> : int_<12> {};
template<> struct integral_rank<ulong_long_type>: int_<13> {};


template< typename T1, typename T2 > struct largest_int

    : if_c<
          ( integral_rank<T1>::value >= integral_rank<T2>::value )
        , T1
        , T2
        >
{






};

}}}
# 19 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/numeric_cast.hpp" 1 3
# 30 "/usr/local/include/boost/mpl/numeric_cast.hpp" 3
namespace boost { namespace mpl {



template< typename SourceTag, typename TargetTag > struct numeric_cast
{
    template< typename N > struct apply;
};

}}
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/apply_wrap.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/has_apply.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/has_apply.hpp" 3
# 1 "/usr/local/include/boost/mpl/has_xxx.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/has_xxx.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/yes_no.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/yes_no.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/arrays.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/yes_no.hpp" 2 3




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/usr/local/include/boost/mpl/aux_/yes_no.hpp" 3
}}}
# 23 "/usr/local/include/boost/mpl/has_xxx.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/config/has_xxx.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/has_xxx.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/msvc_typename.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/has_xxx.hpp" 2 3




# 1 "/usr/local/include/boost/preprocessor/array/elem.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/array/elem.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/data.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/array/elem.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/array/size.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/array/elem.hpp" 2 3
# 31 "/usr/local/include/boost/mpl/has_xxx.hpp" 2 3



# 1 "/usr/local/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 1 3
# 35 "/usr/local/include/boost/mpl/has_xxx.hpp" 2 3
# 18 "/usr/local/include/boost/mpl/aux_/has_apply.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/has_apply.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/has_apply.hpp" 2 3

namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}
# 24 "/usr/local/include/boost/mpl/apply_wrap.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/msvc_never_true.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/apply_wrap.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1 3
# 29 "/usr/local/include/boost/mpl/apply_wrap.hpp" 2 3





# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 16 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/compiler.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3



# 1 "/usr/local/include/boost/preprocessor/stringize.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 3
namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/usr/local/include/boost/mpl/apply_wrap.hpp" 2 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/tag.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/tag.hpp" 3
# 1 "/usr/local/include/boost/mpl/eval_if.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/eval_if.hpp" 3
namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;




   
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 18 "/usr/local/include/boost/mpl/tag.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/has_tag.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/has_tag.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 20 "/usr/local/include/boost/mpl/tag.hpp" 2 3


namespace boost { namespace mpl {

namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}

template< typename T, typename Default = void_ > struct tag

    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
# 48 "/usr/local/include/boost/mpl/tag.hpp" 3
};

}}
# 25 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_cast_utils.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/numeric_cast_utils.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/config/forwarding.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2 3

namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast1st_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , typename apply_wrap1< numeric_cast<Tag1,Tag2>,N1 >::type
            , N2
            >
    {
# 46 "/usr/local/include/boost/mpl/aux_/numeric_cast_utils.hpp" 3
    };
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast2nd_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , N1
            , typename apply_wrap1< numeric_cast<Tag2,Tag1>,N2 >::type
            >
    {
# 72 "/usr/local/include/boost/mpl/aux_/numeric_cast_utils.hpp" 3
    };
};

}}}
# 26 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/aux_/msvc_eti_base.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/msvc_eti_base.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 3
namespace boost { namespace mpl { namespace aux {
# 62 "/usr/local/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 3
}}}
# 18 "/usr/local/include/boost/mpl/aux_/msvc_eti_base.hpp" 2 3




namespace boost { namespace mpl { namespace aux {
# 55 "/usr/local/include/boost/mpl/aux_/msvc_eti_base.hpp" 3
template< typename T > struct msvc_eti_base
    : T
{

    msvc_eti_base();

    typedef T type;
};



template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};

}}}
# 30 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct plus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< plus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< plus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct plus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct plus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct plus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct plus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct plus
    : plus< plus< plus< plus< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct plus< N1,N2,N3,N4,na >

    : plus< plus< plus< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct plus< N1,N2,N3,na,na >

    : plus< plus< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct plus< N1,N2,na,na,na >
    : plus_impl<
          typename plus_tag<N1>::type
        , typename plus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct plus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : plus< T1 , T2 > { }; }; template< typename Tag > struct lambda< plus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef plus< na , na > result_; typedef plus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< plus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< plus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct plus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  + N2::value
                )
            >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/plus.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/minus.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/minus.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct minus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< minus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< minus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct minus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct minus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct minus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct minus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct minus
    : minus< minus< minus< minus< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct minus< N1,N2,N3,N4,na >

    : minus< minus< minus< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct minus< N1,N2,N3,na,na >

    : minus< minus< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct minus< N1,N2,na,na,na >
    : minus_impl<
          typename minus_tag<N1>::type
        , typename minus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct minus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : minus< T1 , T2 > { }; }; template< typename Tag > struct lambda< minus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef minus< na , na > result_; typedef minus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< minus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< minus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct minus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  - N2::value
                )
            >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/minus.hpp" 2 3
# 21 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/advance_fwd.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/advance_fwd.hpp" 3
namespace boost { namespace mpl {



template< typename Tag > struct advance_impl;
template< typename Iterator, typename N > struct advance;

}}
# 22 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/distance_fwd.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/distance_fwd.hpp" 3
namespace boost { namespace mpl {



template< typename Tag > struct distance_impl;
template< typename First, typename Last > struct distance;

}}
# 23 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/next.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/prior.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 2 3





namespace boost { namespace mpl {

template<
      typename Vector
    , long n_
    >
struct v_iter
{
    typedef aux::v_iter_tag tag;
    typedef random_access_iterator_tag category;
    typedef typename v_at<Vector,n_>::type type;

    typedef Vector vector_;
    typedef mpl::long_<n_> pos;
# 56 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 3
};




template<
      typename Vector
    , long n_
    >
struct next< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ + 1)> type;
};

template<
      typename Vector
    , long n_
    >
struct prior< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ - 1)> type;
};

template<
      typename Vector
    , long n_
    , typename Distance
    >
struct advance< v_iter<Vector,n_>,Distance>
{
    typedef v_iter<
          Vector
        , (n_ + Distance::value)
        > type;
};

template<
      typename Vector
    , long n_
    , long m_
    >
struct distance< v_iter<Vector,n_>, v_iter<Vector,m_> >
    : mpl::long_<(m_ - n_)>
{
};
# 128 "/usr/local/include/boost/mpl/vector/aux_/iterator.hpp" 3
}}
# 23 "/usr/local/include/boost/mpl/vector/aux_/vector0.hpp" 2 3



namespace boost { namespace mpl {

template< typename Dummy = na > struct vector0;

template<> struct vector0<na>
{

    typedef aux::vector_tag tag;
    typedef vector0 type;
    typedef long_<32768> lower_bound_;
    typedef lower_bound_ upper_bound_;
    typedef long_<0> size;

    static aux::type_wrapper<void_> item_(...);
# 48 "/usr/local/include/boost/mpl/vector/aux_/vector0.hpp" 3
};

}}
# 19 "/usr/local/include/boost/mpl/vector/aux_/clear.hpp" 2 3




namespace boost { namespace mpl {



template<>
struct clear_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef vector0<> type;
    };
};
# 53 "/usr/local/include/boost/mpl/vector/aux_/clear.hpp" 3
}}
# 25 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/O1_size.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/O1_size.hpp" 3
# 1 "/usr/local/include/boost/mpl/O1_size_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/O1_size_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/O1_size.hpp" 2 3






namespace boost { namespace mpl {



template<>
struct O1_size_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : Vector::size
    {
    };
};
# 54 "/usr/local/include/boost/mpl/vector/aux_/O1_size.hpp" 3
}}
# 26 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/size.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/size.hpp" 3
# 1 "/usr/local/include/boost/mpl/size_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/size_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct size_impl;
template< typename Sequence > struct size;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/size.hpp" 2 3





namespace boost { namespace mpl {



template<>
struct size_impl< aux::vector_tag >
    : O1_size_impl< aux::vector_tag >
{
};
# 47 "/usr/local/include/boost/mpl/vector/aux_/size.hpp" 3
}}
# 27 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/empty.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/vector/aux_/empty.hpp" 3
# 1 "/usr/local/include/boost/mpl/empty_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/empty_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;

}}
# 18 "/usr/local/include/boost/mpl/vector/aux_/empty.hpp" 2 3






namespace boost { namespace mpl {



template<>
struct empty_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : is_same<
              typename Vector::lower_bound_
            , typename Vector::upper_bound_
            >
    {
    };
};
# 66 "/usr/local/include/boost/mpl/vector/aux_/empty.hpp" 3
}}
# 28 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/vector/aux_/begin_end.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/vector/aux_/begin_end.hpp" 3
# 1 "/usr/local/include/boost/mpl/begin_end_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/begin_end_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;

template< typename Sequence > struct begin;
template< typename Sequence > struct end;

}}
# 22 "/usr/local/include/boost/mpl/vector/aux_/begin_end.hpp" 2 3



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,0> type;
    };
};

template<>
struct end_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,Vector::size::value> type;
    };
};

}}
# 32 "/usr/local/include/boost/mpl/vector/vector0.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/vector/vector10.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/vector/vector10.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 1 3
# 49 "/usr/local/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0
    >
struct vector1
    : v_item<
          T0
        , vector0< >
        >
{
    typedef vector1 type;
};

template<
      typename T0, typename T1
    >
struct vector2
    : v_item<
          T1
        , vector1<T0>
        >
{
    typedef vector2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector3
    : v_item<
          T2
        , vector2< T0,T1 >
        >
{
    typedef vector3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector4
    : v_item<
          T3
        , vector3< T0,T1,T2 >
        >
{
    typedef vector4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector5
    : v_item<
          T4
        , vector4< T0,T1,T2,T3 >
        >
{
    typedef vector5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector6
    : v_item<
          T5
        , vector5< T0,T1,T2,T3,T4 >
        >
{
    typedef vector6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector7
    : v_item<
          T6
        , vector6< T0,T1,T2,T3,T4,T5 >
        >
{
    typedef vector7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector8
    : v_item<
          T7
        , vector7< T0,T1,T2,T3,T4,T5,T6 >
        >
{
    typedef vector8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector9
    : v_item<
          T8
        , vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef vector9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector10
    : v_item<
          T9
        , vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef vector10 type;
};

}}
# 50 "/usr/local/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/vector/vector10.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/vector/vector20.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/vector/vector20.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 1 3
# 49 "/usr/local/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector11
    : v_item<
          T10
        , vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef vector11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector12
    : v_item<
          T11
        , vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef vector12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector13
    : v_item<
          T12
        , vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef vector13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector14
    : v_item<
          T13
        , vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef vector14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector15
    : v_item<
          T14
        , vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef vector15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector16
    : v_item<
          T15
        , vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef vector16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector17
    : v_item<
          T16
        , vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef vector17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector18
    : v_item<
          T17
        , vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef vector18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector19
    : v_item<
          T18
        , vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef vector19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector20
    : v_item<
          T19
        , vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef vector20 type;
};

}}
# 50 "/usr/local/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/vector/vector20.hpp" 2 3
# 29 "/usr/local/include/boost/python/detail/type_list.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 9 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
# 1 "/usr/local/include/boost/python/detail/type_list.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 2 3


# 1 "/usr/local/include/boost/preprocessor/enum_params_with_a_default.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/enum_params_with_a_default.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/enum_params_with_a_default.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/repetition/enum_params_with_a_default.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/facilities/intercept.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/repetition/enum_params_with_a_default.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/repetition/enum_params_with_a_default.hpp" 2 3
# 16 "/usr/local/include/boost/preprocessor/enum_params_with_a_default.hpp" 2 3
# 13 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 2 3



# 1 "/usr/local/include/boost/preprocessor/iterate.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/iterate.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/iterate.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/iteration/iterate.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/slot.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/slot/slot.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/def.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/slot/slot.hpp" 2 3
# 21 "/usr/local/include/boost/preprocessor/iteration/iterate.hpp" 2 3
# 16 "/usr/local/include/boost/preprocessor/iterate.hpp" 2 3
# 17 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/repetition/enum_trailing.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/repetition/enum_trailing.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/repetition/enum_trailing.hpp" 2 3
# 18 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 2 3

namespace boost { namespace python { namespace detail {

template < class T0 = mpl::void_ , class T1 = mpl::void_ , class T2 = mpl::void_ , class T3 = mpl::void_ , class T4 = mpl::void_ , class T5 = mpl::void_ , class T6 = mpl::void_ , class T7 = mpl::void_ , class T8 = mpl::void_ , class T9 = mpl::void_ , class T10 = mpl::void_ , class T11 = mpl::void_ , class T12 = mpl::void_ , class T13 = mpl::void_ , class T14 = mpl::void_ , class T15 = mpl::void_ , class T16 = mpl::void_ >
struct type_list
    : mpl::vector17< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16>
{
};



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
   
    >
struct type_list<
   
   
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector0<>
{
};
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0
    >
struct type_list<
    T0
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector1< T0>
{
};
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1
    >
struct type_list<
    T0 , T1
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector2< T0 , T1>
{
};
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2
    >
struct type_list<
    T0 , T1 , T2
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector3< T0 , T1 , T2>
{
};
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3
    >
struct type_list<
    T0 , T1 , T2 , T3
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector4< T0 , T1 , T2 , T3>
{
};
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector5< T0 , T1 , T2 , T3 , T4>
{
};
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector6< T0 , T1 , T2 , T3 , T4 , T5>
{
};
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector7< T0 , T1 , T2 , T3 , T4 , T5 , T6>
{
};
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
{
};
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
{
};
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
{
};
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector11< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
{
};
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector12< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
{
};
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
    ,
    mpl::void_ , mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector13< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
{
};
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
    ,
    mpl::void_ , mpl::void_ , mpl::void_

    >
   : mpl::vector14< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
{
};
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
    ,
    mpl::void_ , mpl::void_

    >
   : mpl::vector15< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
{
};
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 1 3
# 41 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 3
template <
    class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15
    >
struct type_list<
    T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15
    ,
    mpl::void_

    >
   : mpl::vector16< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15>
{
};
# 128 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 30 "/usr/local/include/boost/python/detail/type_list_impl.hpp" 2 3


}}}
# 34 "/usr/local/include/boost/python/detail/type_list.hpp" 2 3
# 14 "/usr/local/include/boost/python/args.hpp" 2 3





# 1 "/usr/local/include/boost/preprocessor/iteration/local.hpp" 1 3
# 20 "/usr/local/include/boost/python/args.hpp" 2 3

# 1 "/usr/local/include/boost/python/detail/mpl_lambda.hpp" 1 3
# 22 "/usr/local/include/boost/python/args.hpp" 2 3
# 1 "/usr/local/include/boost/python/object_core.hpp" 1 3
# 14 "/usr/local/include/boost/python/object_core.hpp" 3
# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 15 "/usr/local/include/boost/python/call.hpp" 3
# 1 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 1 3







# 1 "/usr/local/include/boost/python/ptr.hpp" 1 3
# 17 "/usr/local/include/boost/python/ptr.hpp" 3
namespace boost { namespace python {

template<class Ptr> class pointer_wrapper
{
 public:
    typedef Ptr type;

    explicit pointer_wrapper(Ptr x): p_(x) {}
    operator Ptr() const { return p_; }
    Ptr get() const { return p_; }
 private:
    Ptr p_;
};

template<class T>
inline pointer_wrapper<T> ptr(T t)
{
    return pointer_wrapper<T>(t);
}

template<typename T>
class is_pointer_wrapper
    : public mpl::false_
{
};

template<typename T>
class is_pointer_wrapper<pointer_wrapper<T> >
    : public mpl::true_
{
};

template<typename T>
class unwrap_pointer
{
 public:
    typedef T type;
};

template<typename T>
class unwrap_pointer<pointer_wrapper<T> >
{
 public:
    typedef T type;
};

}}
# 9 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3

# 1 "/usr/local/include/boost/python/to_python_indirect.hpp" 1 3
# 10 "/usr/local/include/boost/python/to_python_indirect.hpp" 3
# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 14 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3
# 1 "/usr/local/include/boost/python/instance_holder.hpp" 1 3
# 10 "/usr/local/include/boost/python/instance_holder.hpp" 3
# 1 "/usr/local/include/boost/noncopyable.hpp" 1 3
# 15 "/usr/local/include/boost/noncopyable.hpp" 3
# 1 "/usr/local/include/boost/core/noncopyable.hpp" 1 3
# 14 "/usr/local/include/boost/core/noncopyable.hpp" 3
namespace boost {






namespace noncopyable_
{
# 34 "/usr/local/include/boost/core/noncopyable.hpp" 3
  struct base_token {};



  class noncopyable: base_token
  {
  protected:

      constexpr noncopyable() = default;
      ~noncopyable() = default;





      noncopyable( const noncopyable& ) = delete;
      noncopyable& operator=( const noncopyable& ) = delete;





  };
}

typedef noncopyable_::noncopyable noncopyable;

}
# 16 "/usr/local/include/boost/noncopyable.hpp" 2 3
# 11 "/usr/local/include/boost/python/instance_holder.hpp" 2 3
# 1 "/usr/local/include/boost/python/type_id.hpp" 1 3
# 10 "/usr/local/include/boost/python/type_id.hpp" 3
# 1 "/usr/local/include/boost/python/detail/msvc_typeinfo.hpp" 1 3
# 11 "/usr/local/include/boost/python/type_id.hpp" 2 3
# 1 "/usr/local/include/boost/operators.hpp" 1 3
# 98 "/usr/local/include/boost/operators.hpp" 3
# 1 "/usr/include/c++/7/iterator" 1 3
# 58 "/usr/include/c++/7/iterator" 3
       
# 59 "/usr/include/c++/7/iterator" 3





# 1 "/usr/include/c++/7/ostream" 1 3
# 36 "/usr/include/c++/7/ostream" 3
       
# 37 "/usr/include/c++/7/ostream" 3

# 1 "/usr/include/c++/7/ios" 1 3
# 36 "/usr/include/c++/7/ios" 3
       
# 37 "/usr/include/c++/7/ios" 3





# 1 "/usr/include/c++/7/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/7/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/7/bits/ios_base.h" 3



# 1 "/usr/include/c++/7/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/7/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/7/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/7/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/7/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/7/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/7/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/include/c++/7/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/include/c++/7/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/include/c++/7/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/include/c++/7/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/include/c++/7/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/usr/include/c++/7/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/usr/include/c++/7/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/usr/include/c++/7/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/usr/include/c++/7/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/usr/include/c++/7/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/usr/include/c++/7/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "/usr/include/c++/7/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "/usr/include/c++/7/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "/usr/include/c++/7/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "/usr/include/c++/7/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "/usr/include/c++/7/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "/usr/include/c++/7/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "/usr/include/c++/7/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "/usr/include/c++/7/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "/usr/include/c++/7/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "/usr/include/c++/7/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/7/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/7/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/7/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/7/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/7/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "/usr/include/c++/7/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/7/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/7/system_error" 1 3
# 32 "/usr/include/c++/7/system_error" 3
       
# 33 "/usr/include/c++/7/system_error" 3






# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/error_constants.h" 1 3
# 34 "/usr/include/x86_64-linux-gnu/c++/7/bits/error_constants.h" 3
# 1 "/usr/include/c++/7/cerrno" 1 3
# 39 "/usr/include/c++/7/cerrno" 3
       
# 40 "/usr/include/c++/7/cerrno" 3
# 35 "/usr/include/x86_64-linux-gnu/c++/7/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/include/c++/7/system_error" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 71 "/usr/include/c++/7/system_error" 3
  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "/usr/include/c++/7/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };
# 414 "/usr/include/c++/7/system_error" 3

}
# 47 "/usr/include/c++/7/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/include/c++/7/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/include/c++/7/bits/ios_base.h" 3
  public:
# 255 "/usr/include/c++/7/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 487 "/usr/include/c++/7/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 504 "/usr/include/c++/7/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 516 "/usr/include/c++/7/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 629 "/usr/include/c++/7/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 645 "/usr/include/c++/7/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 662 "/usr/include/c++/7/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 688 "/usr/include/c++/7/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 739 "/usr/include/c++/7/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 751 "/usr/include/c++/7/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 762 "/usr/include/c++/7/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 773 "/usr/include/c++/7/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 792 "/usr/include/c++/7/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 808 "/usr/include/c++/7/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 829 "/usr/include/c++/7/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 846 "/usr/include/c++/7/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 860 "/usr/include/c++/7/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/streambuf" 1 3
# 36 "/usr/include/c++/7/streambuf" 3
       
# 37 "/usr/include/c++/7/streambuf" 3
# 45 "/usr/include/c++/7/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/include/c++/7/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/7/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/7/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/7/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/include/c++/7/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/include/c++/7/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/include/c++/7/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/include/c++/7/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/include/c++/7/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/include/c++/7/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/include/c++/7/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/include/c++/7/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/include/c++/7/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/include/c++/7/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/include/c++/7/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/include/c++/7/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/include/c++/7/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/include/c++/7/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/include/c++/7/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/include/c++/7/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/include/c++/7/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/include/c++/7/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/include/c++/7/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/include/c++/7/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/include/c++/7/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/include/c++/7/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/include/c++/7/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/include/c++/7/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/include/c++/7/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/include/c++/7/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/include/c++/7/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/include/c++/7/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "/usr/include/c++/7/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/7/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/7/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 851 "/usr/include/c++/7/streambuf" 2 3
# 44 "/usr/include/c++/7/ios" 2 3
# 1 "/usr/include/c++/7/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/7/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/7/bits/basic_ios.h" 3



# 1 "/usr/include/c++/7/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/7/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/7/bits/locale_facets.h" 3

# 1 "/usr/include/c++/7/cwctype" 1 3
# 39 "/usr/include/c++/7/cwctype" 3
       
# 40 "/usr/include/c++/7/cwctype" 3
# 50 "/usr/include/c++/7/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 51 "/usr/include/c++/7/cwctype" 2 3
# 80 "/usr/include/c++/7/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/7/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/7/cctype" 1 3
# 39 "/usr/include/c++/7/cctype" 3
       
# 40 "/usr/include/c++/7/cctype" 3
# 41 "/usr/include/c++/7/bits/locale_facets.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_base.h" 1 3
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/7/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/7/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/7/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/7/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/7/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/include/c++/7/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/include/c++/7/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/include/c++/7/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/include/c++/7/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "/usr/include/c++/7/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "/usr/include/c++/7/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1156 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "/usr/include/c++/7/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "/usr/include/c++/7/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "/usr/include/c++/7/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "/usr/include/c++/7/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "/usr/include/c++/7/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1947 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "/usr/include/c++/7/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "/usr/include/c++/7/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "/usr/include/c++/7/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "/usr/include/c++/7/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2505 "/usr/include/c++/7/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/7/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/7/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/7/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/include/c++/7/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/include/c++/7/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "/usr/include/c++/7/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/7/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/7/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/include/c++/7/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/include/c++/7/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/include/c++/7/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/include/c++/7/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/include/c++/7/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/include/c++/7/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/include/c++/7/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/include/c++/7/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/include/c++/7/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/include/c++/7/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/include/c++/7/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/7/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/7/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/7/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/7/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/include/c++/7/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/7/ios" 2 3
# 39 "/usr/include/c++/7/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/7/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/include/c++/7/ostream" 3
      pos_type
      tellp();
# 368 "/usr/include/c++/7/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/include/c++/7/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "/usr/include/c++/7/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "/usr/include/c++/7/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "/usr/include/c++/7/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "/usr/include/c++/7/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "/usr/include/c++/7/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 674 "/usr/include/c++/7/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "/usr/include/c++/7/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 694 "/usr/include/c++/7/ostream" 2 3
# 65 "/usr/include/c++/7/iterator" 2 3
# 1 "/usr/include/c++/7/istream" 1 3
# 36 "/usr/include/c++/7/istream" 3
       
# 37 "/usr/include/c++/7/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/7/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/7/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/7/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/7/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/7/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/7/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/7/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/7/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/7/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/7/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/7/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/7/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/7/istream" 3
      int
      sync();
# 570 "/usr/include/c++/7/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/7/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/7/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/include/c++/7/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/include/c++/7/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/include/c++/7/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/include/c++/7/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "/usr/include/c++/7/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/include/c++/7/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/include/c++/7/istream" 2 3
# 66 "/usr/include/c++/7/iterator" 2 3
# 1 "/usr/include/c++/7/bits/stream_iterator.h" 1 3
# 33 "/usr/include/c++/7/bits/stream_iterator.h" 3
       
# 34 "/usr/include/c++/7/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      constexpr istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(std::__addressof(__s))
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return std::__addressof((operator*())); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 152 "/usr/include/c++/7/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_string(0) {}
# 184 "/usr/include/c++/7/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 67 "/usr/include/c++/7/iterator" 2 3
# 99 "/usr/local/include/boost/operators.hpp" 2 3
# 116 "/usr/local/include/boost/operators.hpp" 3
namespace boost
{
namespace operators_impl
{
namespace operators_detail
{

template <typename T> class empty_base {};

}






template <class T, class U, class B = operators_detail::empty_base<T> >
struct less_than_comparable2 : B
{
     friend bool operator<=(const T& x, const U& y) { return !static_cast<bool>(x > y); }
     friend bool operator>=(const T& x, const U& y) { return !static_cast<bool>(x < y); }
     friend bool operator>(const U& x, const T& y) { return y < x; }
     friend bool operator<(const U& x, const T& y) { return y > x; }
     friend bool operator<=(const U& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const U& x, const T& y) { return !static_cast<bool>(y > x); }
};

template <class T, class B = operators_detail::empty_base<T> >
struct less_than_comparable1 : B
{
     friend bool operator>(const T& x, const T& y) { return y < x; }
     friend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }
};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct equality_comparable2 : B
{
     friend bool operator==(const U& y, const T& x) { return x == y; }
     friend bool operator!=(const U& y, const T& x) { return !static_cast<bool>(x == y); }
     friend bool operator!=(const T& y, const U& x) { return !static_cast<bool>(y == x); }
};

template <class T, class B = operators_detail::empty_base<T> >
struct equality_comparable1 : B
{
     friend bool operator!=(const T& x, const T& y) { return !static_cast<bool>(x == y); }
};
# 259 "/usr/local/include/boost/operators.hpp" 3
template <class T, class U, class B = operators_detail::empty_base<T> > struct multipliable2 : B { friend T operator *( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } friend T operator *( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv *= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct multipliable1 : B { friend T operator *( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct addable2 : B { friend T operator +( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } friend T operator +( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv += lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct addable1 : B { friend T operator +( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct subtractable2 : B { friend T operator -( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct subtractable2_left : B { friend T operator -( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct subtractable1 : B { friend T operator -( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct dividable2 : B { friend T operator /( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct dividable2_left : B { friend T operator /( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct dividable1 : B { friend T operator /( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct modable2 : B { friend T operator %( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class U, class B = operators_detail::empty_base<T> > struct modable2_left : B { friend T operator %( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct modable1 : B { friend T operator %( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct xorable2 : B { friend T operator ^( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } friend T operator ^( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv ^= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct xorable1 : B { friend T operator ^( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct andable2 : B { friend T operator &( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } friend T operator &( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv &= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct andable1 : B { friend T operator &( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct orable2 : B { friend T operator |( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } friend T operator |( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv |= lhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct orable1 : B { friend T operator |( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } };







template <class T, class B = operators_detail::empty_base<T> >
struct incrementable : B
{
  friend T operator++(T& x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private:
  typedef T incrementable_type;
};

template <class T, class B = operators_detail::empty_base<T> >
struct decrementable : B
{
  friend T operator--(T& x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private:
  typedef T decrementable_type;
};



template <class T, class P, class B = operators_detail::empty_base<T> >
struct dereferenceable : B
{
  P operator->() const
  {
    return ::boost::addressof(*static_cast<const T&>(*this));
  }
};

template <class T, class I, class R, class B = operators_detail::empty_base<T> >
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast<const T&>(*this) + n);
  }
};
# 357 "/usr/local/include/boost/operators.hpp" 3
template <class T, class U, class B = operators_detail::empty_base<T> > struct left_shiftable2 : B { friend T operator <<( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct left_shiftable1 : B { friend T operator <<( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } };
template <class T, class U, class B = operators_detail::empty_base<T> > struct right_shiftable2 : B { friend T operator >>( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } }; template <class T, class B = operators_detail::empty_base<T> > struct right_shiftable1 : B { friend T operator >>( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } };



template <class T, class U, class B = operators_detail::empty_base<T> >
struct equivalent2 : B
{
  friend bool operator==(const T& x, const U& y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
  }
};

template <class T, class B = operators_detail::empty_base<T> >
struct equivalent1 : B
{
  friend bool operator==(const T&x, const T&y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
  }
};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct partially_ordered2 : B
{
  friend bool operator<=(const T& x, const U& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const U& y)
    { return static_cast<bool>(x > y) || static_cast<bool>(x == y); }
  friend bool operator>(const U& x, const T& y)
    { return y < x; }
  friend bool operator<(const U& x, const T& y)
    { return y > x; }
  friend bool operator<=(const U& x, const T& y)
    { return static_cast<bool>(y > x) || static_cast<bool>(y == x); }
  friend bool operator>=(const U& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(y == x); }
};

template <class T, class B = operators_detail::empty_base<T> >
struct partially_ordered1 : B
{
  friend bool operator>(const T& x, const T& y)
    { return y < x; }
  friend bool operator<=(const T& x, const T& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(x == y); }
};



template <class T, class U, class B = operators_detail::empty_base<T> >
struct totally_ordered2
    : less_than_comparable2<T, U
    , equality_comparable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct totally_ordered1
    : less_than_comparable1<T
    , equality_comparable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct additive2
    : addable2<T, U
    , subtractable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct additive1
    : addable1<T
    , subtractable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct multiplicative2
    : multipliable2<T, U
    , dividable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct multiplicative1
    : multipliable1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct integer_multiplicative2
    : multiplicative2<T, U
    , modable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct integer_multiplicative1
    : multiplicative1<T
    , modable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct arithmetic2
    : additive2<T, U
    , multiplicative2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct arithmetic1
    : additive1<T
    , multiplicative1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct integer_arithmetic2
    : additive2<T, U
    , integer_multiplicative2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct integer_arithmetic1
    : additive1<T
    , integer_multiplicative1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct bitwise2
    : xorable2<T, U
    , andable2<T, U
    , orable2<T, U, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct bitwise1
    : xorable1<T
    , andable1<T
    , orable1<T, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct unit_steppable
    : incrementable<T
    , decrementable<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct shiftable2
    : left_shiftable2<T, U
    , right_shiftable2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct shiftable1
    : left_shiftable1<T
    , right_shiftable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ring_operators2
    : additive2<T, U
    , subtractable2_left<T, U
    , multipliable2<T, U, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ring_operators1
    : additive1<T
    , multipliable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_ring_operators2
    : ring_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_ring_operators1
    : ring_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct field_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct field_operators1
    : ring_operators1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_field_operators2
    : field_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_field_operators1
    : field_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct euclidian_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct euclidian_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U
    , euclidian_ring_operators2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T
    , euclidian_ring_operators1<T, B
      > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct euclidean_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct euclidean_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = operators_detail::empty_base<T> >
struct ordered_euclidean_ring_operators2
    : totally_ordered2<T, U
    , euclidean_ring_operators2<T, U, B
      > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct ordered_euclidean_ring_operators1
    : totally_ordered1<T
    , euclidean_ring_operators1<T, B
      > > {};

template <class T, class P, class B = operators_detail::empty_base<T> >
struct input_iteratable
    : equality_comparable1<T
    , incrementable<T
    , dereferenceable<T, P, B
      > > > {};

template <class T, class B = operators_detail::empty_base<T> >
struct output_iteratable
    : incrementable<T, B
      > {};

template <class T, class P, class B = operators_detail::empty_base<T> >
struct forward_iteratable
    : input_iteratable<T, P, B
      > {};

template <class T, class P, class B = operators_detail::empty_base<T> >
struct bidirectional_iteratable
    : forward_iteratable<T, P
    , decrementable<T, B
      > > {};





template <class T, class P, class D, class R, class B = operators_detail::empty_base<T> >
struct random_access_iteratable
    : bidirectional_iteratable<T, P
    , less_than_comparable1<T
    , additive2<T, D
    , indexable<T, D, R, B
      > > > > {};
# 662 "/usr/local/include/boost/operators.hpp" 3
namespace operators_detail
{



struct true_t {};
struct false_t {};

}
# 679 "/usr/local/include/boost/operators.hpp" 3
template<class T> struct is_chained_base {
  typedef operators_detail::false_t value;
};
# 757 "/usr/local/include/boost/operators.hpp" 3
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct less_than_comparable; template<class T, class U, class B> struct less_than_comparable<T, U, B, operators_detail::false_t> : less_than_comparable2<T, U, B> {}; template<class T, class U> struct less_than_comparable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : less_than_comparable1<T, U> {}; template <class T, class B> struct less_than_comparable<T, T, B, operators_detail::false_t> : less_than_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< less_than_comparable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< less_than_comparable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< less_than_comparable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equality_comparable; template<class T, class U, class B> struct equality_comparable<T, U, B, operators_detail::false_t> : equality_comparable2<T, U, B> {}; template<class T, class U> struct equality_comparable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : equality_comparable1<T, U> {}; template <class T, class B> struct equality_comparable<T, T, B, operators_detail::false_t> : equality_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< equality_comparable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< equality_comparable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< equality_comparable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multipliable; template<class T, class U, class B> struct multipliable<T, U, B, operators_detail::false_t> : multipliable2<T, U, B> {}; template<class T, class U> struct multipliable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : multipliable1<T, U> {}; template <class T, class B> struct multipliable<T, T, B, operators_detail::false_t> : multipliable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< multipliable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< multipliable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< multipliable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct addable; template<class T, class U, class B> struct addable<T, U, B, operators_detail::false_t> : addable2<T, U, B> {}; template<class T, class U> struct addable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : addable1<T, U> {}; template <class T, class B> struct addable<T, T, B, operators_detail::false_t> : addable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< addable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< addable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< addable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct subtractable; template<class T, class U, class B> struct subtractable<T, U, B, operators_detail::false_t> : subtractable2<T, U, B> {}; template<class T, class U> struct subtractable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : subtractable1<T, U> {}; template <class T, class B> struct subtractable<T, T, B, operators_detail::false_t> : subtractable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< subtractable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< subtractable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< subtractable1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< subtractable2_left<T, U, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct dividable; template<class T, class U, class B> struct dividable<T, U, B, operators_detail::false_t> : dividable2<T, U, B> {}; template<class T, class U> struct dividable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : dividable1<T, U> {}; template <class T, class B> struct dividable<T, T, B, operators_detail::false_t> : dividable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< dividable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< dividable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< dividable1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< dividable2_left<T, U, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct modable; template<class T, class U, class B> struct modable<T, U, B, operators_detail::false_t> : modable2<T, U, B> {}; template<class T, class U> struct modable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : modable1<T, U> {}; template <class T, class B> struct modable<T, T, B, operators_detail::false_t> : modable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< modable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< modable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< modable1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< modable2_left<T, U, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct xorable; template<class T, class U, class B> struct xorable<T, U, B, operators_detail::false_t> : xorable2<T, U, B> {}; template<class T, class U> struct xorable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : xorable1<T, U> {}; template <class T, class B> struct xorable<T, T, B, operators_detail::false_t> : xorable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< xorable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< xorable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< xorable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct andable; template<class T, class U, class B> struct andable<T, U, B, operators_detail::false_t> : andable2<T, U, B> {}; template<class T, class U> struct andable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : andable1<T, U> {}; template <class T, class B> struct andable<T, T, B, operators_detail::false_t> : andable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< andable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< andable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< andable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct orable; template<class T, class U, class B> struct orable<T, U, B, operators_detail::false_t> : orable2<T, U, B> {}; template<class T, class U> struct orable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : orable1<T, U> {}; template <class T, class B> struct orable<T, T, B, operators_detail::false_t> : orable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< orable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< orable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< orable1<T, B> > { typedef operators_detail::true_t value; };

template<class T, class B> struct is_chained_base< incrementable<T, B> > { typedef operators_detail::true_t value; };
template<class T, class B> struct is_chained_base< decrementable<T, B> > { typedef operators_detail::true_t value; };

template<class T, class U, class B> struct is_chained_base< dereferenceable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class V, class B> struct is_chained_base< indexable<T, U, V, B> > { typedef operators_detail::true_t value; };

template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct left_shiftable; template<class T, class U, class B> struct left_shiftable<T, U, B, operators_detail::false_t> : left_shiftable2<T, U, B> {}; template<class T, class U> struct left_shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : left_shiftable1<T, U> {}; template <class T, class B> struct left_shiftable<T, T, B, operators_detail::false_t> : left_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< left_shiftable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< left_shiftable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< left_shiftable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct right_shiftable; template<class T, class U, class B> struct right_shiftable<T, U, B, operators_detail::false_t> : right_shiftable2<T, U, B> {}; template<class T, class U> struct right_shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : right_shiftable1<T, U> {}; template <class T, class B> struct right_shiftable<T, T, B, operators_detail::false_t> : right_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< right_shiftable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< right_shiftable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< right_shiftable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equivalent; template<class T, class U, class B> struct equivalent<T, U, B, operators_detail::false_t> : equivalent2<T, U, B> {}; template<class T, class U> struct equivalent<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : equivalent1<T, U> {}; template <class T, class B> struct equivalent<T, T, B, operators_detail::false_t> : equivalent1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< equivalent<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< equivalent2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< equivalent1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct partially_ordered; template<class T, class U, class B> struct partially_ordered<T, U, B, operators_detail::false_t> : partially_ordered2<T, U, B> {}; template<class T, class U> struct partially_ordered<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : partially_ordered1<T, U> {}; template <class T, class B> struct partially_ordered<T, T, B, operators_detail::false_t> : partially_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< partially_ordered<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< partially_ordered2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< partially_ordered1<T, B> > { typedef operators_detail::true_t value; };

template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct totally_ordered; template<class T, class U, class B> struct totally_ordered<T, U, B, operators_detail::false_t> : totally_ordered2<T, U, B> {}; template<class T, class U> struct totally_ordered<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : totally_ordered1<T, U> {}; template <class T, class B> struct totally_ordered<T, T, B, operators_detail::false_t> : totally_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< totally_ordered<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< totally_ordered2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< totally_ordered1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct additive; template<class T, class U, class B> struct additive<T, U, B, operators_detail::false_t> : additive2<T, U, B> {}; template<class T, class U> struct additive<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : additive1<T, U> {}; template <class T, class B> struct additive<T, T, B, operators_detail::false_t> : additive1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< additive<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< additive2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< additive1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multiplicative; template<class T, class U, class B> struct multiplicative<T, U, B, operators_detail::false_t> : multiplicative2<T, U, B> {}; template<class T, class U> struct multiplicative<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : multiplicative1<T, U> {}; template <class T, class B> struct multiplicative<T, T, B, operators_detail::false_t> : multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< multiplicative<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< multiplicative2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< multiplicative1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_multiplicative; template<class T, class U, class B> struct integer_multiplicative<T, U, B, operators_detail::false_t> : integer_multiplicative2<T, U, B> {}; template<class T, class U> struct integer_multiplicative<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : integer_multiplicative1<T, U> {}; template <class T, class B> struct integer_multiplicative<T, T, B, operators_detail::false_t> : integer_multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< integer_multiplicative<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< integer_multiplicative2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< integer_multiplicative1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct arithmetic; template<class T, class U, class B> struct arithmetic<T, U, B, operators_detail::false_t> : arithmetic2<T, U, B> {}; template<class T, class U> struct arithmetic<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : arithmetic1<T, U> {}; template <class T, class B> struct arithmetic<T, T, B, operators_detail::false_t> : arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< arithmetic<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< arithmetic2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< arithmetic1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_arithmetic; template<class T, class U, class B> struct integer_arithmetic<T, U, B, operators_detail::false_t> : integer_arithmetic2<T, U, B> {}; template<class T, class U> struct integer_arithmetic<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : integer_arithmetic1<T, U> {}; template <class T, class B> struct integer_arithmetic<T, T, B, operators_detail::false_t> : integer_arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< integer_arithmetic<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< integer_arithmetic2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< integer_arithmetic1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct bitwise; template<class T, class U, class B> struct bitwise<T, U, B, operators_detail::false_t> : bitwise2<T, U, B> {}; template<class T, class U> struct bitwise<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : bitwise1<T, U> {}; template <class T, class B> struct bitwise<T, T, B, operators_detail::false_t> : bitwise1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< bitwise<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< bitwise2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< bitwise1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class B> struct is_chained_base< unit_steppable<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct shiftable; template<class T, class U, class B> struct shiftable<T, U, B, operators_detail::false_t> : shiftable2<T, U, B> {}; template<class T, class U> struct shiftable<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : shiftable1<T, U> {}; template <class T, class B> struct shiftable<T, T, B, operators_detail::false_t> : shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< shiftable<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< shiftable2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< shiftable1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ring_operators; template<class T, class U, class B> struct ring_operators<T, U, B, operators_detail::false_t> : ring_operators2<T, U, B> {}; template<class T, class U> struct ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ring_operators1<T, U> {}; template <class T, class B> struct ring_operators<T, T, B, operators_detail::false_t> : ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_ring_operators; template<class T, class U, class B> struct ordered_ring_operators<T, U, B, operators_detail::false_t> : ordered_ring_operators2<T, U, B> {}; template<class T, class U> struct ordered_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_ring_operators1<T, U> {}; template <class T, class B> struct ordered_ring_operators<T, T, B, operators_detail::false_t> : ordered_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct field_operators; template<class T, class U, class B> struct field_operators<T, U, B, operators_detail::false_t> : field_operators2<T, U, B> {}; template<class T, class U> struct field_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : field_operators1<T, U> {}; template <class T, class B> struct field_operators<T, T, B, operators_detail::false_t> : field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< field_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< field_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< field_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_field_operators; template<class T, class U, class B> struct ordered_field_operators<T, U, B, operators_detail::false_t> : ordered_field_operators2<T, U, B> {}; template<class T, class U> struct ordered_field_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_field_operators1<T, U> {}; template <class T, class B> struct ordered_field_operators<T, T, B, operators_detail::false_t> : ordered_field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_field_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_field_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_field_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidian_ring_operators; template<class T, class U, class B> struct euclidian_ring_operators<T, U, B, operators_detail::false_t> : euclidian_ring_operators2<T, U, B> {}; template<class T, class U> struct euclidian_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : euclidian_ring_operators1<T, U> {}; template <class T, class B> struct euclidian_ring_operators<T, T, B, operators_detail::false_t> : euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< euclidian_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< euclidian_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< euclidian_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidian_ring_operators; template<class T, class U, class B> struct ordered_euclidian_ring_operators<T, U, B, operators_detail::false_t> : ordered_euclidian_ring_operators2<T, U, B> {}; template<class T, class U> struct ordered_euclidian_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_euclidian_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidian_ring_operators<T, T, B, operators_detail::false_t> : ordered_euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_euclidian_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_euclidian_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_euclidian_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidean_ring_operators; template<class T, class U, class B> struct euclidean_ring_operators<T, U, B, operators_detail::false_t> : euclidean_ring_operators2<T, U, B> {}; template<class T, class U> struct euclidean_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : euclidean_ring_operators1<T, U> {}; template <class T, class B> struct euclidean_ring_operators<T, T, B, operators_detail::false_t> : euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< euclidean_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< euclidean_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< euclidean_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template <class T ,class U = T ,class B = operators_detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidean_ring_operators; template<class T, class U, class B> struct ordered_euclidean_ring_operators<T, U, B, operators_detail::false_t> : ordered_euclidean_ring_operators2<T, U, B> {}; template<class T, class U> struct ordered_euclidean_ring_operators<T, U, operators_detail::empty_base<T>, operators_detail::true_t> : ordered_euclidean_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidean_ring_operators<T, T, B, operators_detail::false_t> : ordered_euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ordered_euclidean_ring_operators<T, U, B, O> > { typedef operators_detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ordered_euclidean_ring_operators2<T, U, B> > { typedef operators_detail::true_t value; }; template<class T, class B> struct is_chained_base< ordered_euclidean_ring_operators1<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< input_iteratable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class B> struct is_chained_base< output_iteratable<T, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< forward_iteratable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class B> struct is_chained_base< bidirectional_iteratable<T, U, B> > { typedef operators_detail::true_t value; };
template<class T, class U, class V, class W, class B> struct is_chained_base< random_access_iteratable<T, U, V, W, B> > { typedef operators_detail::true_t value; };







template <class T, class U>
struct operators2
    : totally_ordered2<T,U
    , integer_arithmetic2<T,U
    , bitwise2<T,U
      > > > {};

template <class T, class U = T>
struct operators : operators2<T, U> {};

template <class T> struct operators<T, T>
    : totally_ordered<T
    , integer_arithmetic<T
    , bitwise<T
    , unit_steppable<T
      > > > > {};





template <class Category,
          class T,
          class Distance = std::ptrdiff_t,
          class Pointer = T*,
          class Reference = T&>
struct iterator_helper
{
  typedef Category iterator_category;
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
  : input_iteratable<T, P
  , iterator_helper<std::input_iterator_tag, V, D, P, R
    > > {};

template<class T>
struct output_iterator_helper
  : output_iteratable<T
  , iterator_helper<std::output_iterator_tag, void, void, void, void
  > >
{
  T& operator*() { return static_cast<T&>(*this); }
  T& operator++() { return static_cast<T&>(*this); }
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct forward_iterator_helper
  : forward_iteratable<T, P
  , iterator_helper<std::forward_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct bidirectional_iterator_helper
  : bidirectional_iteratable<T, P
  , iterator_helper<std::bidirectional_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct random_access_iterator_helper
  : random_access_iteratable<T, P, D, R
  , iterator_helper<std::random_access_iterator_tag, V, D, P, R
    > >
{
  friend D requires_difference_operator(const T& x, const T& y) {
    return x - y;
  }
};

}
using namespace operators_impl;

}
# 12 "/usr/local/include/boost/python/type_id.hpp" 2 3

# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 14 "/usr/local/include/boost/python/type_id.hpp" 2 3
# 26 "/usr/local/include/boost/python/type_id.hpp" 3
namespace boost { namespace python {
# 42 "/usr/local/include/boost/python/type_id.hpp" 3
bool cxxabi_cxa_demangle_is_broken();






struct type_info : private totally_ordered<type_info>
{
    inline type_info(std::type_info const& = typeid(void));

    inline bool operator<(type_info const& rhs) const;
    inline bool operator==(type_info const& rhs) const;

    char const* name() const;
    friend std::ostream& operator<<(
        std::ostream&, type_info const&);

 private:

    typedef char const* base_id_t;




    base_id_t m_base_type;
};





template <class T>
inline type_info type_id()
{
    return type_info(


        typeid(T)



        );
}
# 114 "/usr/local/include/boost/python/type_id.hpp" 3
inline type_info::type_info(std::type_info const& id)
    : m_base_type(

        id.name()



        )
{
}

inline bool type_info::operator<(type_info const& rhs) const
{

    return std::strcmp(m_base_type, rhs.m_base_type) < 0;



}

inline bool type_info::operator==(type_info const& rhs) const
{

    return !std::strcmp(m_base_type, rhs.m_base_type);



}


namespace detail
{
  char const* gcc_demangle(char const*);
}


inline char const* type_info::name() const
{
    char const* raw_name
        = m_base_type



        ;


    return detail::gcc_demangle(raw_name);



}


 std::ostream& operator<<(std::ostream&, type_info const&);

template<>
inline type_info type_id<void>()
{
    return type_info (typeid (void *));
}

template<>
inline type_info type_id<const volatile void>()
{
    return type_info (typeid (void *));
}


}}
# 12 "/usr/local/include/boost/python/instance_holder.hpp" 2 3


namespace boost { namespace python {


struct instance_holder : private noncopyable
{
 public:
    instance_holder();
    virtual ~instance_holder();


    instance_holder* next() const;







    virtual void* holds(type_info, bool null_ptr_only) = 0;

    void install(PyObject* inst) throw();






    static void* allocate(PyObject*, std::size_t offset, std::size_t size);



    static void deallocate(PyObject*, void* storage) throw();
 private:
    instance_holder* m_next;
};







inline instance_holder* instance_holder::next() const
{
    return m_next;
}

}}
# 15 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/inheritance_query.hpp" 1 3
# 10 "/usr/local/include/boost/python/object/inheritance_query.hpp" 3
namespace boost { namespace python { namespace objects {

 void* find_static_type(void* p, type_info src, type_info dst);
 void* find_dynamic_type(void* p, type_info src, type_info dst);

}}}
# 16 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/forward.hpp" 1 3
# 10 "/usr/local/include/boost/python/object/forward.hpp" 3
# 1 "/usr/local/include/boost/python/detail/value_arg.hpp" 1 3






# 1 "/usr/local/include/boost/python/detail/copy_ctor_mutates_rhs.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/is_auto_ptr.hpp" 1 3
# 9 "/usr/local/include/boost/python/detail/is_auto_ptr.hpp" 3
# 1 "/usr/local/include/boost/python/detail/is_xxx.hpp" 1 3







# 1 "/usr/local/include/boost/detail/is_xxx.hpp" 1 3
# 9 "/usr/local/include/boost/python/detail/is_xxx.hpp" 2 3
# 10 "/usr/local/include/boost/python/detail/is_auto_ptr.hpp" 2 3



namespace boost { namespace python { namespace detail {



template <class T> struct is_auto_ptr : boost::false_type { }; template < class T0 > struct is_auto_ptr< std::auto_ptr< T0 > > : boost::true_type { };
# 28 "/usr/local/include/boost/python/detail/is_auto_ptr.hpp" 3
}}}
# 9 "/usr/local/include/boost/python/detail/copy_ctor_mutates_rhs.hpp" 2 3


namespace boost { namespace python { namespace detail {

template <class T>
struct copy_ctor_mutates_rhs
    : is_auto_ptr<T>
{
};

}}}
# 8 "/usr/local/include/boost/python/detail/value_arg.hpp" 2 3

# 1 "/usr/local/include/boost/python/detail/indirect_traits.hpp" 1 3






# 1 "/usr/local/include/boost/detail/indirect_traits.hpp" 1 3
# 11 "/usr/local/include/boost/detail/indirect_traits.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_class.hpp" 1 3
# 31 "/usr/local/include/boost/type_traits/is_class.hpp" 3
namespace boost {

namespace detail {
# 96 "/usr/local/include/boost/type_traits/is_class.hpp" 3
template <typename T>
struct is_class_impl
{
    static const bool value = __is_class(T);
};


}

template <class T> struct is_class : public integral_constant<bool, ::boost::detail::is_class_impl<T>::value> {};






}
# 12 "/usr/local/include/boost/detail/indirect_traits.hpp" 2 3






# 1 "/usr/local/include/boost/type_traits/remove_pointer.hpp" 1 3
# 20 "/usr/local/include/boost/type_traits/remove_pointer.hpp" 3
namespace boost {
# 68 "/usr/local/include/boost/type_traits/remove_pointer.hpp" 3
template <class T> struct remove_pointer{ typedef T type; };
template <class T> struct remove_pointer<T*>{ typedef T type; };
template <class T> struct remove_pointer<T*const>{ typedef T type; };
template <class T> struct remove_pointer<T*volatile>{ typedef T type; };
template <class T> struct remove_pointer<T*const volatile>{ typedef T type; };





   template <class T> using remove_pointer_t = typename remove_pointer<T>::type;



}
# 19 "/usr/local/include/boost/detail/indirect_traits.hpp" 2 3


# 1 "/usr/local/include/boost/detail/select_type.hpp" 1 3
# 16 "/usr/local/include/boost/detail/select_type.hpp" 3
namespace boost { namespace detail {






  template <bool b> struct if_true
  {
      template <class T, class F>
      struct then { typedef T type; };
  };

  template <>
  struct if_true<false>
  {
      template <class T, class F>
      struct then { typedef F type; };
  };
}}
# 22 "/usr/local/include/boost/detail/indirect_traits.hpp" 2 3


namespace boost { namespace detail {

namespace indirect_traits {

template <class T>
struct is_reference_to_const : boost::false_type
{
};

template <class T>
struct is_reference_to_const<T const&> : boost::true_type
{
};
# 45 "/usr/local/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_function : boost::false_type
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : boost::false_type
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : boost::false_type
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
};

template <class T>
struct is_reference_to_function_pointer_aux
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >::value
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : boost::detail::if_true<
          is_reference_to_function<T>::value
      >::template then<
          boost::false_type
        , is_reference_to_function_pointer_aux<T>
      >::type
{
};

template <class T>
struct is_reference_to_non_const
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          !is_reference_to_const<T>::value
      >
{
};

template <class T>
struct is_reference_to_volatile : boost::false_type
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : boost::true_type
{
};
# 137 "/usr/local/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_pointer : boost::false_type
{
};

template <class T>
struct is_reference_to_pointer<T*&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : boost::true_type
{
};

template <class T>
struct is_reference_to_class
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >::value
      >
{
};

template <class T>
struct is_pointer_to_class
    : boost::integral_constant<bool,
          is_pointer<T>::value &&
          is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >::value
      >
{
};


}

using namespace indirect_traits;

}}
# 8 "/usr/local/include/boost/python/detail/indirect_traits.hpp" 2 3

namespace boost { namespace python {
namespace indirect_traits = boost::detail::indirect_traits;
}}
# 10 "/usr/local/include/boost/python/detail/value_arg.hpp" 2 3

namespace boost { namespace python { namespace detail {

template <class T>
struct value_arg
  : mpl::if_<
        copy_ctor_mutates_rhs<T>
      , T
      , typename add_lvalue_reference<
            typename add_const<T>::type
        >::type
  >
{};

}}}
# 11 "/usr/local/include/boost/python/object/forward.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/or.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/or.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/nested_type_wknd.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/aux_/nested_type_wknd.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 24 "/usr/local/include/boost/mpl/or.hpp" 2 3
# 43 "/usr/local/include/boost/mpl/or.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }





}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/usr/local/include/boost/mpl/or.hpp" 2 3
# 14 "/usr/local/include/boost/python/object/forward.hpp" 2 3

namespace boost { namespace python { namespace objects {




template <class T>
struct reference_to_value
{
    typedef typename boost::python::detail::add_lvalue_reference<typename
        boost::python::detail::add_const<T>::type>::type reference;

    reference_to_value(reference x) : m_value(x) {}
    reference get() const { return m_value; }
 private:
    reference m_value;
};




template <class T>
struct forward
    : mpl::if_<
          mpl::or_<python::detail::copy_ctor_mutates_rhs<T>, boost::python::detail::is_scalar<T> >
        , T
        , reference_to_value<T>
      >
{
};

template<typename T>
struct unforward
{
    typedef typename unwrap_reference<T>::type& type;
};

template<typename T>
struct unforward<reference_to_value<T> >
{
    typedef T type;
};

template <typename T>
struct unforward_cref
  : python::detail::value_arg<
        typename unwrap_reference<T>::type
    >
{
};

template<typename T>
struct unforward_cref<reference_to_value<T> >
  : boost::python::detail::add_lvalue_reference<typename boost::python::detail::add_const<T>::type>
{
};


template <class T>
typename reference_to_value<T>::reference
do_unforward(reference_to_value<T> const& x, int)
{
    return x.get();
}

template <class T>
typename reference_wrapper<T>::type&
do_unforward(reference_wrapper<T> const& x, int)
{
    return x.get();
}

template <class T>
T const& do_unforward(T const& x, ...)
{
    return x;
}

}}}
# 17 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3

# 1 "/usr/local/include/boost/python/pointee.hpp" 1 3
# 11 "/usr/local/include/boost/python/pointee.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <bool is_ptr = true>
  struct pointee_impl
  {
      template <class T> struct apply : detail::remove_pointer<T> {};
  };

  template <>
  struct pointee_impl<false>
  {
      template <class T> struct apply
      {
          typedef typename T::element_type type;
      };
  };
}

template <class T>
struct pointee
    : detail::pointee_impl<
        detail::is_pointer<T>::value
      >::template apply<T>
{
};

}}
# 19 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3


# 1 "/usr/local/include/boost/python/detail/wrapper_base.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/wrapper_base.hpp" 3
namespace boost { namespace python {

class override;

namespace detail
{
  class wrapper_base;

  namespace wrapper_base_
  {
    inline PyObject* get_owner(wrapper_base const volatile& w);

    inline PyObject*
    owner_impl(void const volatile* , detail::false_)
    {
        return 0;
    }

    template <class T>
    inline PyObject*
    owner_impl(T const volatile* x, detail::true_);

    template <class T>
    inline PyObject*
    owner(T const volatile* x)
    {
        return wrapper_base_::owner_impl(x,is_polymorphic<T>());
    }
  }

  class wrapper_base
  {
      friend void initialize_wrapper(PyObject* self, wrapper_base* w);
      friend PyObject* wrapper_base_::get_owner(wrapper_base const volatile& w);
   protected:
      wrapper_base() : m_self(0) {}

      override get_override(
          char const* name, PyTypeObject* class_object) const;

   private:
      void detach();

   private:
      PyObject* m_self;
  };

  namespace wrapper_base_
  {
    template <class T>
    inline PyObject*
    owner_impl(T const volatile* x, detail::true_)
    {
        if (wrapper_base const volatile* w = dynamic_cast<wrapper_base const volatile*>(x))
        {
            return wrapper_base_::get_owner(*w);
        }
        return 0;
    }

    inline PyObject* get_owner(wrapper_base const volatile& w)
    {
        return w.m_self;
    }
  }

  inline void initialize_wrapper(PyObject* self, wrapper_base* w)
  {
      w->m_self = self;
  }

  inline void initialize_wrapper(PyObject* , ...) {}



}

}}
# 22 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/force_instantiate.hpp" 1 3







namespace boost { namespace python { namespace detail {




template <class T>
inline void force_instantiate(T const&) {}

}}}
# 23 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3





# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/apply.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_fwd.hpp" 1 3
# 31 "/usr/local/include/boost/mpl/apply_fwd.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 3
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 32 "/usr/local/include/boost/mpl/apply_fwd.hpp" 2 3
# 23 "/usr/local/include/boost/mpl/apply.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/apply.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/placeholders.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/placeholders.hpp" 3
# 1 "/usr/local/include/boost/mpl/arg.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/arg.hpp" 3
# 1 "/usr/local/include/boost/mpl/arg_fwd.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/arg_fwd.hpp" 3
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 24 "/usr/local/include/boost/mpl/arg.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/na_assert.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/na_assert.hpp" 3
# 1 "/usr/local/include/boost/mpl/assert.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/assert.hpp" 3
# 1 "/usr/local/include/boost/mpl/not.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/not.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 18 "/usr/local/include/boost/mpl/assert.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/assert.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/gpu.hpp" 1 3
# 29 "/usr/local/include/boost/mpl/assert.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/config/pp_counter.hpp" 1 3
# 31 "/usr/local/include/boost/mpl/assert.hpp" 2 3
# 66 "/usr/local/include/boost/mpl/assert.hpp" 3
namespace mpl_ {

struct failed {};
# 79 "/usr/local/include/boost/mpl/assert.hpp" 3
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 127 "/usr/local/include/boost/mpl/assert.hpp" 3
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};
# 171 "/usr/local/include/boost/mpl/assert.hpp" 3
template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};







template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );






template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 257 "/usr/local/include/boost/mpl/assert.hpp" 3
}
# 24 "/usr/local/include/boost/mpl/aux_/na_assert.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/arg.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/arity_spec.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/arg.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/arg_typedef.hpp" 1 3
# 28 "/usr/local/include/boost/mpl/arg.hpp" 2 3
# 37 "/usr/local/include/boost/mpl/arg.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1 3
# 13 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 38 "/usr/local/include/boost/mpl/arg.hpp" 2 3
# 25 "/usr/local/include/boost/mpl/placeholders.hpp" 2 3
# 43 "/usr/local/include/boost/mpl/placeholders.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1 3
# 13 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 3
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/usr/local/include/boost/mpl/placeholders.hpp" 2 3
# 25 "/usr/local/include/boost/mpl/apply.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/lambda.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/lambda.hpp" 3
# 1 "/usr/local/include/boost/mpl/bind.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/bind.hpp" 3
# 1 "/usr/local/include/boost/mpl/bind_fwd.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/bind_fwd.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/config/bind.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/bind_fwd.hpp" 2 3






# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 3
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 33 "/usr/local/include/boost/mpl/bind_fwd.hpp" 2 3
# 24 "/usr/local/include/boost/mpl/bind.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/placeholders.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/bind.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/protect.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/protect.hpp" 3
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
# 48 "/usr/local/include/boost/mpl/protect.hpp" 3
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
# 27 "/usr/local/include/boost/mpl/bind.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 28 "/usr/local/include/boost/mpl/bind.hpp" 2 3
# 50 "/usr/local/include/boost/mpl/bind.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1 3
# 13 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 51 "/usr/local/include/boost/mpl/bind.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/lambda.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 3
# 1 "/usr/local/include/boost/mpl/bind_fwd.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/quote.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/quote.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/has_type.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/has_type.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 24 "/usr/local/include/boost/mpl/quote.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/aux_/config/bcc.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/quote.hpp" 2 3
# 45 "/usr/local/include/boost/mpl/quote.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 3
namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 46 "/usr/local/include/boost/mpl/quote.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/arg.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/aux_/template_arity.hpp" 1 3
# 43 "/usr/local/include/boost/mpl/aux_/template_arity.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) )

         ;
};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1

         ;
};

template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value )

          ;
    typedef mpl::int_<value> type;
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/usr/local/include/boost/mpl/aux_/template_arity.hpp" 2 3
# 30 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 44 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 45 "/usr/local/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 23 "/usr/local/include/boost/mpl/lambda.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/apply.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/apply.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 3
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{
   




};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   




};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   




};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   




};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 37 "/usr/local/include/boost/mpl/apply.hpp" 2 3
# 29 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3




# 1 "/usr/local/include/boost/preprocessor/debug/line.hpp" 1 3
# 34 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3





namespace boost { namespace python {

template <class T> class wrapper;

}}


namespace boost { namespace python { namespace objects {



template <class Pointer, class Value>
struct pointer_holder : instance_holder
{
    typedef Value value_type;

    pointer_holder(Pointer);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3







    pointer_holder(PyObject* self )
        : m_p(new Value(
               
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 >

    pointer_holder(PyObject* self , A0 a0)
        : m_p(new Value(
                objects::do_unforward(a0,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 187 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 >

    pointer_holder(PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13 , A14 a14)
        : m_p(new Value(
                objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0) , objects::do_unforward(a14,0)
            ))
    {
        python::detail::initialize_wrapper(self, get_pointer(this->m_p));
    }
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 61 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3

 private:

 private:
    void* holds(type_info, bool null_ptr_only);

    template <class T>
    inline void* holds_wrapped(type_info dst_t, wrapper<T>*,T* p)
    {
        return python::type_id<T>() == dst_t ? p : 0;
    }

    inline void* holds_wrapped(type_info, ...)
    {
        return 0;
    }

 private:
    Pointer m_p;
};

template <class Pointer, class Value>
struct pointer_holder_back_reference : instance_holder
{
 private:
    typedef typename python::pointee<Pointer>::type held_type;
 public:
    typedef Value value_type;



    pointer_holder_back_reference(Pointer);



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3







    pointer_holder_back_reference(
        PyObject* p )
        : m_p(new held_type(
                    p
            ))
    {}
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0)
            ))
    {}
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0)
            ))
    {}
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0)
            ))
    {}
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0)
            ))
    {}
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0)
            ))
    {}
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0)
            ))
    {}
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0)
            ))
    {}
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0)
            ))
    {}
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0)
            ))
    {}
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0)
            ))
    {}
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0)
            ))
    {}
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0)
            ))
    {}
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0)
            ))
    {}
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0)
            ))
    {}
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 209 "/usr/local/include/boost/python/object/pointer_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 >

    pointer_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13 , A14 a14)
        : m_p(new held_type(
                    p , objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0) , objects::do_unforward(a14,0)
            ))
    {}
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 97 "/usr/local/include/boost/python/object/pointer_holder.hpp" 2 3

 private:
    void* holds(type_info, bool null_ptr_only);

 private:
    Pointer m_p;
};



template <class Pointer, class Value>
inline pointer_holder<Pointer,Value>::pointer_holder(Pointer p)



    : m_p(std::move(p))

{
}

template <class Pointer, class Value>
inline pointer_holder_back_reference<Pointer,Value>::pointer_holder_back_reference(Pointer p)



    : m_p(std::move(p))

{
}

template <class Pointer, class Value>
void* pointer_holder<Pointer, Value>::holds(type_info dst_t, bool null_ptr_only)
{
    typedef typename boost::python::detail::remove_const< Value >::type non_const_value;

    if (dst_t == python::type_id<Pointer>()
        && !(null_ptr_only && get_pointer(this->m_p))
    )
        return &this->m_p;

    Value* p0



        = get_pointer(this->m_p)

        ;
    non_const_value* p = const_cast<non_const_value*>( p0 );

    if (p == 0)
        return 0;

    if (void* wrapped = holds_wrapped(dst_t, p, p))
        return wrapped;

    type_info src_t = python::type_id<non_const_value>();
    return src_t == dst_t ? p : find_dynamic_type(p, src_t, dst_t);
}

template <class Pointer, class Value>
void* pointer_holder_back_reference<Pointer, Value>::holds(type_info dst_t, bool null_ptr_only)
{
    if (dst_t == python::type_id<Pointer>()
        && !(null_ptr_only && get_pointer(this->m_p))
    )
        return &this->m_p;

    if (!get_pointer(this->m_p))
        return 0;

    Value* p = get_pointer(m_p);

    if (dst_t == python::type_id<held_type>())
        return p;

    type_info src_t = python::type_id<Value>();
    return src_t == dst_t ? p : find_dynamic_type(p, src_t, dst_t);
}

}}}
# 11 "/usr/local/include/boost/python/to_python_indirect.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/make_ptr_instance.hpp" 1 3







# 1 "/usr/local/include/boost/python/object/make_instance.hpp" 1 3
# 9 "/usr/local/include/boost/python/object/make_instance.hpp" 3
# 1 "/usr/local/include/boost/python/object/instance.hpp" 1 3
# 12 "/usr/local/include/boost/python/object/instance.hpp" 3
namespace boost { namespace python
{
  struct instance_holder;
}}

namespace boost { namespace python { namespace objects {


template <class Data = char>
struct instance
{
    Py_ssize_t ob_refcnt; struct _typeobject *ob_type; Py_ssize_t ob_size;
    PyObject* dict;
    PyObject* weakrefs;
    instance_holder* objects;

    typedef typename boost::python::detail::type_with_alignment<
        boost::python::detail::alignment_of<Data>::value
    >::type align_t;

    union
    {
        align_t align;
        char bytes[sizeof(Data)];
    } storage;
};

template <class Data>
struct additional_instance_size
{
    typedef instance<Data> instance_data;
    typedef instance<char> instance_char;
    static const std::size_t value = sizeof(instance_data) - __builtin_offsetof (instance_char, storage)

                                                                          ;
};

}}}
# 10 "/usr/local/include/boost/python/object/make_instance.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/registered.hpp" 1 3
# 11 "/usr/local/include/boost/python/converter/registered.hpp" 3
# 1 "/usr/local/include/boost/python/converter/registry.hpp" 1 3







# 1 "/usr/local/include/boost/python/converter/to_python_function_type.hpp" 1 3
# 10 "/usr/local/include/boost/python/converter/to_python_function_type.hpp" 3
namespace boost { namespace python { namespace converter {




typedef PyObject* (*to_python_function_t)(void const*);

}}}
# 9 "/usr/local/include/boost/python/converter/registry.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/rvalue_from_python_data.hpp" 1 3







# 1 "/usr/local/include/boost/python/converter/constructor_function.hpp" 1 3







namespace boost { namespace python { namespace converter {



struct rvalue_from_python_stage1_data;
typedef void (*constructor_function)(PyObject* source, rvalue_from_python_stage1_data*);

}}}
# 9 "/usr/local/include/boost/python/converter/rvalue_from_python_data.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/referent_storage.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/referent_storage.hpp" 3
namespace boost { namespace python { namespace detail {

struct alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();






template <std::size_t size>
union aligned_storage
{
    typename mpl::if_c< sizeof(char) <= size, char, char>::type t0;
    typename mpl::if_c< sizeof(short) <= size, short, char>::type t1;
    typename mpl::if_c< sizeof(int) <= size, int, char>::type t2;
    typename mpl::if_c< sizeof(long) <= size, long, char>::type t3;
    typename mpl::if_c< sizeof(float) <= size, float, char>::type t4;
    typename mpl::if_c< sizeof(double) <= size, double, char>::type t5;
    typename mpl::if_c< sizeof(long double) <= size, long double, char>::type t6;
    typename mpl::if_c< sizeof(void*) <= size, void*, char>::type t7;
    typename mpl::if_c< sizeof(function_ptr) <= size, function_ptr, char>::type t8;
    typename mpl::if_c< sizeof(member_ptr) <= size, member_ptr, char>::type t9;
    typename mpl::if_c< sizeof(member_function_ptr) <= size, member_function_ptr, char>::type t10;
    char bytes[size];
};





  template <class T> struct referent_size;


  template <class T>
  struct referent_size<T&>
  {
      static const std::size_t value = sizeof(T)
                                         ;
  };




template <class T>
struct referent_storage
{
    typedef aligned_storage<
        ::boost::python::detail::referent_size<T>::value
    > type;
};

}}}
# 10 "/usr/local/include/boost/python/converter/rvalue_from_python_data.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/destroy.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/destroy.hpp" 3
namespace boost { namespace python { namespace detail {

template <bool array> struct value_destroyer;

template <>
struct value_destroyer<false>
{
    template <class T>
    static void execute(T const volatile* p)
    {
        p->~T();
    }
};

template <>
struct value_destroyer<true>
{
    template <class A, class T>
    static void execute(A*, T const volatile* const first)
    {
        for (T const volatile* p = first; p != first + sizeof(A)/sizeof(T); ++p)
        {
            value_destroyer<
                is_array<T>::value
            >::execute(p);
        }
    }

    template <class T>
    static void execute(T const volatile* p)
    {
        execute(p, *p);
    }
};

template <class T>
inline void destroy_referent_impl(void* p, T& (*)())
{


    value_destroyer<
         (is_array<T>::value)
    >::execute((const volatile T*)p);
}

template <class T>
inline void destroy_referent(void* p, T(*)() = 0)
{
    destroy_referent_impl(p, (T(*)())0);
}

}}}
# 11 "/usr/local/include/boost/python/converter/rvalue_from_python_data.hpp" 2 3
# 38 "/usr/local/include/boost/python/converter/rvalue_from_python_data.hpp" 3
namespace boost { namespace python { namespace converter {
# 61 "/usr/local/include/boost/python/converter/rvalue_from_python_data.hpp" 3
struct rvalue_from_python_stage1_data
{
    void* convertible;
    constructor_function construct;
};







template <class T>
struct rvalue_from_python_storage
{
    rvalue_from_python_stage1_data stage1;


    typename python::detail::referent_storage<
        typename boost::python::detail::add_lvalue_reference<T>::type
    >::type storage;
};







template <class T>
struct rvalue_from_python_data : rvalue_from_python_storage<T>
{





    static_assert(__builtin_offsetof (rvalue_from_python_storage<T>, stage1) == 0, "BOOST_PYTHON_OFFSETOF(rvalue_from_python_storage<T>,stage1) == 0");



    rvalue_from_python_data(rvalue_from_python_stage1_data const&);




    rvalue_from_python_data(void* convertible);


    ~rvalue_from_python_data();
 private:
    typedef typename boost::python::detail::add_lvalue_reference<
                typename boost::python::detail::add_cv<T>::type>::type ref_type;
};




template <class T>
inline rvalue_from_python_data<T>::rvalue_from_python_data(rvalue_from_python_stage1_data const& _stage1)
{
    this->stage1 = _stage1;
}

template <class T>
inline rvalue_from_python_data<T>::rvalue_from_python_data(void* convertible)
{
    this->stage1.convertible = convertible;
}

template <class T>
inline rvalue_from_python_data<T>::~rvalue_from_python_data()
{
    if (this->stage1.convertible == this->storage.bytes)
        python::detail::destroy_referent<ref_type>(this->storage.bytes);
}

}}}
# 10 "/usr/local/include/boost/python/converter/registry.hpp" 2 3

# 1 "/usr/local/include/boost/python/converter/convertible_function.hpp" 1 3







namespace boost { namespace python { namespace converter {

typedef void* (*convertible_function)(PyObject*);

}}}
# 12 "/usr/local/include/boost/python/converter/registry.hpp" 2 3

namespace boost { namespace python { namespace converter {

struct registration;


namespace registry
{

  registration const& lookup(type_info);



  registration const& lookup_shared_ptr(type_info);


  registration const* query(type_info);

  void insert(to_python_function_t, type_info, PyTypeObject const* (*to_python_target_type)() = 0);


  void insert(convertible_function, type_info, PyTypeObject const* (*expected_pytype)() = 0);


  void insert(
      convertible_function
      , constructor_function
      , type_info
      , PyTypeObject const* (*expected_pytype)() = 0
      );



  void push_back(
      convertible_function
      , constructor_function
      , type_info
      , PyTypeObject const* (*expected_pytype)() = 0
      );
}

}}}
# 12 "/usr/local/include/boost/python/converter/registered.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/registrations.hpp" 1 3
# 18 "/usr/local/include/boost/python/converter/registrations.hpp" 3
namespace boost { namespace python { namespace converter {

struct lvalue_from_python_chain
{
    convertible_function convert;
    lvalue_from_python_chain* next;
};

struct rvalue_from_python_chain
{
    convertible_function convertible;
    constructor_function construct;
    PyTypeObject const* (*expected_pytype)();
    rvalue_from_python_chain* next;
};

struct registration
{
 public:
    explicit registration(type_info target, bool is_shared_ptr = false);
   ~registration();


    PyObject* to_python(void const volatile*) const;



    PyTypeObject* get_class_object() const;



    PyTypeObject const* expected_from_python_type() const;
    PyTypeObject const* to_python_target_type() const;

 public:
    const python::type_info target_type;


    lvalue_from_python_chain* lvalue_chain;


    rvalue_from_python_chain* rvalue_chain;


    PyTypeObject* m_class_object;


    to_python_function_t m_to_python;
    PyTypeObject const* (*m_to_python_target_type)();




    const bool is_shared_ptr;





};




inline registration::registration(type_info target_type, bool is_shared_ptr)
    : target_type(target_type)
      , lvalue_chain(0)
      , rvalue_chain(0)
      , m_class_object(0)
      , m_to_python(0)
      , m_to_python_target_type(0)
      , is_shared_ptr(is_shared_ptr)
{}

inline bool operator<(registration const& lhs, registration const& rhs)
{
    return lhs.target_type < rhs.target_type;
}

}}}
# 13 "/usr/local/include/boost/python/converter/registered.hpp" 2 3
# 22 "/usr/local/include/boost/python/converter/registered.hpp" 3
namespace boost {




template <class T> class shared_ptr;

namespace python { namespace converter {

struct registration;

namespace detail
{
  template <class T>
  struct registered_base
  {
      static registration const& converters;
  };
}

template <class T>
struct registered
  : detail::registered_base<
        typename boost::python::detail::add_lvalue_reference<
            typename boost::python::detail::add_cv<T>::type
        >::type
    >
{
};






template <class T>
struct registered<T&>
  : registered<T> {};





namespace detail
{
  inline void
  register_shared_ptr0(...)
  {
  }

  template <class T>
  inline void
  register_shared_ptr0(shared_ptr<T>*)
  {
      registry::lookup_shared_ptr(type_id<shared_ptr<T> >());
  }


  template <class T>
  inline void
  register_shared_ptr0(std::shared_ptr<T>*)
  {
      registry::lookup_shared_ptr(type_id<std::shared_ptr<T> >());
  }


  template <class T>
  inline void
  register_shared_ptr1(T const volatile*)
  {
      detail::register_shared_ptr0((T*)0);
  }

  template <class T>
  inline registration const&
  registry_lookup2(T&(*)())
  {
      detail::register_shared_ptr1((T*)0);
      return registry::lookup(type_id<T&>());
  }

  template <class T>
  inline registration const&
  registry_lookup1(type<T>)
  {
      return registry_lookup2((T(*)())0);
  }

  inline registration const&
  registry_lookup1(type<const volatile void>)
  {
      detail::register_shared_ptr1((void*)0);
      return registry::lookup(type_id<void>());
  }

  template <class T>
  registration const& registered_base<T>::converters = detail::registry_lookup1(type<T>());

}

}}}
# 11 "/usr/local/include/boost/python/object/make_instance.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/decref_guard.hpp" 1 3







namespace boost { namespace python { namespace detail {

struct decref_guard
{
    decref_guard(PyObject* o) : obj(o) {}
    ~decref_guard() { do { if ((obj) == __null) ; else do { if ( --((PyObject*)(obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(obj)))); } while (0); } while (0); }
    void cancel() { obj = 0; }
 private:
    PyObject* obj;
};

}}}
# 12 "/usr/local/include/boost/python/object/make_instance.hpp" 2 3

# 1 "/usr/local/include/boost/python/detail/none.hpp" 1 3
# 14 "/usr/local/include/boost/python/detail/none.hpp" 3
namespace boost { namespace python { namespace detail {

inline PyObject* none() { ( ((PyObject*)((&_Py_NoneStruct)))->ob_refcnt++); return (&_Py_NoneStruct); }

}}}
# 14 "/usr/local/include/boost/python/object/make_instance.hpp" 2 3



namespace boost { namespace python { namespace objects {

template <class T, class Holder, class Derived>
struct make_instance_impl
{
    typedef objects::instance<Holder> instance_t;

    template <class Arg>
    static inline PyObject* execute(Arg& x)
    {
        enum { mpl_assertion_in_line_28 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (mpl::or_<boost::python::detail::is_class<T>, boost::python::detail::is_union<T> >))0, 1 ) ) ) }
                                                      ;

        PyTypeObject* type = Derived::get_class_object(x);

        if (type == 0)
            return python::detail::none();

        PyObject* raw_result = type->tp_alloc(
            type, objects::additional_instance_size<Holder>::value);

        if (raw_result != 0)
        {
            python::detail::decref_guard protect(raw_result);

            instance_t* instance = (instance_t*)raw_result;



            Derived::construct(&instance->storage, (PyObject*)instance, x)->install(raw_result);



            (((PyVarObject*)(instance))->ob_size) = __builtin_offsetof (instance_t, storage);


            protect.cancel();
        }
        return raw_result;
    }
};


template <class T, class Holder>
struct make_instance
    : make_instance_impl<T, Holder, make_instance<T,Holder> >
{
    template <class U>
    static inline PyTypeObject* get_class_object(U&)
    {
        return converter::registered<T>::converters.get_class_object();
    }

    static inline Holder* construct(void* storage, PyObject* instance, reference_wrapper<T const> x)
    {
        return new (storage) Holder(instance, x);
    }
};


}}}
# 9 "/usr/local/include/boost/python/object/make_ptr_instance.hpp" 2 3






namespace boost { namespace python { namespace objects {

template <class T, class Holder>
struct make_ptr_instance
    : make_instance_impl<T, Holder, make_ptr_instance<T,Holder> >
{
    template <class Arg>
    static inline Holder* construct(void* storage, PyObject*, Arg& x)
    {



      return new (storage) Holder(std::move(x));

    }

    template <class Ptr>
    static inline PyTypeObject* get_class_object(Ptr const& x)
    {
        return get_class_object_impl(get_pointer(x));
    }

    static inline PyTypeObject const* get_pytype()
    {
        return converter::registered<T>::converters.get_class_object();
    }

 private:
    template <class U>
    static inline PyTypeObject* get_class_object_impl(U const volatile* p)
    {
        if (p == 0)
            return 0;

        PyTypeObject* derived = get_derived_class_object(
            typename boost::python::detail::is_polymorphic<U>::type(), p);

        if (derived)
            return derived;
        return converter::registered<T>::converters.get_class_object();
    }

    template <class U>
    static inline PyTypeObject* get_derived_class_object(boost::python::detail::true_, U const volatile* x)
    {
        converter::registration const* r = converter::registry::query(
            type_info(typeid(*x))
        );
        return r ? r->m_class_object : 0;
    }

    template <class U>
    static inline PyTypeObject* get_derived_class_object(boost::python::detail::false_, U*)
    {
        return 0;
    }
};


}}}
# 12 "/usr/local/include/boost/python/to_python_indirect.hpp" 2 3




# 1 "/usr/local/include/boost/python/converter/pytype_function.hpp" 1 3
# 10 "/usr/local/include/boost/python/converter/pytype_function.hpp" 3
# 1 "/usr/local/include/boost/python/detail/unwind_type.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/cv_category.hpp" 1 3
# 9 "/usr/local/include/boost/python/detail/cv_category.hpp" 3
namespace boost { namespace python { namespace detail {

template <bool is_const_, bool is_volatile_>
struct cv_tag
{
    static const bool is_const = is_const_;
    static const bool is_volatile = is_volatile_;
};

typedef cv_tag<false,false> cv_unqualified;
typedef cv_tag<true,false> const_;
typedef cv_tag<false,true> volatile_;
typedef cv_tag<true,true> const_volatile_;

template <class T>
struct cv_category
{


    typedef cv_tag<
        is_const<T>::value
      , is_volatile<T>::value
    > type;
};

}}}
# 9 "/usr/local/include/boost/python/detail/unwind_type.hpp" 2 3



namespace boost { namespace python { namespace detail {





template <class Generator, class U>
inline typename Generator::result_type
unwind_type(U const& p, Generator* = 0);


template <class Generator, class U>
inline typename Generator::result_type
unwind_type(boost::type<U>*p = 0, Generator* = 0);


template <class Generator, class U>
inline typename Generator::result_type
unwind_type_cv(U* p, cv_unqualified, Generator* = 0)
{
    return Generator::execute(p);
}

template <class Generator, class U>
inline typename Generator::result_type
unwind_type_cv(U const* p, const_, Generator* = 0)
{
    return unwind_type(const_cast<U*>(p), (Generator*)0);
}

template <class Generator, class U>
inline typename Generator::result_type
unwind_type_cv(U volatile* p, volatile_, Generator* = 0)
{
    return unwind_type(const_cast<U*>(p), (Generator*)0);
}

template <class Generator, class U>
inline typename Generator::result_type
unwind_type_cv(U const volatile* p, const_volatile_, Generator* = 0)
{
    return unwind_type(const_cast<U*>(p), (Generator*)0);
}

template <class Generator, class U>
inline typename Generator::result_type
unwind_ptr_type(U* p, Generator* = 0)
{
    typedef typename cv_category<U>::type tag;
    return unwind_type_cv<Generator>(p, tag());
}

template <bool is_ptr>
struct unwind_helper
{
    template <class Generator, class U>
    static typename Generator::result_type
    execute(U p, Generator* = 0)
    {
        return unwind_ptr_type(p, (Generator*)0);
    }
};

template <>
struct unwind_helper<false>
{
    template <class Generator, class U>
    static typename Generator::result_type
    execute(U& p, Generator* = 0)
    {
        return unwind_ptr_type(&p, (Generator*)0);
    }
};

template <class Generator, class U>
inline typename Generator::result_type

unwind_type(U const& p, Generator*)



{
    return unwind_helper<is_pointer<U>::value>::execute(p, (Generator*)0);
}

enum { direct_ = 0, pointer_ = 1, reference_ = 2, reference_to_pointer_ = 3 };
template <int indirection> struct unwind_helper2;

template <>
struct unwind_helper2<direct_>
{
    template <class Generator, class U>
    static typename Generator::result_type
    execute(U(*)(), Generator* = 0)
    {
        return unwind_ptr_type((U*)0, (Generator*)0);
    }
};

template <>
struct unwind_helper2<pointer_>
{
    template <class Generator, class U>
    static typename Generator::result_type
    execute(U*(*)(), Generator* = 0)
    {
        return unwind_ptr_type((U*)0, (Generator*)0);
    }
};

template <>
struct unwind_helper2<reference_>
{
    template <class Generator, class U>
    static typename Generator::result_type
    execute(U&(*)(), Generator* = 0)
    {
        return unwind_ptr_type((U*)0, (Generator*)0);
    }
};

template <>
struct unwind_helper2<reference_to_pointer_>
{
    template <class Generator, class U>
    static typename Generator::result_type
    execute(U&(*)(), Generator* = 0)
    {
        return unwind_ptr_type(U(0), (Generator*)0);
    }
};
# 151 "/usr/local/include/boost/python/detail/unwind_type.hpp" 3
template <class Generator, class U>
inline typename Generator::result_type

unwind_type(boost::type<U>*, Generator*)



{
    static const int indirection = (is_pointer<U>::value ? pointer_ : 0) + (indirect_traits::is_reference_to_pointer<U>::value ? reference_to_pointer_ : is_lvalue_reference<U>::value ? reference_ : 0)





                                  ;

    return unwind_helper2<indirection>::execute((U(*)())0,(Generator*)0);
}

}}}
# 11 "/usr/local/include/boost/python/converter/pytype_function.hpp" 2 3



namespace boost { namespace python {

namespace converter
{
template <PyTypeObject const* python_type>
struct wrap_pytype
{
    static PyTypeObject const* get_pytype()
    {
        return python_type;
    }
};

typedef PyTypeObject const* (*pytype_function)();





namespace detail
{
struct unwind_type_id_helper{
    typedef python::type_info result_type;
    template <class U>
    static result_type execute(U* ){
        return python::type_id<U>();
    }
};

template <class T>
inline python::type_info unwind_type_id_(boost::type<T>* = 0, mpl::false_ * =0)
{
    return boost::python::detail::unwind_type<unwind_type_id_helper, T> ();
}

inline python::type_info unwind_type_id_(boost::type<void>* = 0, mpl::true_* =0)
{
    return type_id<void>();
}

template <class T>
inline python::type_info unwind_type_id(boost::type<T>* p= 0)
{
    return unwind_type_id_(p, (mpl::bool_<boost::python::detail::is_void<T>::value >*)0 );
}
}


template <class T>
struct expected_pytype_for_arg
{
    static PyTypeObject const *get_pytype()
    {
        const converter::registration *r=converter::registry::query(
            detail::unwind_type_id_((boost::type<T>*)0, (mpl::bool_<boost::python::detail::is_void<T>::value >*)0 )
            );
        return r ? r->expected_from_python_type(): 0;
    }
};


template <class T>
struct registered_pytype
{
    static PyTypeObject const *get_pytype()
    {
        const converter::registration *r=converter::registry::query(
            detail::unwind_type_id_((boost::type<T>*) 0, (mpl::bool_<boost::python::detail::is_void<T>::value >*)0 )
            );
        return r ? r->m_class_object: 0;
    }
};


template <class T>
struct registered_pytype_direct
{
    static PyTypeObject const* get_pytype()
    {
        return registered<T>::converters.m_class_object;
    }
};

template <class T>
struct expected_from_python_type : expected_pytype_for_arg<T>{};

template <class T>
struct expected_from_python_type_direct
{
    static PyTypeObject const* get_pytype()
    {
        return registered<T>::converters.expected_from_python_type();
    }
};

template <class T>
struct to_python_target_type
{
    static PyTypeObject const *get_pytype()
    {
        const converter::registration *r=converter::registry::query(
            detail::unwind_type_id_((boost::type<T>*)0, (mpl::bool_<boost::python::detail::is_void<T>::value >*)0 )
            );
        return r ? r->to_python_target_type(): 0;
    }
};

template <class T>
struct to_python_target_type_direct
{
    static PyTypeObject const *get_pytype()
    {
        return registered<T>::converters.to_python_target_type();
    }
};


}}}
# 17 "/usr/local/include/boost/python/to_python_indirect.hpp" 2 3
# 29 "/usr/local/include/boost/python/to_python_indirect.hpp" 3
namespace boost { namespace python {

template <class T, class MakeHolder>
struct to_python_indirect
{
    template <class U>
    inline PyObject*
    operator()(U const& ref) const
    {
        return this->execute(const_cast<U&>(ref), detail::is_pointer<U>());
    }

    inline PyTypeObject const*
    get_pytype()const
    {
        return converter::registered_pytype<T>::get_pytype();
    }

 private:
    template <class U>
    inline PyObject* execute(U* ptr, detail::true_) const
    {

        if (ptr == 0)
            return python::detail::none();
        else
            return this->execute(*ptr, detail::false_());
    }

    template <class U>
    inline PyObject* execute(U const& x, detail::false_) const
    {
        U* const p = &const_cast<U&>(x);
        if (detail::is_polymorphic<U>::value)
        {
            if (PyObject* o = detail::wrapper_base_::owner(p))
                return incref(o);
        }
        return MakeHolder::execute(p);
    }
};




namespace detail
{
  struct make_owning_holder
  {
      template <class T>
      static PyObject* execute(T* p)
      {
# 89 "/usr/local/include/boost/python/to_python_indirect.hpp" 3
          typedef std::unique_ptr<T> smart_pointer;

          typedef objects::pointer_holder<smart_pointer, T> holder_t;

          smart_pointer ptr(const_cast<T*>(p));
          return objects::make_ptr_instance<T, holder_t>::execute(ptr);
      }
  };

  struct make_reference_holder
  {
      template <class T>
      static PyObject* execute(T* p)
      {
          typedef objects::pointer_holder<T*, T> holder_t;
          T* q = const_cast<T*>(p);
          return objects::make_ptr_instance<T, holder_t>::execute(q);
      }
  };
}

}}
# 11 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3


# 1 "/usr/local/include/boost/python/converter/registered_pointee.hpp" 1 3







# 1 "/usr/local/include/boost/python/converter/pointer_type_id.hpp" 1 3
# 11 "/usr/local/include/boost/python/converter/pointer_type_id.hpp" 3
namespace boost { namespace python { namespace converter {

namespace detail
{
  template <bool is_ref = false>
  struct pointer_typeid_select
  {
      template <class T>
      static inline type_info execute(T*(*)() = 0)
      {
          return type_id<T>();
      }
  };

  template <>
  struct pointer_typeid_select<true>
  {
      template <class T>
      static inline type_info execute(T* const volatile&(*)() = 0)
      {
          return type_id<T>();
      }

      template <class T>
      static inline type_info execute(T*volatile&(*)() = 0)
      {
          return type_id<T>();
      }

      template <class T>
      static inline type_info execute(T*const&(*)() = 0)
      {
          return type_id<T>();
      }

      template <class T>
      static inline type_info execute(T*&(*)() = 0)
      {
          return type_id<T>();
      }
  };
}





template <class T>
type_info pointer_type_id(T(*)() = 0)
{
    return detail::pointer_typeid_select<
          boost::python::detail::is_lvalue_reference<T>::value
        >::execute((T(*)())0);
}

}}}
# 9 "/usr/local/include/boost/python/converter/registered_pointee.hpp" 2 3



namespace boost { namespace python { namespace converter {

struct registration;

template <class T>
struct registered_pointee
    : registered<
        typename boost::python::detail::remove_pointer<
           typename boost::python::detail::remove_cv<
              typename boost::python::detail::remove_reference<T>::type
           >::type
        >::type
    >
{
};
}}}
# 14 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/arg_to_python_base.hpp" 1 3
# 9 "/usr/local/include/boost/python/converter/arg_to_python_base.hpp" 3
namespace boost { namespace python { namespace converter {

struct registration;

namespace detail
{
  struct arg_to_python_base
      : handle<>
  {
      arg_to_python_base(void const volatile* source, registration const&);
  };
}

}}}
# 15 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/shared_ptr_to_python.hpp" 1 3
# 11 "/usr/local/include/boost/python/converter/shared_ptr_to_python.hpp" 3
# 1 "/usr/local/include/boost/python/converter/shared_ptr_deleter.hpp" 1 3







namespace boost { namespace python { namespace converter {

struct shared_ptr_deleter
{
    shared_ptr_deleter(handle<> owner);
    ~shared_ptr_deleter();

    void operator()(void const*);

    handle<> owner;
};

}}}
# 12 "/usr/local/include/boost/python/converter/shared_ptr_to_python.hpp" 2 3
# 1 "/usr/local/include/boost/shared_ptr.hpp" 1 3
# 17 "/usr/local/include/boost/shared_ptr.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 1 3
# 25 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 26 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3
# 1 "/usr/local/include/boost/checked_delete.hpp" 1 3
# 15 "/usr/local/include/boost/checked_delete.hpp" 3
# 1 "/usr/local/include/boost/core/checked_delete.hpp" 1 3
# 26 "/usr/local/include/boost/core/checked_delete.hpp" 3
namespace boost
{



template<class T> inline void checked_delete(T * x) noexcept
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x) noexcept
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const noexcept
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const noexcept
    {
        boost::checked_array_delete(x);
    }
};

}
# 16 "/usr/local/include/boost/checked_delete.hpp" 2 3
# 27 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3

# 1 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 1 3
# 28 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/bad_weak_ptr.hpp" 1 3
# 27 "/usr/local/include/boost/smart_ptr/bad_weak_ptr.hpp" 3
namespace boost
{
# 46 "/usr/local/include/boost/smart_ptr/bad_weak_ptr.hpp" 3
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const noexcept
    {
        return "tr1::bad_weak_ptr";
    }
};
# 64 "/usr/local/include/boost/smart_ptr/bad_weak_ptr.hpp" 3
}
# 29 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 2 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base.hpp" 1 3
# 21 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_has_sync.hpp" 1 3
# 22 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2 3
# 48 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp" 1 3
# 18 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp" 3
# 1 "/usr/local/include/boost/detail/sp_typeinfo.hpp" 1 3
# 20 "/usr/local/include/boost/detail/sp_typeinfo.hpp" 3
# 1 "/usr/local/include/boost/core/typeinfo.hpp" 1 3
# 138 "/usr/local/include/boost/core/typeinfo.hpp" 3
namespace boost
{

namespace core
{







typedef std::type_info typeinfo;



inline std::string demangled_name( core::typeinfo const & ti )
{
    return core::demangle( ti.name() );
}

}

}
# 21 "/usr/local/include/boost/detail/sp_typeinfo.hpp" 2 3

namespace boost
{

namespace detail
{

typedef boost::core::typeinfo sp_typeinfo;

}

}
# 19 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp" 2 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_noexcept.hpp" 1 3
# 20 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp" 2 3

# 1 "/usr/include/c++/7/atomic" 1 3
# 35 "/usr/include/c++/7/atomic" 3
       
# 36 "/usr/include/c++/7/atomic" 3
# 44 "/usr/include/c++/7/atomic" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/7/atomic" 3
  template<typename _Tp>
    struct atomic;



  template<>
  struct atomic<bool>
  {
  private:
    __atomic_base<bool> _M_base;

  public:
    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;

    constexpr atomic(bool __i) noexcept : _M_base(__i) { }

    bool
    operator=(bool __i) noexcept
    { return _M_base.operator=(__i); }

    bool
    operator=(bool __i) volatile noexcept
    { return _M_base.operator=(__i); }

    operator bool() const noexcept
    { return _M_base.load(); }

    operator bool() const volatile noexcept
    { return _M_base.load(); }

    bool
    is_lock_free() const noexcept { return _M_base.is_lock_free(); }

    bool
    is_lock_free() const volatile noexcept { return _M_base.is_lock_free(); }





    void
    store(bool __i, memory_order __m = memory_order_seq_cst) noexcept
    { _M_base.store(__i, __m); }

    void
    store(bool __i, memory_order __m = memory_order_seq_cst) volatile noexcept
    { _M_base.store(__i, __m); }

    bool
    load(memory_order __m = memory_order_seq_cst) const noexcept
    { return _M_base.load(__m); }

    bool
    load(memory_order __m = memory_order_seq_cst) const volatile noexcept
    { return _M_base.load(__m); }

    bool
    exchange(bool __i, memory_order __m = memory_order_seq_cst) noexcept
    { return _M_base.exchange(__i, __m); }

    bool
    exchange(bool __i,
      memory_order __m = memory_order_seq_cst) volatile noexcept
    { return _M_base.exchange(__i, __m); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
     memory_order __m2) noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
     memory_order __m2) volatile noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2,
     memory_order __m = memory_order_seq_cst) noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2,
       memory_order __m = memory_order_seq_cst) volatile noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
       memory_order __m2) noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
       memory_order __m2) volatile noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2,
       memory_order __m = memory_order_seq_cst) noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2,
      memory_order __m = memory_order_seq_cst) volatile noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
  };







  template<typename _Tp>
    struct atomic
    {
    private:

      static constexpr int _S_min_alignment
 = (sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16
 ? 0 : sizeof(_Tp);

      static constexpr int _S_alignment
        = _S_min_alignment > alignof(_Tp) ? _S_min_alignment : alignof(_Tp);

      alignas(_S_alignment) _Tp _M_i;

      static_assert(__is_trivially_copyable(_Tp),
      "std::atomic requires a trivially copyable type");

      static_assert(sizeof(_Tp) > 0,
      "Incomplete or zero-sized types are not supported");

    public:
      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }

      operator _Tp() const noexcept
      { return load(); }

      operator _Tp() const volatile noexcept
      { return load(); }

      _Tp
      operator=(_Tp __i) noexcept
      { store(__i); return __i; }

      _Tp
      operator=(_Tp __i) volatile noexcept
      { store(__i); return __i; }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }






      void
      store(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept
      { __atomic_store(std::__addressof(_M_i), std::__addressof(__i), __m); }

      void
      store(_Tp __i, memory_order __m = memory_order_seq_cst) volatile noexcept
      { __atomic_store(std::__addressof(_M_i), std::__addressof(__i), __m); }

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_load(std::__addressof(_M_i), __ptr, __m);
 return *__ptr;
      }

      _Tp
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_load(std::__addressof(_M_i), __ptr, __m);
 return *__ptr;
      }

      _Tp
      exchange(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),
     __ptr, __m);
 return *__ptr;
      }

      _Tp
      exchange(_Tp __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),
     __ptr, __m);
 return *__ptr;
      }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
       memory_order __f) noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      true, __s, __f);
      }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
       memory_order __f) volatile noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      true, __s, __f);
      }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i,
       memory_order __m = memory_order_seq_cst) noexcept
      { return compare_exchange_weak(__e, __i, __m,
                                     __cmpexch_failure_order(__m)); }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i,
       memory_order __m = memory_order_seq_cst) volatile noexcept
      { return compare_exchange_weak(__e, __i, __m,
                                     __cmpexch_failure_order(__m)); }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
         memory_order __f) noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      false, __s, __f);
      }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
         memory_order __f) volatile noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      false, __s, __f);
      }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i,
          memory_order __m = memory_order_seq_cst) noexcept
      { return compare_exchange_strong(__e, __i, __m,
                                       __cmpexch_failure_order(__m)); }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i,
       memory_order __m = memory_order_seq_cst) volatile noexcept
      { return compare_exchange_strong(__e, __i, __m,
                                       __cmpexch_failure_order(__m)); }
    };



  template<typename _Tp>
    struct atomic<_Tp*>
    {
      typedef _Tp* __pointer_type;
      typedef __atomic_base<_Tp*> __base_type;
      __base_type _M_b;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__pointer_type __p) noexcept : _M_b(__p) { }

      operator __pointer_type() const noexcept
      { return __pointer_type(_M_b); }

      operator __pointer_type() const volatile noexcept
      { return __pointer_type(_M_b); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      { return _M_b.operator=(__p); }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      { return _M_b.operator=(__p); }

      __pointer_type
      operator++(int) noexcept
      { return _M_b++; }

      __pointer_type
      operator++(int) volatile noexcept
      { return _M_b++; }

      __pointer_type
      operator--(int) noexcept
      { return _M_b--; }

      __pointer_type
      operator--(int) volatile noexcept
      { return _M_b--; }

      __pointer_type
      operator++() noexcept
      { return ++_M_b; }

      __pointer_type
      operator++() volatile noexcept
      { return ++_M_b; }

      __pointer_type
      operator--() noexcept
      { return --_M_b; }

      __pointer_type
      operator--() volatile noexcept
      { return --_M_b; }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return _M_b.operator+=(__d); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return _M_b.operator+=(__d); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return _M_b.operator-=(__d); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return _M_b.operator-=(__d); }

      bool
      is_lock_free() const noexcept
      { return _M_b.is_lock_free(); }

      bool
      is_lock_free() const volatile noexcept
      { return _M_b.is_lock_free(); }





      void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.store(__p, __m); }

      void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.store(__p, __m); }

      __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return _M_b.load(__m); }

      __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      { return _M_b.load(__m); }

      __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.exchange(__p, __m); }

      __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.exchange(__p, __m); }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
       memory_order __m1, memory_order __m2) noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
      memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1, memory_order __m2) noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return _M_b.compare_exchange_strong(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
      memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return _M_b.compare_exchange_strong(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.fetch_add(__d, __m); }

      __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.fetch_add(__d, __m); }

      __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.fetch_sub(__d, __m); }

      __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.fetch_sub(__d, __m); }
    };



  template<>
    struct atomic<char> : __atomic_base<char>
    {
      typedef char __integral_type;
      typedef __atomic_base<char> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<signed char> : __atomic_base<signed char>
    {
      typedef signed char __integral_type;
      typedef __atomic_base<signed char> __base_type;

      atomic() noexcept= default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<unsigned char> : __atomic_base<unsigned char>
    {
      typedef unsigned char __integral_type;
      typedef __atomic_base<unsigned char> __base_type;

      atomic() noexcept= default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<short> : __atomic_base<short>
    {
      typedef short __integral_type;
      typedef __atomic_base<short> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<unsigned short> : __atomic_base<unsigned short>
    {
      typedef unsigned short __integral_type;
      typedef __atomic_base<unsigned short> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<int> : __atomic_base<int>
    {
      typedef int __integral_type;
      typedef __atomic_base<int> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<unsigned int> : __atomic_base<unsigned int>
    {
      typedef unsigned int __integral_type;
      typedef __atomic_base<unsigned int> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<long> : __atomic_base<long>
    {
      typedef long __integral_type;
      typedef __atomic_base<long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<unsigned long> : __atomic_base<unsigned long>
    {
      typedef unsigned long __integral_type;
      typedef __atomic_base<unsigned long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<long long> : __atomic_base<long long>
    {
      typedef long long __integral_type;
      typedef __atomic_base<long long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<unsigned long long> : __atomic_base<unsigned long long>
    {
      typedef unsigned long long __integral_type;
      typedef __atomic_base<unsigned long long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<wchar_t> : __atomic_base<wchar_t>
    {
      typedef wchar_t __integral_type;
      typedef __atomic_base<wchar_t> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<char16_t> : __atomic_base<char16_t>
    {
      typedef char16_t __integral_type;
      typedef __atomic_base<char16_t> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };


  template<>
    struct atomic<char32_t> : __atomic_base<char32_t>
    {
      typedef char32_t __integral_type;
      typedef __atomic_base<char32_t> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;




    };



  typedef atomic<bool> atomic_bool;


  typedef atomic<char> atomic_char;


  typedef atomic<signed char> atomic_schar;


  typedef atomic<unsigned char> atomic_uchar;


  typedef atomic<short> atomic_short;


  typedef atomic<unsigned short> atomic_ushort;


  typedef atomic<int> atomic_int;


  typedef atomic<unsigned int> atomic_uint;


  typedef atomic<long> atomic_long;


  typedef atomic<unsigned long> atomic_ulong;


  typedef atomic<long long> atomic_llong;


  typedef atomic<unsigned long long> atomic_ullong;


  typedef atomic<wchar_t> atomic_wchar_t;


  typedef atomic<char16_t> atomic_char16_t;


  typedef atomic<char32_t> atomic_char32_t;






  typedef atomic<int8_t> atomic_int8_t;


  typedef atomic<uint8_t> atomic_uint8_t;


  typedef atomic<int16_t> atomic_int16_t;


  typedef atomic<uint16_t> atomic_uint16_t;


  typedef atomic<int32_t> atomic_int32_t;


  typedef atomic<uint32_t> atomic_uint32_t;


  typedef atomic<int64_t> atomic_int64_t;


  typedef atomic<uint64_t> atomic_uint64_t;



  typedef atomic<int_least8_t> atomic_int_least8_t;


  typedef atomic<uint_least8_t> atomic_uint_least8_t;


  typedef atomic<int_least16_t> atomic_int_least16_t;


  typedef atomic<uint_least16_t> atomic_uint_least16_t;


  typedef atomic<int_least32_t> atomic_int_least32_t;


  typedef atomic<uint_least32_t> atomic_uint_least32_t;


  typedef atomic<int_least64_t> atomic_int_least64_t;


  typedef atomic<uint_least64_t> atomic_uint_least64_t;



  typedef atomic<int_fast8_t> atomic_int_fast8_t;


  typedef atomic<uint_fast8_t> atomic_uint_fast8_t;


  typedef atomic<int_fast16_t> atomic_int_fast16_t;


  typedef atomic<uint_fast16_t> atomic_uint_fast16_t;


  typedef atomic<int_fast32_t> atomic_int_fast32_t;


  typedef atomic<uint_fast32_t> atomic_uint_fast32_t;


  typedef atomic<int_fast64_t> atomic_int_fast64_t;


  typedef atomic<uint_fast64_t> atomic_uint_fast64_t;



  typedef atomic<intptr_t> atomic_intptr_t;


  typedef atomic<uintptr_t> atomic_uintptr_t;


  typedef atomic<size_t> atomic_size_t;


  typedef atomic<intmax_t> atomic_intmax_t;


  typedef atomic<uintmax_t> atomic_uintmax_t;


  typedef atomic<ptrdiff_t> atomic_ptrdiff_t;



  inline bool
  atomic_flag_test_and_set_explicit(atomic_flag* __a,
        memory_order __m) noexcept
  { return __a->test_and_set(__m); }

  inline bool
  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a,
        memory_order __m) noexcept
  { return __a->test_and_set(__m); }

  inline void
  atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m) noexcept
  { __a->clear(__m); }

  inline void
  atomic_flag_clear_explicit(volatile atomic_flag* __a,
        memory_order __m) noexcept
  { __a->clear(__m); }

  inline bool
  atomic_flag_test_and_set(atomic_flag* __a) noexcept
  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }

  inline bool
  atomic_flag_test_and_set(volatile atomic_flag* __a) noexcept
  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }

  inline void
  atomic_flag_clear(atomic_flag* __a) noexcept
  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }

  inline void
  atomic_flag_clear(volatile atomic_flag* __a) noexcept
  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }



  template<typename _ITp>
    inline bool
    atomic_is_lock_free(const atomic<_ITp>* __a) noexcept
    { return __a->is_lock_free(); }

  template<typename _ITp>
    inline bool
    atomic_is_lock_free(const volatile atomic<_ITp>* __a) noexcept
    { return __a->is_lock_free(); }

  template<typename _ITp>
    inline void
    atomic_init(atomic<_ITp>* __a, _ITp __i) noexcept
    { __a->store(__i, memory_order_relaxed); }

  template<typename _ITp>
    inline void
    atomic_init(volatile atomic<_ITp>* __a, _ITp __i) noexcept
    { __a->store(__i, memory_order_relaxed); }

  template<typename _ITp>
    inline void
    atomic_store_explicit(atomic<_ITp>* __a, _ITp __i,
     memory_order __m) noexcept
    { __a->store(__i, __m); }

  template<typename _ITp>
    inline void
    atomic_store_explicit(volatile atomic<_ITp>* __a, _ITp __i,
     memory_order __m) noexcept
    { __a->store(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_load_explicit(const atomic<_ITp>* __a, memory_order __m) noexcept
    { return __a->load(__m); }

  template<typename _ITp>
    inline _ITp
    atomic_load_explicit(const volatile atomic<_ITp>* __a,
    memory_order __m) noexcept
    { return __a->load(__m); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange_explicit(atomic<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->exchange(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange_explicit(volatile atomic<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->exchange(__i, __m); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak_explicit(atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2,
       memory_order __m1,
       memory_order __m2) noexcept
    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak_explicit(volatile atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2,
       memory_order __m1,
       memory_order __m2) noexcept
    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong_explicit(atomic<_ITp>* __a,
         _ITp* __i1, _ITp __i2,
         memory_order __m1,
         memory_order __m2) noexcept
    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong_explicit(volatile atomic<_ITp>* __a,
         _ITp* __i1, _ITp __i2,
         memory_order __m1,
         memory_order __m2) noexcept
    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }


  template<typename _ITp>
    inline void
    atomic_store(atomic<_ITp>* __a, _ITp __i) noexcept
    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline void
    atomic_store(volatile atomic<_ITp>* __a, _ITp __i) noexcept
    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_load(const atomic<_ITp>* __a) noexcept
    { return atomic_load_explicit(__a, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_load(const volatile atomic<_ITp>* __a) noexcept
    { return atomic_load_explicit(__a, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange(atomic<_ITp>* __a, _ITp __i) noexcept
    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange(volatile atomic<_ITp>* __a, _ITp __i) noexcept
    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak(atomic<_ITp>* __a,
     _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
         memory_order_seq_cst,
         memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak(volatile atomic<_ITp>* __a,
     _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
         memory_order_seq_cst,
         memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong(atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
           memory_order_seq_cst,
           memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong(volatile atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
           memory_order_seq_cst,
           memory_order_seq_cst);
    }





  template<typename _ITp>
    inline _ITp
    atomic_fetch_add_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_add(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_add(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_sub(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_sub(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_and(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_and(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or_explicit(__atomic_base<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->fetch_or(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->fetch_or(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_xor(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_xor(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }



  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
         memory_order __m) noexcept
    { return __a->fetch_add(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add_explicit(volatile atomic<_ITp*>* __a, ptrdiff_t __d,
         memory_order __m) noexcept
    { return __a->fetch_add(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_add(__d); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_add(__d); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub_explicit(volatile atomic<_ITp*>* __a,
         ptrdiff_t __d, memory_order __m) noexcept
    { return __a->fetch_sub(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
         memory_order __m) noexcept
    { return __a->fetch_sub(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_sub(__d); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_sub(__d); }



}
# 22 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp" 2 3


namespace boost
{

namespace detail
{

inline void atomic_increment( std::atomic_int_least32_t * pw ) noexcept
{
    pw->fetch_add( 1, std::memory_order_relaxed );
}

inline std::int_least32_t atomic_decrement( std::atomic_int_least32_t * pw ) noexcept
{
    return pw->fetch_sub( 1, std::memory_order_acq_rel );
}

inline std::int_least32_t atomic_conditional_increment( std::atomic_int_least32_t * pw ) noexcept
{




    std::int_least32_t r = pw->load( std::memory_order_relaxed );

    for( ;; )
    {
        if( r == 0 )
        {
            return r;
        }

        if( pw->compare_exchange_weak( r, r + 1, std::memory_order_relaxed, std::memory_order_relaxed ) )
        {
            return r;
        }
    }
}

class __attribute__((__visibility__("default"))) sp_counted_base
{
private:

    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );

    std::atomic_int_least32_t use_count_;
    std::atomic_int_least32_t weak_count_;

public:

    sp_counted_base() noexcept: use_count_( 1 ), weak_count_( 1 )
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() noexcept = 0;



    virtual void destroy() noexcept
    {
        delete this;
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) noexcept = 0;
    virtual void * get_local_deleter( sp_typeinfo const & ti ) noexcept = 0;
    virtual void * get_untyped_deleter() noexcept = 0;

    void add_ref_copy() noexcept
    {
        atomic_increment( &use_count_ );
    }

    bool add_ref_lock() noexcept
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }

    void release() noexcept
    {
        if( atomic_decrement( &use_count_ ) == 1 )
        {
            dispose();
            weak_release();
        }
    }

    void weak_add_ref() noexcept
    {
        atomic_increment( &weak_count_ );
    }

    void weak_release() noexcept
    {
        if( atomic_decrement( &weak_count_ ) == 1 )
        {
            destroy();
        }
    }

    long use_count() const noexcept
    {
        return use_count_.load( std::memory_order_acquire );
    }
};

}

}
# 49 "/usr/local/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2 3
# 30 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 2 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 1 3
# 42 "/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3
namespace boost
{
# 52 "/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3
namespace detail
{



template<class D> class local_sp_deleter;

template<class D> D * get_local_deleter( D * ) noexcept
{
    return 0;
}

template<class D> D * get_local_deleter( local_sp_deleter<D> * p ) noexcept;



template<class X> class __attribute__((__visibility__("default"))) sp_counted_impl_p: public sp_counted_base
{
private:

    X * px_;

    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );

    typedef sp_counted_impl_p<X> this_type;

public:

    explicit sp_counted_impl_p( X * px ): px_( px )
    {



    }

    virtual void dispose() noexcept
    {



        boost::checked_delete( px_ );
    }

    virtual void * get_deleter( sp_typeinfo const & ) noexcept
    {
        return 0;
    }

    virtual void * get_local_deleter( sp_typeinfo const & ) noexcept
    {
        return 0;
    }

    virtual void * get_untyped_deleter() noexcept
    {
        return 0;
    }
# 138 "/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3
};
# 147 "/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3
template<class P, class D> class __attribute__((__visibility__("default"))) sp_counted_impl_pd: public sp_counted_base
{
private:

    P ptr;
    D del;

    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );

    typedef sp_counted_impl_pd<P, D> this_type;

public:



    sp_counted_impl_pd( P p, D & d ): ptr( p ), del( d )
    {
    }

    sp_counted_impl_pd( P p ): ptr( p ), del()
    {
    }

    virtual void dispose() noexcept
    {
        del( ptr );
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) noexcept
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }

    virtual void * get_local_deleter( sp_typeinfo const & ti ) noexcept
    {
        return ti == typeid(D)? boost::detail::get_local_deleter( boost::addressof( del ) ): 0;
    }

    virtual void * get_untyped_deleter() noexcept
    {
        return &reinterpret_cast<char&>( del );
    }
# 218 "/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3
};

template<class P, class D, class A> class __attribute__((__visibility__("default"))) sp_counted_impl_pda: public sp_counted_base
{
private:

    P p_;
    D d_;
    A a_;

    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );

    typedef sp_counted_impl_pda<P, D, A> this_type;

public:



    sp_counted_impl_pda( P p, D & d, A a ): p_( p ), d_( d ), a_( a )
    {
    }

    sp_counted_impl_pda( P p, A a ): p_( p ), d_( a ), a_( a )
    {
    }

    virtual void dispose() noexcept
    {
        d_( p_ );
    }

    virtual void destroy() noexcept
    {


        typedef typename std::allocator_traits<A>::template rebind_alloc< this_type > A2;







        A2 a2( a_ );

        this->~this_type();

        a2.deallocate( this, 1 );
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) noexcept
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }

    virtual void * get_local_deleter( sp_typeinfo const & ti ) noexcept
    {
        return ti == typeid(D)? boost::detail::get_local_deleter( boost::addressof( d_ ) ): 0;
    }

    virtual void * get_untyped_deleter() noexcept
    {
        return &reinterpret_cast<char&>( d_ );
    }
};





}

}
# 31 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 2 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_disable_deprecated.hpp" 1 3
# 32 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 2 3
# 48 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


namespace boost
{

namespace movelib
{

template< class T, class D > class unique_ptr;

}

namespace detail
{
# 72 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
struct sp_nothrow_tag {};

template< class D > struct sp_inplace_tag
{
};

template< class T > class sp_reference_wrapper
{
public:

    explicit sp_reference_wrapper( T & t): t_( boost::addressof( t ) )
    {
    }

    template< class Y > void operator()( Y * p ) const
    {
        (*t_)( p );
    }

private:

    T * t_;
};

template< class D > struct sp_convert_reference
{
    typedef D type;
};

template< class D > struct sp_convert_reference< D& >
{
    typedef sp_reference_wrapper< D > type;
};

class weak_count;

class shared_count
{
private:

    sp_counted_base * pi_;





    friend class weak_count;

public:

    constexpr shared_count() noexcept: pi_(0)



    {
    }

    constexpr explicit shared_count( sp_counted_base * pi ) noexcept: pi_( pi )



    {
    }

    template<class Y> explicit shared_count( Y * p ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
# 164 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
    }




    template<class P, class D> shared_count( P p, D d ): pi_(0)




    {





        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 201 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
    }



    template< class P, class D > shared_count( P p, sp_inplace_tag<D> ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_pd< P, D >( p );
        }
        catch( ... )
        {
            D::operator_fn( p );
            throw;
        }
# 233 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
    }



    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;



        typedef typename std::allocator_traits<A>::template rebind_alloc< impl_type > A2;







        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1 );
            ::new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 290 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
    }



    template< class P, class D, class A > shared_count( P p, sp_inplace_tag< D >, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda< P, D, A > impl_type;



        typedef typename std::allocator_traits<A>::template rebind_alloc< impl_type > A2;







        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1 );
            ::new( static_cast< void* >( pi_ ) ) impl_type( p, a );
        }
        catch(...)
        {
            D::operator_fn( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 347 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
    }







    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )



    {
# 370 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
        r.release();
    }





    template<class Y, class D>
    explicit shared_count( std::unique_ptr<Y, D> & r ): pi_( 0 )



    {
        typedef typename sp_convert_reference<D>::type D2;

        D2 d2( r.get_deleter() );
        pi_ = new sp_counted_impl_pd< typename std::unique_ptr<Y, D>::pointer, D2 >( r.get(), d2 );
# 397 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
        r.release();
    }



    template<class Y, class D>
    explicit shared_count( boost::movelib::unique_ptr<Y, D> & r ): pi_( 0 )



    {
        typedef typename sp_convert_reference<D>::type D2;

        D2 d2( r.get_deleter() );
        pi_ = new sp_counted_impl_pd< typename boost::movelib::unique_ptr<Y, D>::pointer, D2 >( r.get(), d2 );
# 422 "/usr/local/include/boost/smart_ptr/detail/shared_count.hpp" 3
        r.release();
    }

    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();



    }

    shared_count(shared_count const & r) noexcept: pi_(r.pi_)



    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }



    shared_count(shared_count && r) noexcept: pi_(r.pi_)



    {
        r.pi_ = 0;
    }



    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag ) noexcept;

    shared_count & operator= (shared_count const & r) noexcept
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r) noexcept
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const noexcept
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const noexcept
    {
        return use_count() == 1;
    }

    bool empty() const noexcept
    {
        return pi_ == 0;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b) noexcept
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b) noexcept
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }

    void * get_deleter( sp_typeinfo const & ti ) const noexcept
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }

    void * get_local_deleter( sp_typeinfo const & ti ) const noexcept
    {
        return pi_? pi_->get_local_deleter( ti ): 0;
    }

    void * get_untyped_deleter() const noexcept
    {
        return pi_? pi_->get_untyped_deleter(): 0;
    }
};


class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    constexpr weak_count() noexcept: pi_(0)



    {
    }

    weak_count(shared_count const & r) noexcept: pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r) noexcept: pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }





    weak_count(weak_count && r) noexcept: pi_(r.pi_)



    {
        r.pi_ = 0;
    }



    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r) noexcept
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    weak_count & operator= (weak_count const & r) noexcept
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(weak_count & r) noexcept
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const noexcept
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool empty() const noexcept
    {
        return pi_ == 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b) noexcept
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b) noexcept
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )



{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}

inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ) noexcept: pi_( r.pi_ )



{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}

}

}


#pragma GCC diagnostic pop
# 29 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3

# 1 "/usr/local/include/boost/smart_ptr/detail/sp_convertible.hpp" 1 3
# 35 "/usr/local/include/boost/smart_ptr/detail/sp_convertible.hpp" 3
namespace boost
{

namespace detail
{

template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];

    static yes f( T* );
    static no f( ... );

    enum _vt { value = sizeof( (f)( static_cast<Y*>(0) ) ) == sizeof(yes) };
};

template< class Y, class T > struct sp_convertible< Y, T[] >
{
    enum _vt { value = false };
};

template< class Y, class T > struct sp_convertible< Y[], T[] >
{
    enum _vt { value = sp_convertible< Y[1], T[1] >::value };
};

template< class Y, std::size_t N, class T > struct sp_convertible< Y[N], T[] >
{
    enum _vt { value = sp_convertible< Y[1], T[1] >::value };
};

struct sp_empty
{
};

template< bool > struct sp_enable_if_convertible_impl;

template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};

template<> struct sp_enable_if_convertible_impl<false>
{
};

template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};

}

}
# 31 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3
# 1 "/usr/local/include/boost/smart_ptr/detail/sp_nullptr_t.hpp" 1 3
# 23 "/usr/local/include/boost/smart_ptr/detail/sp_nullptr_t.hpp" 3
namespace boost
{

namespace detail
{







    typedef std::nullptr_t sp_nullptr_t;



}

}
# 32 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3




# 1 "/usr/local/include/boost/smart_ptr/detail/spinlock_pool.hpp" 1 3
# 25 "/usr/local/include/boost/smart_ptr/detail/spinlock_pool.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/detail/spinlock.hpp" 1 3
# 47 "/usr/local/include/boost/smart_ptr/detail/spinlock.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/detail/spinlock_std_atomic.hpp" 1 3
# 18 "/usr/local/include/boost/smart_ptr/detail/spinlock_std_atomic.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/detail/yield_k.hpp" 1 3
# 28 "/usr/local/include/boost/smart_ptr/detail/yield_k.hpp" 3
# 1 "/usr/local/include/boost/predef/platform/windows_runtime.h" 1 3
# 12 "/usr/local/include/boost/predef/platform/windows_runtime.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3






# 1 "/usr/local/include/boost/predef/detail/test.h" 1 3
# 8 "/usr/local/include/boost/predef/make.h" 2 3
# 13 "/usr/local/include/boost/predef/platform/windows_runtime.h" 2 3
# 1 "/usr/local/include/boost/predef/os/windows.h" 1 3
# 11 "/usr/local/include/boost/predef/os/windows.h" 3
# 1 "/usr/local/include/boost/predef/version_number.h" 1 3
# 12 "/usr/local/include/boost/predef/os/windows.h" 2 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/os/windows.h" 2 3
# 51 "/usr/local/include/boost/predef/os/windows.h" 3

# 14 "/usr/local/include/boost/predef/platform/windows_runtime.h" 2 3
# 1 "/usr/local/include/boost/predef/platform/windows_phone.h" 1 3
# 12 "/usr/local/include/boost/predef/platform/windows_phone.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/platform/windows_phone.h" 2 3
# 1 "/usr/local/include/boost/predef/os/windows.h" 1 3
# 51 "/usr/local/include/boost/predef/os/windows.h" 3

# 14 "/usr/local/include/boost/predef/platform/windows_phone.h" 2 3
# 1 "/usr/local/include/boost/predef/platform/windows_uwp.h" 1 3
# 11 "/usr/local/include/boost/predef/platform/windows_uwp.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 12 "/usr/local/include/boost/predef/platform/windows_uwp.h" 2 3
# 1 "/usr/local/include/boost/predef/os/windows.h" 1 3
# 51 "/usr/local/include/boost/predef/os/windows.h" 3

# 13 "/usr/local/include/boost/predef/platform/windows_uwp.h" 2 3
# 60 "/usr/local/include/boost/predef/platform/windows_uwp.h" 3

# 15 "/usr/local/include/boost/predef/platform/windows_phone.h" 2 3
# 48 "/usr/local/include/boost/predef/platform/windows_phone.h" 3

# 15 "/usr/local/include/boost/predef/platform/windows_runtime.h" 2 3
# 1 "/usr/local/include/boost/predef/platform/windows_store.h" 1 3
# 12 "/usr/local/include/boost/predef/platform/windows_store.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/platform/windows_store.h" 2 3
# 1 "/usr/local/include/boost/predef/os/windows.h" 1 3
# 51 "/usr/local/include/boost/predef/os/windows.h" 3

# 14 "/usr/local/include/boost/predef/platform/windows_store.h" 2 3
# 1 "/usr/local/include/boost/predef/platform/windows_uwp.h" 1 3
# 60 "/usr/local/include/boost/predef/platform/windows_uwp.h" 3

# 15 "/usr/local/include/boost/predef/platform/windows_store.h" 2 3
# 50 "/usr/local/include/boost/predef/platform/windows_store.h" 3

# 16 "/usr/local/include/boost/predef/platform/windows_runtime.h" 2 3
# 53 "/usr/local/include/boost/predef/platform/windows_runtime.h" 3

# 29 "/usr/local/include/boost/smart_ptr/detail/yield_k.hpp" 2 3
# 125 "/usr/local/include/boost/smart_ptr/detail/yield_k.hpp" 3
namespace boost
{

namespace detail
{

inline void yield( unsigned k )
{
    if( k < 4 )
    {
    }

    else if( k < 16 )
    {
        __asm__ __volatile__( "rep; nop" : : : "memory" );
    }

    else if( k < 32 || k & 1 )
    {
        sched_yield();
    }
    else
    {

        struct timespec rqtp = { 0, 0 };




        rqtp.tv_sec = 0;
        rqtp.tv_nsec = 1000;

        nanosleep( &rqtp, 0 );
    }
}

}

}
# 19 "/usr/local/include/boost/smart_ptr/detail/spinlock_std_atomic.hpp" 2 3



namespace boost
{

namespace detail
{

class spinlock
{
public:

    std::atomic_flag v_;

public:

    bool try_lock() noexcept
    {
        return !v_.test_and_set( std::memory_order_acquire );
    }

    void lock() noexcept
    {
        for( unsigned k = 0; !try_lock(); ++k )
        {
            boost::detail::yield( k );
        }
    }

    void unlock() noexcept
    {
        v_ .clear( std::memory_order_release );
    }

public:

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( spinlock & sp ) noexcept: sp_( sp )
        {
            sp.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

}
}
# 48 "/usr/local/include/boost/smart_ptr/detail/spinlock.hpp" 2 3
# 26 "/usr/local/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2 3


namespace boost
{

namespace detail
{

template< int M > class spinlock_pool
{
private:

    static spinlock pool_[ 41 ];

public:

    static spinlock & spinlock_for( void const * pv )
    {



        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;

        return pool_[ i ];
    }

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

template< int M > spinlock spinlock_pool< M >::pool_[ 41 ] =
{
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } },
    { { 0 } }
};

}
}
# 37 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3
# 53 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


namespace boost
{

template<class T> class shared_ptr;
template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;
class enable_shared_from_raw;

namespace movelib
{

    template< class T, class D > class unique_ptr;

}

namespace detail
{



template< class T > struct sp_element
{
    typedef T type;
};



template< class T > struct sp_element< T[] >
{
    typedef T type;
};



template< class T, std::size_t N > struct sp_element< T[N] >
{
    typedef T type;
};







template< class T > struct sp_dereference
{
    typedef T & type;
};

template<> struct sp_dereference< void >
{
    typedef void type;
};



template<> struct sp_dereference< void const >
{
    typedef void type;
};

template<> struct sp_dereference< void volatile >
{
    typedef void type;
};

template<> struct sp_dereference< void const volatile >
{
    typedef void type;
};





template< class T > struct sp_dereference< T[] >
{
    typedef void type;
};



template< class T, std::size_t N > struct sp_dereference< T[N] >
{
    typedef void type;
};







template< class T > struct sp_member_access
{
    typedef T * type;
};



template< class T > struct sp_member_access< T[] >
{
    typedef void type;
};



template< class T, std::size_t N > struct sp_member_access< T[N] >
{
    typedef void type;
};







template< class T > struct sp_array_access
{
    typedef void type;
};



template< class T > struct sp_array_access< T[] >
{
    typedef T & type;
};



template< class T, std::size_t N > struct sp_array_access< T[N] >
{
    typedef T & type;
};







template< class T > struct sp_extent
{
    enum _vt { value = 0 };
};



template< class T, std::size_t N > struct sp_extent< T[N] >
{
    enum _vt { value = N };
};





template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}

template< class X, class Y > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_raw const * pe );
# 242 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
inline void sp_enable_shared_from_this( ... )
{
}







template< class T, class R > struct sp_enable_if_auto_ptr
{
};

template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};





template< class Y, class T > inline void sp_assert_convertible() noexcept
{



    typedef char tmp[ sp_convertible< Y, T >::value? 1: -1 ];
    (void)sizeof( tmp );







}



template< class T, class Y > inline void sp_pointer_construct( boost::shared_ptr< T > * ppx, Y * p, boost::detail::shared_count & pn )
{
    boost::detail::shared_count( p ).swap( pn );
    boost::detail::sp_enable_shared_from_this( ppx, p, p );
}



template< class T, class Y > inline void sp_pointer_construct( boost::shared_ptr< T[] > * , Y * p, boost::detail::shared_count & pn )
{
    sp_assert_convertible< Y[], T[] >();
    boost::detail::shared_count( p, boost::checked_array_deleter< T >() ).swap( pn );
}

template< class T, std::size_t N, class Y > inline void sp_pointer_construct( boost::shared_ptr< T[N] > * , Y * p, boost::detail::shared_count & pn )
{
    sp_assert_convertible< Y[N], T[N] >();
    boost::detail::shared_count( p, boost::checked_array_deleter< T >() ).swap( pn );
}





template< class T, class Y > inline void sp_deleter_construct( boost::shared_ptr< T > * ppx, Y * p )
{
    boost::detail::sp_enable_shared_from_this( ppx, p, p );
}



template< class T, class Y > inline void sp_deleter_construct( boost::shared_ptr< T[] > * , Y * )
{
    sp_assert_convertible< Y[], T[] >();
}

template< class T, std::size_t N, class Y > inline void sp_deleter_construct( boost::shared_ptr< T[N] > * , Y * )
{
    sp_assert_convertible< Y[N], T[N] >();
}



struct sp_internal_constructor_tag
{
};

}
# 341 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
template<class T> class shared_ptr
{
private:


    typedef shared_ptr<T> this_type;

public:

    typedef typename boost::detail::sp_element< T >::type element_type;

    constexpr shared_ptr() noexcept : px( 0 ), pn()
    {
    }



    constexpr shared_ptr( boost::detail::sp_nullptr_t ) noexcept : px( 0 ), pn()
    {
    }



    constexpr shared_ptr( boost::detail::sp_internal_constructor_tag, element_type * px_, boost::detail::shared_count const & pn_ ) noexcept : px( px_ ), pn( pn_ )
    {
    }



    constexpr shared_ptr( boost::detail::sp_internal_constructor_tag, element_type * px_, boost::detail::shared_count && pn_ ) noexcept : px( px_ ), pn( std::move( pn_ ) )
    {
    }



    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn()
    {
        boost::detail::sp_pointer_construct( this, p, pn );
    }







    template<class Y, class D> shared_ptr( Y * p, D d ): px( p ), pn( p, d )
    {
        boost::detail::sp_deleter_construct( this, p );
    }



    template<class D> shared_ptr( boost::detail::sp_nullptr_t p, D d ): px( p ), pn( p, d )
    {
    }





    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_deleter_construct( this, p );
    }



    template<class D, class A> shared_ptr( boost::detail::sp_nullptr_t p, D d, A a ): px( p ), pn( p, d, a )
    {
    }
# 422 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
    shared_ptr( shared_ptr const & r ) noexcept : px( r.px ), pn( r.pn )
    {
    }



    template<class Y>
    explicit shared_ptr( weak_ptr<Y> const & r ): pn( r.pn )
    {
        boost::detail::sp_assert_convertible< Y, T >();


        px = r.px;
    }

    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag )
    noexcept : px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    noexcept : px( r.px ), pn( r.pn )
    {
        boost::detail::sp_assert_convertible< Y, T >();
    }


    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, element_type * p ) noexcept : px( p ), pn( r.pn )
    {
    }



    template<class Y>
    explicit shared_ptr( std::auto_ptr<Y> & r ): px(r.get()), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        Y * tmp = r.get();
        pn = boost::detail::shared_count( r );

        boost::detail::sp_deleter_construct( this, tmp );
    }



    template<class Y>
    shared_ptr( std::auto_ptr<Y> && r ): px(r.get()), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        Y * tmp = r.get();
        pn = boost::detail::shared_count( r );

        boost::detail::sp_deleter_construct( this, tmp );
    }
# 515 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
    template< class Y, class D >
    shared_ptr( std::unique_ptr< Y, D > && r ): px( r.get() ), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        typename std::unique_ptr< Y, D >::pointer tmp = r.get();

        if( tmp != 0 )
        {
            pn = boost::detail::shared_count( r );
            boost::detail::sp_deleter_construct( this, tmp );
        }
    }



    template< class Y, class D >
    shared_ptr( boost::movelib::unique_ptr< Y, D > r ): px( r.get() ), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        typename boost::movelib::unique_ptr< Y, D >::pointer tmp = r.get();

        if( tmp != 0 )
        {
            pn = boost::detail::shared_count( r );
            boost::detail::sp_deleter_construct( this, tmp );
        }
    }



    shared_ptr & operator=( shared_ptr const & r ) noexcept
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r) noexcept
    {
        this_type(r).swap(*this);
        return *this;
    }





    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type( r ).swap( *this );
        return *this;
    }



    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> && r )
    {
        this_type( static_cast< std::auto_ptr<Y> && >( r ) ).swap( *this );
        return *this;
    }
# 597 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
    template<class Y, class D>
    shared_ptr & operator=( std::unique_ptr<Y, D> && r )
    {
        this_type( static_cast< std::unique_ptr<Y, D> && >( r ) ).swap(*this);
        return *this;
    }



    template<class Y, class D>
    shared_ptr & operator=( boost::movelib::unique_ptr<Y, D> r )
    {


        boost::detail::sp_assert_convertible< Y, T >();

        typename boost::movelib::unique_ptr< Y, D >::pointer p = r.get();

        shared_ptr tmp;

        if( p != 0 )
        {
            tmp.px = p;
            tmp.pn = boost::detail::shared_count( r );

            boost::detail::sp_deleter_construct( &tmp, p );
        }

        tmp.swap( *this );

        return *this;
    }





    shared_ptr( shared_ptr && r ) noexcept : px( r.px ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    noexcept : px( r.px ), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        pn.swap( r.pn );
        r.px = 0;
    }

    shared_ptr & operator=( shared_ptr && r ) noexcept
    {
        this_type( static_cast< shared_ptr && >( r ) ).swap( *this );
        return *this;
    }

    template<class Y>
    shared_ptr & operator=( shared_ptr<Y> && r ) noexcept
    {
        this_type( static_cast< shared_ptr<Y> && >( r ) ).swap( *this );
        return *this;
    }


    template<class Y>
    shared_ptr( shared_ptr<Y> && r, element_type * p ) noexcept : px( p ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }





    shared_ptr & operator=( boost::detail::sp_nullptr_t ) noexcept
    {
        this_type().swap(*this);
        return *this;
    }



    void reset() noexcept
    {
        this_type().swap(*this);
    }

    template<class Y> void reset( Y * p )
    {
        (static_cast <bool> (p == 0 || p != px) ? void (0) : __assert_fail ("p == 0 || p != px", "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 698, __extension__ __PRETTY_FUNCTION__));
        this_type( p ).swap( *this );
    }

    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }

    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }

    template<class Y> void reset( shared_ptr<Y> const & r, element_type * p ) noexcept
    {
        this_type( r, p ).swap( *this );
    }



    template<class Y> void reset( shared_ptr<Y> && r, element_type * p ) noexcept
    {
        this_type( static_cast< shared_ptr<Y> && >( r ), p ).swap( *this );
    }



    typename boost::detail::sp_dereference< T >::type operator* () const noexcept
    {
        (static_cast <bool> (px != 0) ? void (0) : __assert_fail ("px != 0", "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 728, __extension__ __PRETTY_FUNCTION__));
        return *px;
    }

    typename boost::detail::sp_member_access< T >::type operator-> () const noexcept
    {
        (static_cast <bool> (px != 0) ? void (0) : __assert_fail ("px != 0", "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 734, __extension__ __PRETTY_FUNCTION__));
        return px;
    }

    typename boost::detail::sp_array_access< T >::type operator[] ( std::ptrdiff_t i ) const noexcept
    {
        (static_cast <bool> (px != 0) ? void (0) : __assert_fail ("px != 0", "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 740, __extension__ __PRETTY_FUNCTION__));
        (static_cast <bool> (i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 )) ? void (0) : __assert_fail ("i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 )", "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 741, __extension__ __PRETTY_FUNCTION__));

        return static_cast< typename boost::detail::sp_array_access< T >::type >( px[ i ] );
    }

    element_type * get() const noexcept
    {
        return px;
    }


# 1 "/usr/local/include/boost/smart_ptr/detail/operator_bool.hpp" 1 3
# 12 "/usr/local/include/boost/smart_ptr/detail/operator_bool.hpp" 3
    explicit operator bool () const noexcept
    {
        return px != 0;
    }
# 61 "/usr/local/include/boost/smart_ptr/detail/operator_bool.hpp" 3
    bool operator! () const noexcept
    {
        return px == 0;
    }
# 753 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3

    bool unique() const noexcept
    {
        return pn.unique();
    }

    long use_count() const noexcept
    {
        return pn.use_count();
    }

    void swap( shared_ptr & other ) noexcept
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool owner_before( shared_ptr<Y> const & rhs ) const noexcept
    {
        return pn < rhs.pn;
    }

    template<class Y> bool owner_before( weak_ptr<Y> const & rhs ) const noexcept
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const noexcept
    {
        return pn.get_deleter( ti );
    }

    void * _internal_get_local_deleter( boost::detail::sp_typeinfo const & ti ) const noexcept
    {
        return pn.get_local_deleter( ti );
    }

    void * _internal_get_untyped_deleter() const noexcept
    {
        return pn.get_untyped_deleter();
    }

    bool _internal_equiv( shared_ptr const & r ) const noexcept
    {
        return px == r.px && pn == r.pn;
    }

    boost::detail::shared_count _internal_count() const noexcept
    {
        return pn;
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;




    element_type * px;
    boost::detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b) noexcept
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b) noexcept
{
    return a.get() != b.get();
}
# 846 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
template<class T> inline bool operator==( shared_ptr<T> const & p, boost::detail::sp_nullptr_t ) noexcept
{
    return p.get() == 0;
}

template<class T> inline bool operator==( boost::detail::sp_nullptr_t, shared_ptr<T> const & p ) noexcept
{
    return p.get() == 0;
}

template<class T> inline bool operator!=( shared_ptr<T> const & p, boost::detail::sp_nullptr_t ) noexcept
{
    return p.get() != 0;
}

template<class T> inline bool operator!=( boost::detail::sp_nullptr_t, shared_ptr<T> const & p ) noexcept
{
    return p.get() != 0;
}



template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b) noexcept
{
    return a.owner_before( b );
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b) noexcept
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) static_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = static_cast< E* >( r.get() );
    return shared_ptr<T>( r, p );
}

template<class T, class U> shared_ptr<T> const_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) const_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = const_cast< E* >( r.get() );
    return shared_ptr<T>( r, p );
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) dynamic_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = dynamic_cast< E* >( r.get() );
    return p? shared_ptr<T>( r, p ): shared_ptr<T>();
}

template<class T, class U> shared_ptr<T> reinterpret_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) reinterpret_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = reinterpret_cast< E* >( r.get() );
    return shared_ptr<T>( r, p );
}



template<class T, class U> shared_ptr<T> static_pointer_cast( shared_ptr<U> && r ) noexcept
{
    (void) static_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = static_cast< E* >( r.get() );
    return shared_ptr<T>( std::move(r), p );
}

template<class T, class U> shared_ptr<T> const_pointer_cast( shared_ptr<U> && r ) noexcept
{
    (void) const_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = const_cast< E* >( r.get() );
    return shared_ptr<T>( std::move(r), p );
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast( shared_ptr<U> && r ) noexcept
{
    (void) dynamic_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = dynamic_cast< E* >( r.get() );
    return p? shared_ptr<T>( std::move(r), p ): shared_ptr<T>();
}

template<class T, class U> shared_ptr<T> reinterpret_pointer_cast( shared_ptr<U> && r ) noexcept
{
    (void) reinterpret_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = reinterpret_cast< E* >( r.get() );
    return shared_ptr<T>( std::move(r), p );
}





template<class T> inline typename shared_ptr<T>::element_type * get_pointer(shared_ptr<T> const & p) noexcept
{
    return p.get();
}
# 991 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 1006 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 3
namespace detail
{

template<class D, class T> D * basic_get_deleter( shared_ptr<T> const & p ) noexcept
{
    return static_cast<D *>( p._internal_get_deleter(typeid(D)) );
}

template<class D, class T> D * basic_get_local_deleter( D *, shared_ptr<T> const & p ) noexcept;
template<class D, class T> D const * basic_get_local_deleter( D const *, shared_ptr<T> const & p ) noexcept;

class esft2_deleter_wrapper
{
private:

    shared_ptr<void const volatile> deleter_;

public:

    esft2_deleter_wrapper() noexcept
    {
    }

    template< class T > void set_deleter( shared_ptr<T> const & deleter ) noexcept
    {
        deleter_ = deleter;
    }

    template<typename D> D* get_deleter() const noexcept
    {
        return boost::detail::basic_get_deleter<D>( deleter_ );
    }

    template< class T> void operator()( T* ) noexcept
    {
        (static_cast <bool> (deleter_.use_count() <= 1) ? void (0) : __assert_fail ("deleter_.use_count() <= 1", "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 1041, __extension__ __PRETTY_FUNCTION__));
        deleter_.reset();
    }
};

}

template<class D, class T> D * get_deleter( shared_ptr<T> const & p ) noexcept
{
    D * d = boost::detail::basic_get_deleter<D>( p );

    if( d == 0 )
    {
        d = boost::detail::basic_get_local_deleter( d, p );
    }

    if( d == 0 )
    {
        boost::detail::esft2_deleter_wrapper *del_wrapper = boost::detail::basic_get_deleter<boost::detail::esft2_deleter_wrapper>(p);


        if(del_wrapper) d = del_wrapper->::boost::detail::esft2_deleter_wrapper::get_deleter<D>();
    }

    return d;
}





template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * ) noexcept
{
    return false;
}

template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p ) noexcept
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}

template<class T, class M> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, M ) noexcept
{
    return atomic_load( p );
}

template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r ) noexcept
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}

template<class T, class M> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, M ) noexcept
{
    atomic_store( p, r );
}

template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r ) noexcept
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();
    p->swap( r );
    sp.unlock();

    return r;
}

template<class T, class M> shared_ptr<T> inline atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, M ) noexcept
{
    return atomic_exchange( p, r );
}

template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w ) noexcept
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();

    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );

        sp.unlock();

        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );

        sp.unlock();

        tmp.swap( *v );
        return false;
    }
}

template<class T, class M> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, M, M ) noexcept
{
    return atomic_compare_exchange( p, v, w );
}





template< class T > struct hash;

template< class T > std::size_t hash_value( boost::shared_ptr<T> const & p ) noexcept
{
    return boost::hash< typename boost::shared_ptr<T>::element_type* >()( p.get() );
}

}

# 1 "/usr/local/include/boost/smart_ptr/detail/local_sp_deleter.hpp" 1 3
# 20 "/usr/local/include/boost/smart_ptr/detail/local_sp_deleter.hpp" 3
# 1 "/usr/local/include/boost/smart_ptr/detail/local_counted_base.hpp" 1 3
# 24 "/usr/local/include/boost/smart_ptr/detail/local_counted_base.hpp" 3
namespace boost
{

namespace detail
{

class __attribute__((__visibility__("default"))) local_counted_base
{
private:

    local_counted_base & operator= ( local_counted_base const & );

private:


    enum count_type { min_ = 0, initial_ = 1, max_ = 2147483647 };

    count_type local_use_count_;

public:

    constexpr local_counted_base() noexcept: local_use_count_( initial_ )
    {
    }

    constexpr local_counted_base( local_counted_base const & ) noexcept: local_use_count_( initial_ )
    {
    }

    virtual ~local_counted_base()
    {
    }

    virtual void local_cb_destroy() noexcept = 0;

    virtual boost::detail::shared_count local_cb_get_shared_count() const noexcept = 0;

    void add_ref() noexcept
    {
# 73 "/usr/local/include/boost/smart_ptr/detail/local_counted_base.hpp" 3
        local_use_count_ = static_cast<count_type>( local_use_count_ + 1 );
    }

    void release() noexcept
    {
        local_use_count_ = static_cast<count_type>( local_use_count_ - 1 );

        if( local_use_count_ == 0 )
        {
            local_cb_destroy();
        }
    }

    long local_use_count() const noexcept
    {
        return local_use_count_;
    }
};

class __attribute__((__visibility__("default"))) local_counted_impl: public local_counted_base
{
private:

    local_counted_impl( local_counted_impl const & );

private:

    shared_count pn_;

public:

    explicit local_counted_impl( shared_count const& pn ) noexcept: pn_( pn )
    {
    }



    explicit local_counted_impl( shared_count && pn ) noexcept: pn_( std::move(pn) )
    {
    }



    virtual void local_cb_destroy() noexcept
    {
        delete this;
    }

    virtual boost::detail::shared_count local_cb_get_shared_count() const noexcept
    {
        return pn_;
    }
};

class __attribute__((__visibility__("default"))) local_counted_impl_em: public local_counted_base
{
public:

    shared_count pn_;

    virtual void local_cb_destroy() noexcept
    {
        shared_count().swap( pn_ );
    }

    virtual boost::detail::shared_count local_cb_get_shared_count() const noexcept
    {
        return pn_;
    }
};

}

}
# 21 "/usr/local/include/boost/smart_ptr/detail/local_sp_deleter.hpp" 2 3


namespace boost
{

namespace detail
{

template<class D> class local_sp_deleter: public local_counted_impl_em
{
private:

    D d_;

public:

    local_sp_deleter(): d_()
    {
    }

    explicit local_sp_deleter( D const& d ) noexcept: d_( d )
    {
    }



    explicit local_sp_deleter( D&& d ) noexcept: d_( std::move(d) )
    {
    }



    D& deleter() noexcept
    {
        return d_;
    }

    template<class Y> void operator()( Y* p ) noexcept
    {
        d_( p );
    }



    void operator()( boost::detail::sp_nullptr_t p ) noexcept
    {
        d_( p );
    }


};

template<> class local_sp_deleter<void>
{
};

template<class D> D * get_local_deleter( local_sp_deleter<D> * p ) noexcept
{
    return &p->deleter();
}

inline void * get_local_deleter( local_sp_deleter<void> * ) noexcept
{
    return 0;
}

}

}
# 1159 "/usr/local/include/boost/smart_ptr/shared_ptr.hpp" 2 3

namespace boost
{

namespace detail
{

template<class D, class T> D * basic_get_local_deleter( D *, shared_ptr<T> const & p ) noexcept
{
    return static_cast<D *>( p._internal_get_local_deleter( typeid(local_sp_deleter<D>) ) );
}

template<class D, class T> D const * basic_get_local_deleter( D const *, shared_ptr<T> const & p ) noexcept
{
    return static_cast<D *>( p._internal_get_local_deleter( typeid(local_sp_deleter<D>) ) );
}

}

}


#pragma GCC diagnostic pop
# 18 "/usr/local/include/boost/shared_ptr.hpp" 2 3
# 13 "/usr/local/include/boost/python/converter/shared_ptr_to_python.hpp" 2 3


namespace boost { namespace python { namespace converter {

template <class T>
PyObject* shared_ptr_to_python(shared_ptr<T> const& x)
{
    if (!x)
        return python::detail::none();
    else if (shared_ptr_deleter* d = boost::get_deleter<shared_ptr_deleter>(x))
        return incref( get_pointer( d->owner ) );
    else
        return converter::registered<shared_ptr<T> const&>::converters.to_python(&x);
}


template <class T>
PyObject* shared_ptr_to_python(std::shared_ptr<T> const& x)
{
  if (!x)
    return python::detail::none();
  else if (shared_ptr_deleter* d = std::get_deleter<shared_ptr_deleter>(x))
    return incref(get_pointer(d->owner));
  else
    return converter::registered<std::shared_ptr<T> const&>::converters.to_python(&x);
}


}}}
# 16 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3

# 1 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 1 3
# 10 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 3
# 1 "/usr/local/include/boost/python/ssize_t.hpp" 1 3
# 11 "/usr/local/include/boost/python/ssize_t.hpp" 3
namespace boost { namespace python {



typedef Py_ssize_t ssize_t;
ssize_t const ssize_t_max = ((Py_ssize_t)(((size_t)-1)>>1));
ssize_t const ssize_t_min = (-((Py_ssize_t)(((size_t)-1)>>1))-1);
# 27 "/usr/local/include/boost/python/ssize_t.hpp" 3
}}
# 11 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 2 3
# 1 "/usr/local/include/boost/implicit_cast.hpp" 1 3







namespace boost {

namespace detail {

template<class T> struct icast_identity
{
    typedef T type;
};

}






template <typename T>
inline T implicit_cast (typename boost::detail::icast_identity<T>::type x) {
    return x;
}





}
# 12 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 2 3

# 1 "/usr/include/c++/7/complex" 1 3
# 39 "/usr/include/c++/7/complex" 3
       
# 40 "/usr/include/c++/7/complex" 3




# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 45 "/usr/include/c++/7/complex" 2 3
# 1 "/usr/include/c++/7/sstream" 1 3
# 36 "/usr/include/c++/7/sstream" 3
       
# 37 "/usr/include/c++/7/sstream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/include/c++/7/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 165 "/usr/include/c++/7/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 189 "/usr/include/c++/7/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 242 "/usr/include/c++/7/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 356 "/usr/include/c++/7/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 379 "/usr/include/c++/7/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 415 "/usr/include/c++/7/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 433 "/usr/include/c++/7/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 484 "/usr/include/c++/7/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 523 "/usr/include/c++/7/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 559 "/usr/include/c++/7/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 577 "/usr/include/c++/7/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 628 "/usr/include/c++/7/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 667 "/usr/include/c++/7/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 702 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 718 "/usr/include/c++/7/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 769 "/usr/include/c++/7/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/include/c++/7/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/7/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/7/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/include/c++/7/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 827 "/usr/include/c++/7/sstream" 2 3
# 46 "/usr/include/c++/7/complex" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/7/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 121 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      constexpr complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }



      constexpr complex(const complex&) = default;



      template<typename _Up>
        constexpr complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      real() const { return _M_real; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      imag() const { return _M_imag; }
# 172 "/usr/include/c++/7/complex" 3
      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);



      complex& operator=(const complex&) = default;



      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      constexpr complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch = _CharT();
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else if (__is)
 {
   __is.putback(__ch);
   if (__is >> __re_x)
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }



  template<typename _Tp>
    constexpr _Tp
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    constexpr _Tp
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }
# 572 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 608 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 638 "/usr/include/c++/7/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    {
      ;
      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));
    }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 772 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 864 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 908 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 936 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 965 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),
        __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(float __r = 0.0f, float __i = 0.0f)

      : _M_value{ __r, __i } { }







      explicit constexpr complex(const complex<double>&);
      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      imag() const { return __imag__ _M_value; }
# 1099 "/usr/include/c++/7/complex" 3
      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(double __r = 0.0, double __i = 0.0)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      imag() const { return __imag__ _M_value; }
# 1250 "/usr/include/c++/7/complex" 3
      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(long double __r = 0.0L,
     long double __i = 0.0L)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      constexpr complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      imag() const { return __imag__ _M_value; }
# 1402 "/usr/include/c++/7/complex" 3
      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline constexpr
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);

  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);

  template<typename _Tp> _Tp fabs(const std::complex<_Tp>&);

  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_acos(const std::complex<_Tp>& __z)
    {
      const std::complex<_Tp> __t = std::asin(__z);
      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;
      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());
    }


  inline __complex__ float
  __complex_acos(__complex__ float __z)
  { return __builtin_cacosf(__z); }

  inline __complex__ double
  __complex_acos(__complex__ double __z)
  { return __builtin_cacos(__z); }

  inline __complex__ long double
  __complex_acos(const __complex__ long double& __z)
  { return __builtin_cacosl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acos(const std::complex<_Tp>& __z)
    { return __complex_acos(__z.__rep()); }
# 1623 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_asin(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t(-__z.imag(), __z.real());
      __t = std::asinh(__t);
      return std::complex<_Tp>(__t.imag(), -__t.real());
    }


  inline __complex__ float
  __complex_asin(__complex__ float __z)
  { return __builtin_casinf(__z); }

  inline __complex__ double
  __complex_asin(__complex__ double __z)
  { return __builtin_casin(__z); }

  inline __complex__ long double
  __complex_asin(const __complex__ long double& __z)
  { return __builtin_casinl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asin(const std::complex<_Tp>& __z)
    { return __complex_asin(__z.__rep()); }
# 1659 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atan(const std::complex<_Tp>& __z)
    {
      const _Tp __r2 = __z.real() * __z.real();
      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();

      _Tp __num = __z.imag() + _Tp(1.0);
      _Tp __den = __z.imag() - _Tp(1.0);

      __num = __r2 + __num * __num;
      __den = __r2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),
          _Tp(0.25) * log(__num / __den));
    }


  inline __complex__ float
  __complex_atan(__complex__ float __z)
  { return __builtin_catanf(__z); }

  inline __complex__ double
  __complex_atan(__complex__ double __z)
  { return __builtin_catan(__z); }

  inline __complex__ long double
  __complex_atan(const __complex__ long double& __z)
  { return __builtin_catanl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atan(const std::complex<_Tp>& __z)
    { return __complex_atan(__z.__rep()); }
# 1703 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_acosh(const std::complex<_Tp>& __z)
    {

      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
     + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
    }


  inline __complex__ float
  __complex_acosh(__complex__ float __z)
  { return __builtin_cacoshf(__z); }

  inline __complex__ double
  __complex_acosh(__complex__ double __z)
  { return __builtin_cacosh(__z); }

  inline __complex__ long double
  __complex_acosh(const __complex__ long double& __z)
  { return __builtin_cacoshl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acosh(const std::complex<_Tp>& __z)
    { return __complex_acosh(__z.__rep()); }
# 1739 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_asinh(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t((__z.real() - __z.imag())
       * (__z.real() + __z.imag()) + _Tp(1.0),
       _Tp(2.0) * __z.real() * __z.imag());
      __t = std::sqrt(__t);

      return std::log(__t + __z);
    }


  inline __complex__ float
  __complex_asinh(__complex__ float __z)
  { return __builtin_casinhf(__z); }

  inline __complex__ double
  __complex_asinh(__complex__ double __z)
  { return __builtin_casinh(__z); }

  inline __complex__ long double
  __complex_asinh(const __complex__ long double& __z)
  { return __builtin_casinhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asinh(const std::complex<_Tp>& __z)
    { return __complex_asinh(__z.__rep()); }
# 1778 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atanh(const std::complex<_Tp>& __z)
    {
      const _Tp __i2 = __z.imag() * __z.imag();
      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();

      _Tp __num = _Tp(1.0) + __z.real();
      _Tp __den = _Tp(1.0) - __z.real();

      __num = __i2 + __num * __num;
      __den = __i2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),
          _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));
    }


  inline __complex__ float
  __complex_atanh(__complex__ float __z)
  { return __builtin_catanhf(__z); }

  inline __complex__ double
  __complex_atanh(__complex__ double __z)
  { return __builtin_catanh(__z); }

  inline __complex__ long double
  __complex_atanh(const __complex__ long double& __z)
  { return __builtin_catanhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atanh(const std::complex<_Tp>& __z)
    { return __complex_atanh(__z.__rep()); }
# 1822 "/usr/include/c++/7/complex" 3
  template<typename _Tp>
    inline _Tp



    fabs(const std::complex<_Tp>& __z)
    { return std::abs(__z); }


  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    arg(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;

      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)
                        : __type();



    }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    imag(_Tp)
    { return _Tp(); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    norm(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __type(__x) * __type(__x);
    }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    real(_Tp __x)
    { return __x; }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const _Up& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const _Tp& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), std::complex<__type>(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x),
        std::complex<__type>(__y));
    }



  template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);

  template<typename _Tp>
    std::complex<_Tp>
    __complex_proj(const std::complex<_Tp>& __z)
    {
      const _Tp __den = (__z.real() * __z.real()
    + __z.imag() * __z.imag() + _Tp(1.0));

      return std::complex<_Tp>((_Tp(2.0) * __z.real()) / __den,
          (_Tp(2.0) * __z.imag()) / __den);
    }


  inline __complex__ float
  __complex_proj(__complex__ float __z)
  { return __builtin_cprojf(__z); }

  inline __complex__ double
  __complex_proj(__complex__ double __z)
  { return __builtin_cproj(__z); }

  inline __complex__ long double
  __complex_proj(const __complex__ long double& __z)
  { return __builtin_cprojl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    proj(const std::complex<_Tp>& __z)
    { return __complex_proj(__z.__rep()); }







  template<typename _Tp>
    inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
    proj(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return std::proj(std::complex<__type>(__x));
    }

  template<typename _Tp>
    inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
    conj(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return std::complex<__type>(__x, -__type());
    }





inline namespace literals {
inline namespace complex_literals {




  constexpr std::complex<float>
  operator""if(long double __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<float>
  operator""if(unsigned long long __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<double>
  operator""i(long double __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<double>
  operator""i(unsigned long long __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<long double>
  operator""il(long double __num)
  { return std::complex<long double>{0.0L, __num}; }

  constexpr std::complex<long double>
  operator""il(unsigned long long __num)
  { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }


}
}



}
# 14 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 2 3
# 22 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 3
namespace boost { namespace python {

namespace converter
{
  template <class T> struct arg_to_python;
  PyObject* do_return_to_python(char);
  PyObject* do_return_to_python(char const*);
  PyObject* do_return_to_python(PyObject*);
  PyObject* do_arg_to_python(PyObject*);
}


template <class T> struct to_python_value;

namespace detail
{


  struct builtin_to_python
  {



      static const bool uses_registry = false;
  };
}
# 113 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 3
template <> struct to_python_value<bool&> : detail::builtin_to_python { inline PyObject* operator()(bool const& x) const { return (::PyBool_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyBool_Type); } }; template <> struct to_python_value<bool const&> : detail::builtin_to_python { inline PyObject* operator()(bool const& x) const { return (::PyBool_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyBool_Type); } }; namespace converter { template <> struct arg_to_python< bool > : handle<> { arg_to_python(bool const& x) : python::handle<>(::PyBool_FromLong(x)) {} }; }





template <> struct to_python_value<signed char&> : detail::builtin_to_python { inline PyObject* operator()(signed char const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<signed char const&> : detail::builtin_to_python { inline PyObject* operator()(signed char const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< signed char > : handle<> { arg_to_python(signed char const& x) : python::handle<>(::PyInt_FromLong(x)) {} }; } template <> struct to_python_value<unsigned char&> : detail::builtin_to_python { inline PyObject* operator()(unsigned char const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<unsigned char const&> : detail::builtin_to_python { inline PyObject* operator()(unsigned char const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< unsigned char > : handle<> { arg_to_python(unsigned char const& x) : python::handle<>(static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)) {} }; }

template <> struct to_python_value<signed short&> : detail::builtin_to_python { inline PyObject* operator()(signed short const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<signed short const&> : detail::builtin_to_python { inline PyObject* operator()(signed short const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< signed short > : handle<> { arg_to_python(signed short const& x) : python::handle<>(::PyInt_FromLong(x)) {} }; } template <> struct to_python_value<unsigned short&> : detail::builtin_to_python { inline PyObject* operator()(unsigned short const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<unsigned short const&> : detail::builtin_to_python { inline PyObject* operator()(unsigned short const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< unsigned short > : handle<> { arg_to_python(unsigned short const& x) : python::handle<>(static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)) {} }; }
template <> struct to_python_value<signed int&> : detail::builtin_to_python { inline PyObject* operator()(signed int const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<signed int const&> : detail::builtin_to_python { inline PyObject* operator()(signed int const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< signed int > : handle<> { arg_to_python(signed int const& x) : python::handle<>(::PyInt_FromLong(x)) {} }; } template <> struct to_python_value<unsigned int&> : detail::builtin_to_python { inline PyObject* operator()(unsigned int const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<unsigned int const&> : detail::builtin_to_python { inline PyObject* operator()(unsigned int const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< unsigned int > : handle<> { arg_to_python(unsigned int const& x) : python::handle<>(static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)) {} }; }
template <> struct to_python_value<signed long&> : detail::builtin_to_python { inline PyObject* operator()(signed long const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<signed long const&> : detail::builtin_to_python { inline PyObject* operator()(signed long const& x) const { return (::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< signed long > : handle<> { arg_to_python(signed long const& x) : python::handle<>(::PyInt_FromLong(x)) {} }; } template <> struct to_python_value<unsigned long&> : detail::builtin_to_python { inline PyObject* operator()(unsigned long const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; template <> struct to_python_value<unsigned long const&> : detail::builtin_to_python { inline PyObject* operator()(unsigned long const& x) const { return (static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyInt_Type); } }; namespace converter { template <> struct arg_to_python< unsigned long > : handle<> { arg_to_python(unsigned long const& x) : python::handle<>(static_cast<unsigned long>(x) > static_cast<unsigned long>( (std::numeric_limits<long>::max)()) ? ::PyLong_FromUnsignedLong(x) : ::PyInt_FromLong(x)) {} }; }
# 149 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 3
template <> struct to_python_value<signed long long&> : detail::builtin_to_python { inline PyObject* operator()(signed long long const& x) const { return (::PyLong_FromLongLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyLong_Type); } }; template <> struct to_python_value<signed long long const&> : detail::builtin_to_python { inline PyObject* operator()(signed long long const& x) const { return (::PyLong_FromLongLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyLong_Type); } }; namespace converter { template <> struct arg_to_python< signed long long > : handle<> { arg_to_python(signed long long const& x) : python::handle<>(::PyLong_FromLongLong(x)) {} }; }
template <> struct to_python_value<unsigned long long&> : detail::builtin_to_python { inline PyObject* operator()(unsigned long long const& x) const { return (::PyLong_FromUnsignedLongLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyLong_Type); } }; template <> struct to_python_value<unsigned long long const&> : detail::builtin_to_python { inline PyObject* operator()(unsigned long long const& x) const { return (::PyLong_FromUnsignedLongLong(x)); } inline PyTypeObject const* get_pytype() const { return (&PyLong_Type); } }; namespace converter { template <> struct arg_to_python< unsigned long long > : handle<> { arg_to_python(unsigned long long const& x) : python::handle<>(::PyLong_FromUnsignedLongLong(x)) {} }; }
# 160 "/usr/local/include/boost/python/converter/builtin_converters.hpp" 3
template <> struct to_python_value<char&> : detail::builtin_to_python { inline PyObject* operator()(char const& x) const { return (converter::do_return_to_python(x)); } inline PyTypeObject const* get_pytype() const { return (&PyString_Type); } }; template <> struct to_python_value<char const&> : detail::builtin_to_python { inline PyObject* operator()(char const& x) const { return (converter::do_return_to_python(x)); } inline PyTypeObject const* get_pytype() const { return (&PyString_Type); } }; namespace converter { template <> struct arg_to_python< char > : handle<> { arg_to_python(char const& x) : python::handle<>(converter::do_return_to_python(x)) {} }; }
template <> struct to_python_value<char const*&> : detail::builtin_to_python { inline PyObject* operator()(char const* const& x) const { return (converter::do_return_to_python(x)); } inline PyTypeObject const* get_pytype() const { return (&PyString_Type); } }; template <> struct to_python_value<char const* const&> : detail::builtin_to_python { inline PyObject* operator()(char const* const& x) const { return (converter::do_return_to_python(x)); } inline PyTypeObject const* get_pytype() const { return (&PyString_Type); } }; namespace converter { template <> struct arg_to_python< char const* > : handle<> { arg_to_python(char const* const& x) : python::handle<>(converter::do_return_to_python(x)) {} }; }
template <> struct to_python_value<std::string&> : detail::builtin_to_python { inline PyObject* operator()(std::string const& x) const { return (::PyString_FromStringAndSize(x.data(),implicit_cast<ssize_t>(x.size()))); } inline PyTypeObject const* get_pytype() const { return (&PyString_Type); } }; template <> struct to_python_value<std::string const&> : detail::builtin_to_python { inline PyObject* operator()(std::string const& x) const { return (::PyString_FromStringAndSize(x.data(),implicit_cast<ssize_t>(x.size()))); } inline PyTypeObject const* get_pytype() const { return (&PyString_Type); } }; namespace converter { template <> struct arg_to_python< std::string > : handle<> { arg_to_python(std::string const& x) : python::handle<>(::PyString_FromStringAndSize(x.data(),implicit_cast<ssize_t>(x.size()))) {} }; }



template <> struct to_python_value<std::wstring&> : detail::builtin_to_python { inline PyObject* operator()(std::wstring const& x) const { return (::PyUnicodeUCS4_FromWideChar(x.data(),implicit_cast<ssize_t>(x.size()))); } inline PyTypeObject const* get_pytype() const { return (&PyUnicode_Type); } }; template <> struct to_python_value<std::wstring const&> : detail::builtin_to_python { inline PyObject* operator()(std::wstring const& x) const { return (::PyUnicodeUCS4_FromWideChar(x.data(),implicit_cast<ssize_t>(x.size()))); } inline PyTypeObject const* get_pytype() const { return (&PyUnicode_Type); } }; namespace converter { template <> struct arg_to_python< std::wstring > : handle<> { arg_to_python(std::wstring const& x) : python::handle<>(::PyUnicodeUCS4_FromWideChar(x.data(),implicit_cast<ssize_t>(x.size()))) {} }; }

template <> struct to_python_value<float&> : detail::builtin_to_python { inline PyObject* operator()(float const& x) const { return (::PyFloat_FromDouble(x)); } inline PyTypeObject const* get_pytype() const { return (&PyFloat_Type); } }; template <> struct to_python_value<float const&> : detail::builtin_to_python { inline PyObject* operator()(float const& x) const { return (::PyFloat_FromDouble(x)); } inline PyTypeObject const* get_pytype() const { return (&PyFloat_Type); } }; namespace converter { template <> struct arg_to_python< float > : handle<> { arg_to_python(float const& x) : python::handle<>(::PyFloat_FromDouble(x)) {} }; }
template <> struct to_python_value<double&> : detail::builtin_to_python { inline PyObject* operator()(double const& x) const { return (::PyFloat_FromDouble(x)); } inline PyTypeObject const* get_pytype() const { return (&PyFloat_Type); } }; template <> struct to_python_value<double const&> : detail::builtin_to_python { inline PyObject* operator()(double const& x) const { return (::PyFloat_FromDouble(x)); } inline PyTypeObject const* get_pytype() const { return (&PyFloat_Type); } }; namespace converter { template <> struct arg_to_python< double > : handle<> { arg_to_python(double const& x) : python::handle<>(::PyFloat_FromDouble(x)) {} }; }
template <> struct to_python_value<long double&> : detail::builtin_to_python { inline PyObject* operator()(long double const& x) const { return (::PyFloat_FromDouble(x)); } inline PyTypeObject const* get_pytype() const { return (&PyFloat_Type); } }; template <> struct to_python_value<long double const&> : detail::builtin_to_python { inline PyObject* operator()(long double const& x) const { return (::PyFloat_FromDouble(x)); } inline PyTypeObject const* get_pytype() const { return (&PyFloat_Type); } }; namespace converter { template <> struct arg_to_python< long double > : handle<> { arg_to_python(long double const& x) : python::handle<>(::PyFloat_FromDouble(x)) {} }; }
template <> struct to_python_value<PyObject*&> : detail::builtin_to_python { inline PyObject* operator()(PyObject* const& x) const { return (converter::do_return_to_python(x)); } inline PyTypeObject const* get_pytype() const { return (0); } }; template <> struct to_python_value<PyObject* const&> : detail::builtin_to_python { inline PyObject* operator()(PyObject* const& x) const { return (converter::do_return_to_python(x)); } inline PyTypeObject const* get_pytype() const { return (0); } };
template <> struct to_python_value<std::complex<float>&> : detail::builtin_to_python { inline PyObject* operator()(std::complex<float> const& x) const { return (::PyComplex_FromDoubles(x.real(), x.imag())); } inline PyTypeObject const* get_pytype() const { return (&PyComplex_Type); } }; template <> struct to_python_value<std::complex<float> const&> : detail::builtin_to_python { inline PyObject* operator()(std::complex<float> const& x) const { return (::PyComplex_FromDoubles(x.real(), x.imag())); } inline PyTypeObject const* get_pytype() const { return (&PyComplex_Type); } }; namespace converter { template <> struct arg_to_python< std::complex<float> > : handle<> { arg_to_python(std::complex<float> const& x) : python::handle<>(::PyComplex_FromDoubles(x.real(), x.imag())) {} }; }
template <> struct to_python_value<std::complex<double>&> : detail::builtin_to_python { inline PyObject* operator()(std::complex<double> const& x) const { return (::PyComplex_FromDoubles(x.real(), x.imag())); } inline PyTypeObject const* get_pytype() const { return (&PyComplex_Type); } }; template <> struct to_python_value<std::complex<double> const&> : detail::builtin_to_python { inline PyObject* operator()(std::complex<double> const& x) const { return (::PyComplex_FromDoubles(x.real(), x.imag())); } inline PyTypeObject const* get_pytype() const { return (&PyComplex_Type); } }; namespace converter { template <> struct arg_to_python< std::complex<double> > : handle<> { arg_to_python(std::complex<double> const& x) : python::handle<>(::PyComplex_FromDoubles(x.real(), x.imag())) {} }; }
template <> struct to_python_value<std::complex<long double>&> : detail::builtin_to_python { inline PyObject* operator()(std::complex<long double> const& x) const { return (::PyComplex_FromDoubles(x.real(), x.imag())); } inline PyTypeObject const* get_pytype() const { return (&PyComplex_Type); } }; template <> struct to_python_value<std::complex<long double> const&> : detail::builtin_to_python { inline PyObject* operator()(std::complex<long double> const& x) const { return (::PyComplex_FromDoubles(x.real(), x.imag())); } inline PyTypeObject const* get_pytype() const { return (&PyComplex_Type); } }; namespace converter { template <> struct arg_to_python< std::complex<long double> > : handle<> { arg_to_python(std::complex<long double> const& x) : python::handle<>(::PyComplex_FromDoubles(x.real(), x.imag())) {} }; }






namespace converter
{

  void initialize_builtin_converters();

}

}}
# 18 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3

# 1 "/usr/local/include/boost/python/object/function_handle.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 16 "/usr/local/include/boost/python/detail/caller.hpp" 3
# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 17 "/usr/local/include/boost/python/detail/invoke.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/enum_trailing_binary_params.hpp" 1 3
# 18 "/usr/local/include/boost/python/detail/invoke.hpp" 2 3

# 1 "/usr/local/include/boost/python/to_python_value.hpp" 1 3
# 19 "/usr/local/include/boost/python/to_python_value.hpp" 3
# 1 "/usr/local/include/boost/python/converter/object_manager.hpp" 1 3
# 10 "/usr/local/include/boost/python/converter/object_manager.hpp" 3
# 1 "/usr/local/include/boost/python/converter/pyobject_traits.hpp" 1 3
# 9 "/usr/local/include/boost/python/converter/pyobject_traits.hpp" 3
# 1 "/usr/local/include/boost/python/converter/pyobject_type.hpp" 1 3
# 10 "/usr/local/include/boost/python/converter/pyobject_type.hpp" 3
namespace boost { namespace python { namespace converter {

 inline
PyObject* checked_downcast_impl(PyObject *obj, PyTypeObject *type)
{
  return (PyType_IsSubtype((((PyObject*)(obj))->ob_type), type) ? obj : __null);
}


template <class Object, PyTypeObject* pytype>
struct pyobject_type
{
    static bool check(PyObject* x)
    {
        return ::PyObject_IsInstance(x, (PyObject*)pytype);
    }

    static Object* checked_downcast(PyObject* x)
    {
        return python::downcast<Object>(
            (checked_downcast_impl)(x, pytype)
            );
    }

    static PyTypeObject const* get_pytype() { return pytype; }

};

}}}
# 10 "/usr/local/include/boost/python/converter/pyobject_traits.hpp" 2 3

namespace boost { namespace python { namespace converter {

template <class> struct pyobject_traits;

template <>
struct pyobject_traits<PyObject>
{

    static bool check(PyObject*) { return true; }
    static PyObject* checked_downcast(PyObject* x) { return x; }

    static PyTypeObject const* get_pytype() { return 0; }

};
# 35 "/usr/local/include/boost/python/converter/pyobject_traits.hpp" 3
template <> struct pyobject_traits<PyTypeObject> : pyobject_type<PyTypeObject, &PyType_Type> {};
template <> struct pyobject_traits<PyListObject> : pyobject_type<PyListObject, &PyList_Type> {};

template <> struct pyobject_traits<PyIntObject> : pyobject_type<PyIntObject, &PyInt_Type> {};

template <> struct pyobject_traits<PyLongObject> : pyobject_type<PyLongObject, &PyLong_Type> {};
template <> struct pyobject_traits<PyDictObject> : pyobject_type<PyDictObject, &PyDict_Type> {};
template <> struct pyobject_traits<PyTupleObject> : pyobject_type<PyTupleObject, &PyTuple_Type> {};

}}}
# 11 "/usr/local/include/boost/python/converter/object_manager.hpp" 2 3
# 65 "/usr/local/include/boost/python/converter/object_manager.hpp" 3
namespace boost { namespace python
{
  namespace api
  {
    class object;
  }
}}

namespace boost { namespace python { namespace converter {



template <class T>
struct handle_object_manager_traits
    : pyobject_traits<typename T::element_type>
{
 private:
  typedef pyobject_traits<typename T::element_type> base;

 public:
  static const bool is_specialized = true;



  static null_ok<typename T::element_type>* adopt(PyObject* p)
  {
      return python::allow_null(base::checked_downcast(p));
  }
};

template <class T>
struct default_object_manager_traits
{
    static const bool is_specialized = python::detail::is_borrowed_ptr<T>::value

         ;
};

template <class T>
struct object_manager_traits
    : mpl::if_c<
         is_handle<T>::value
       , handle_object_manager_traits<T>
       , default_object_manager_traits<T>
    >::type
{
};






template <class T>
struct is_object_manager
    : mpl::bool_<object_manager_traits<T>::is_specialized>
{
};

template <class T>
struct is_reference_to_object_manager
    : mpl::false_
{
};

template <class T>
struct is_reference_to_object_manager<T&>
    : is_object_manager<T>
{
};

template <class T>
struct is_reference_to_object_manager<T const&>
    : is_object_manager<T>
{
};

template <class T>
struct is_reference_to_object_manager<T volatile&>
    : is_object_manager<T>
{
};

template <class T>
struct is_reference_to_object_manager<T const volatile&>
    : is_object_manager<T>
{
};

}}}
# 20 "/usr/local/include/boost/python/to_python_value.hpp" 2 3



# 1 "/usr/local/include/boost/python/detail/value_is_shared_ptr.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/value_is_shared_ptr.hpp" 3
# 1 "/usr/local/include/boost/python/detail/value_is_xxx.hpp" 1 3
# 15 "/usr/local/include/boost/python/detail/value_is_xxx.hpp" 3
namespace boost { namespace python { namespace detail {
# 31 "/usr/local/include/boost/python/detail/value_is_xxx.hpp" 3
}}}
# 11 "/usr/local/include/boost/python/detail/value_is_shared_ptr.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/is_shared_ptr.hpp" 1 3
# 13 "/usr/local/include/boost/python/detail/is_shared_ptr.hpp" 3
namespace boost { namespace python { namespace detail {

template <class T> struct is_shared_ptr : boost::false_type { }; template < class T0 > struct is_shared_ptr< shared_ptr< T0 > > : boost::true_type { };

template <typename T>
struct is_shared_ptr<std::shared_ptr<T> > : std::true_type {};


}}}
# 12 "/usr/local/include/boost/python/detail/value_is_shared_ptr.hpp" 2 3

namespace boost { namespace python { namespace detail {

template <class X_>
struct value_is_shared_ptr
{
  static bool const value = is_shared_ptr<typename remove_cv<
         typename remove_reference<X_>
           ::type>
         ::type>
    ::value;
  typedef mpl::bool_<value> type;
};

}}}
# 24 "/usr/local/include/boost/python/to_python_value.hpp" 2 3





namespace boost { namespace python {

namespace detail
{


template <bool is_const_ref>
struct object_manager_get_pytype
{
   template <class U>
   static PyTypeObject const* get( U& (*)() =0)
   {
      return converter::object_manager_traits<U>::get_pytype();
   }
};

template <>
struct object_manager_get_pytype<true>
{
   template <class U>
   static PyTypeObject const* get( U const& (*)() =0)
   {
      return converter::object_manager_traits<U>::get_pytype();
   }
};



  template <class T>
  struct object_manager_to_python_value
  {
      typedef typename value_arg<T>::type argument_type;

      PyObject* operator()(argument_type) const;

      typedef boost::mpl::bool_<is_handle<T>::value> is_t_handle;
      typedef boost::detail::indirect_traits::is_reference_to_const<T> is_t_const;
      PyTypeObject const* get_pytype() const {
          return get_pytype_aux((is_t_handle*)0);
      }

      inline static PyTypeObject const* get_pytype_aux(mpl::true_*) {return converter::object_manager_traits<T>::get_pytype();}

      inline static PyTypeObject const* get_pytype_aux(mpl::false_* )
      {
          return object_manager_get_pytype<is_t_const::value>::get((T(*)())0);
      }






      static const bool uses_registry = false;
  };


  template <class T>
  struct registry_to_python_value
  {
      typedef typename value_arg<T>::type argument_type;

      PyObject* operator()(argument_type) const;

      PyTypeObject const* get_pytype() const {return converter::registered<T>::converters.to_python_target_type();}





      static const bool uses_registry = true;
  };

  template <class T>
  struct shared_ptr_to_python_value
  {
      typedef typename value_arg<T>::type argument_type;

      PyObject* operator()(argument_type) const;

      PyTypeObject const* get_pytype() const {return get_pytype((boost::type<argument_type>*)0);}




      static const bool uses_registry = false;
  private:

    template <class U>
    PyTypeObject const* get_pytype(boost::type<shared_ptr<U> &> *) const {return converter::registered<U>::converters.to_python_target_type();}
    template <class U>
    PyTypeObject const* get_pytype(boost::type<const shared_ptr<U> &> *) const {return converter::registered<U>::converters.to_python_target_type();}

    template <class U>
    PyTypeObject const* get_pytype(boost::type<std::shared_ptr<U> &> *) const {return converter::registered<U>::converters.to_python_target_type();}
    template <class U>
    PyTypeObject const* get_pytype(boost::type<const std::shared_ptr<U> &> *) const {return converter::registered<U>::converters.to_python_target_type();}


  };
}

template <class T>
struct to_python_value
    : mpl::if_<
          detail::value_is_shared_ptr<T>
        , detail::shared_ptr_to_python_value<T>
        , typename mpl::if_<
              mpl::or_<
                  converter::is_object_manager<T>
                , converter::is_reference_to_object_manager<T>
              >
            , detail::object_manager_to_python_value<T>
            , detail::registry_to_python_value<T>
          >::type
      >::type
{
};




namespace detail
{
  template <class T>
  inline PyObject* registry_to_python_value<T>::operator()(argument_type x) const
  {
      return converter::registered<argument_type>::converters.to_python(&x);
  }

  template <class T>
  inline PyObject* object_manager_to_python_value<T>::operator()(argument_type x) const
  {
      return python::upcast<PyObject>(
          python::xincref(
              get_managed_object(x, tag))
          );
  }

  template <class T>
  inline PyObject* shared_ptr_to_python_value<T>::operator()(argument_type x) const
  {
      return converter::shared_ptr_to_python(x);
  }
}

}}
# 20 "/usr/local/include/boost/python/detail/invoke.hpp" 2 3
# 39 "/usr/local/include/boost/python/detail/invoke.hpp" 3
namespace boost { namespace python { namespace detail {



typedef int void_result_to_python;

template <bool void_return, bool member>
struct invoke_tag_ {};



template <class R, class F>
struct invoke_tag
  : invoke_tag_<
        is_same<R,void>::value
      , is_member_function_pointer<F>::value
    >
{
};



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F >
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f )
{
    return rc(f( ));
}

template <class RC, class F >
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f )
{
    f( );
    return none();
}

template <class RC, class F, class TC >
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc )
{
    return rc( (tc().*f)() );
}

template <class RC, class F, class TC >
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc )
{
    (tc().*f)();
    return none();
}
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 )
{
    return rc(f( ac0 () ));
}

template <class RC, class F , class AC0>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 )
{
    f( ac0 () );
    return none();
}

template <class RC, class F, class TC , class AC0>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 )
{
    return rc( (tc().*f)( ac0 () ) );
}

template <class RC, class F, class TC , class AC0>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 )
{
    (tc().*f)( ac0 () );
    return none();
}
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 )
{
    return rc(f( ac0 () , ac1 () ));
}

template <class RC, class F , class AC0 , class AC1>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 )
{
    f( ac0 () , ac1 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 )
{
    return rc( (tc().*f)( ac0 () , ac1 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 )
{
    (tc().*f)( ac0 () , ac1 () );
    return none();
}
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 )
{
    return rc(f( ac0 () , ac1 () , ac2 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 )
{
    f( ac0 () , ac1 () , ac2 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () );
    return none();
}
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () );
    return none();
}
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () );
    return none();
}
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () );
    return none();
}
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () );
    return none();
}
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () );
    return none();
}
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () );
    return none();
}
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () );
    return none();
}
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () );
    return none();
}
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () );
    return none();
}
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () );
    return none();
}
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () );
    return none();
}
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/invoke.hpp" 1 3
# 70 "/usr/local/include/boost/python/detail/invoke.hpp" 3
template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13 , class AC14>
inline PyObject* invoke(invoke_tag_<false,false>, RC const& rc, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 , AC14 & ac14 )
{
    return rc(f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () , ac14 () ));
}

template <class RC, class F , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13 , class AC14>
inline PyObject* invoke(invoke_tag_<true,false>, RC const&, F& f , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 , AC14 & ac14 )
{
    f( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () , ac14 () );
    return none();
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13 , class AC14>
inline PyObject* invoke(invoke_tag_<false,true>, RC const& rc, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 , AC14 & ac14 )
{
    return rc( (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () , ac14 () ) );
}

template <class RC, class F, class TC , class AC0 , class AC1 , class AC2 , class AC3 , class AC4 , class AC5 , class AC6 , class AC7 , class AC8 , class AC9 , class AC10 , class AC11 , class AC12 , class AC13 , class AC14>
inline PyObject* invoke(invoke_tag_<true,true>, RC const&, F& f, TC& tc , AC0 & ac0 , AC1 & ac1 , AC2 & ac2 , AC3 & ac3 , AC4 & ac4 , AC5 & ac5 , AC6 & ac6 , AC7 & ac7 , AC8 & ac8 , AC9 & ac9 , AC10 & ac10 , AC11 & ac11 , AC12 & ac12 , AC13 & ac13 , AC14 & ac14 )
{
    (tc().*f)( ac0 () , ac1 () , ac2 () , ac3 () , ac4 () , ac5 () , ac6 () , ac7 () , ac8 () , ac9 () , ac10 () , ac11 () , ac12 () , ac13 () , ac14 () );
    return none();
}
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 62 "/usr/local/include/boost/python/detail/invoke.hpp" 2 3

}}}
# 17 "/usr/local/include/boost/python/detail/caller.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/mpl/at.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/at.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/at_impl.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/at_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/begin_end.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/begin_end.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/begin_end_impl.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/begin_end_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/sequence_tag_fwd.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/sequence_tag_fwd.hpp" 3
namespace boost { namespace mpl {

struct nested_begin_end_tag;
struct non_sequence_tag;

template< typename Sequence > struct sequence_tag;

}}
# 19 "/usr/local/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/aux_/has_begin.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/has_begin.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 22 "/usr/local/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/traits_lambda_spec.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3


namespace boost { namespace mpl {


namespace aux {

template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};

}





template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};

template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
# 82 "/usr/local/include/boost/mpl/aux_/begin_end_impl.hpp" 3
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };




template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };







}}
# 19 "/usr/local/include/boost/mpl/begin_end.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/sequence_tag.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/sequence_tag.hpp" 3
namespace boost { namespace mpl {
# 78 "/usr/local/include/boost/mpl/sequence_tag.hpp" 3
namespace aux {

template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{


    template< typename Sequence > struct result2_;
};
# 98 "/usr/local/include/boost/mpl/sequence_tag.hpp" 3
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };



}

template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};



template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/begin_end.hpp" 2 3



namespace boost { namespace mpl {




template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }

}}
# 18 "/usr/local/include/boost/mpl/aux_/at_impl.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/advance.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/advance.hpp" 3
# 1 "/usr/local/include/boost/mpl/less.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/less.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less

    : less_impl<
          typename less_tag<N1>::type
        , typename less_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less< T1 , T2 > { }; }; template< typename Tag > struct lambda< less< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less< na , na > result_; typedef less< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N2::value > N1::value ) >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/less.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/advance.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/negate.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/negate.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct negate_impl;

template< typename T > struct negate_tag
{
    typedef typename T::tag type;
};

template<
      typename N = na
    >
struct negate

    : negate_impl<
          typename negate_tag<N>::type
        >::template apply<N>::type






{
   
};

template<> struct negate< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : negate< T1 > { }; }; template< typename Tag > struct lambda< negate< na > , Tag , int_<-1> > { typedef false_ is_le; typedef negate< na > result_; typedef negate< na > type; }; namespace aux { template< typename T1 > struct template_arity< negate< T1 > > : int_<1> { }; template<> struct template_arity< negate< na > > : int_<-1> { }; }
# 65 "/usr/local/include/boost/mpl/negate.hpp" 3
template<>
struct negate_impl<integral_c_tag>
{




    template< typename N > struct apply
        : integral_c< typename N::value_type, (-N::value) >

    {
    };
};

}}
# 20 "/usr/local/include/boost/mpl/advance.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/advance.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/advance_forward.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/advance_forward.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/aux_/advance_forward.hpp" 2 3
# 32 "/usr/local/include/boost/mpl/aux_/advance_forward.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_forward;
template<>
struct advance_forward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_forward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_forward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_forward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_forward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef typename next<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_forward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_forward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_forward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 33 "/usr/local/include/boost/mpl/aux_/advance_forward.hpp" 2 3
# 25 "/usr/local/include/boost/mpl/advance.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/advance_backward.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/advance_backward.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/aux_/advance_backward.hpp" 2 3
# 32 "/usr/local/include/boost/mpl/aux_/advance_backward.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_backward;
template<>
struct advance_backward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_backward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_backward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_backward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_backward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef typename prior<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_backward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_backward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_backward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 33 "/usr/local/include/boost/mpl/aux_/advance_backward.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/advance.hpp" 2 3




namespace boost { namespace mpl {


template< typename Tag >
struct advance_impl
{
    template< typename Iterator, typename N > struct apply
    {
        typedef typename less< N,long_<0> >::type backward_;
        typedef typename if_< backward_, negate<N>, N >::type offset_;

        typedef typename if_<
              backward_
            , aux::advance_backward< offset_::value >
            , aux::advance_forward< offset_::value >
            >::type f_;

        typedef typename apply_wrap1<f_,Iterator>::type type;
    };
};


template<
      typename Iterator = na
    , typename N = na
    >
struct advance
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,N>
{
};

template<
      typename Iterator
    , long N
    >
struct advance_c
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,long_<N> >
{
};

template<> struct advance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : advance< T1 , T2 > { }; }; template< typename Tag > struct lambda< advance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef advance< na , na > result_; typedef advance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< advance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< advance< na , na > > : int_<-1> { }; }

}}
# 19 "/usr/local/include/boost/mpl/aux_/at_impl.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/deref.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/deref.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/msvc_type.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/msvc_type.hpp" 3
namespace boost { namespace mpl { namespace aux {
# 48 "/usr/local/include/boost/mpl/aux_/msvc_type.hpp" 3
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};

template<> struct msvc_type<int>
{
    typedef int type;
};



}}}
# 18 "/usr/local/include/boost/mpl/deref.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct deref
{

    typedef typename Iterator::type type;



   
};

template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/aux_/at_impl.hpp" 2 3


namespace boost { namespace mpl {




template< typename Tag >
struct at_impl
{
    template< typename Sequence, typename N > struct apply
    {
        typedef typename advance<
              typename begin<Sequence>::type
            , N
            >::type iter_;

        typedef typename deref<iter_>::type type;
    };
};

 template<> struct at_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/at.hpp" 2 3






namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename N = na
    >
struct at
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,N >
{
   
};

template<
      typename Sequence
    , long N
    >
struct at_c
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,mpl::long_<N> >
{
};

template<> struct at< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : at< T1 , T2 > { }; }; template< typename Tag > struct lambda< at< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef at< na , na > result_; typedef at< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< at< T1 , T2 > > : int_<2> { }; template<> struct template_arity< at< na , na > > : int_<-1> { }; }

}}
# 21 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/size.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/size.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/size_impl.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/size_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/distance.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/distance.hpp" 3
# 1 "/usr/local/include/boost/mpl/iter_fold.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/iter_fold.hpp" 3
# 1 "/usr/local/include/boost/mpl/O1_size.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/O1_size.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/O1_size_impl.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/O1_size_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/has_size.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/has_size.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_size { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::size>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 21 "/usr/local/include/boost/mpl/aux_/O1_size_impl.hpp" 2 3





namespace boost { namespace mpl {
# 35 "/usr/local/include/boost/mpl/aux_/O1_size_impl.hpp" 3
namespace aux {
template< typename Sequence > struct O1_size_impl
    : Sequence::size
{
};
}

template< typename Tag >
struct O1_size_impl
{
    template< typename Sequence > struct apply

        : if_<
              aux::has_size<Sequence>
            , aux::O1_size_impl<Sequence>
            , long_<-1>
            >::type
    {
# 69 "/usr/local/include/boost/mpl/aux_/O1_size_impl.hpp" 3
    };
};
# 85 "/usr/local/include/boost/mpl/aux_/O1_size_impl.hpp" 3
}}
# 20 "/usr/local/include/boost/mpl/O1_size.hpp" 2 3



namespace boost { namespace mpl {


template<
      typename Sequence = na
    >
struct O1_size
    : O1_size_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct O1_size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : O1_size< T1 > { }; }; template< typename Tag > struct lambda< O1_size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef O1_size< na > result_; typedef O1_size< na > type; }; namespace aux { template< typename T1 > struct template_arity< O1_size< T1 > > : int_<1> { }; template<> struct template_arity< O1_size< na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/iter_fold.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/iter_fold_impl.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/iter_fold_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/iter_fold_impl.hpp" 2 3
# 33 "/usr/local/include/boost/mpl/aux_/iter_fold_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 3
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,state3,iter3 >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl
{
    typedef iter_fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef iter_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,First,Last,State,ForwardOp >
    : iter_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2< ForwardOp,State,First >::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 34 "/usr/local/include/boost/mpl/aux_/iter_fold_impl.hpp" 2 3
# 22 "/usr/local/include/boost/mpl/iter_fold.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct iter_fold
{
    typedef typename aux::iter_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , typename lambda<ForwardOp>::type
        >::state type;

   
};

template<> struct iter_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : iter_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< iter_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold< na , na , na > result_; typedef iter_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< iter_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< iter_fold< na , na , na > > : int_<-1> { }; }

}}
# 19 "/usr/local/include/boost/mpl/distance.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/iterator_range.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/iterator_range.hpp" 3
namespace boost { namespace mpl {

struct iterator_range_tag;

template<
      typename First = na
    , typename Last = na
    >
struct iterator_range
{
    typedef iterator_range_tag tag;
    typedef iterator_range type;
    typedef First begin;
    typedef Last end;

   
};

template<> struct iterator_range< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : iterator_range< T1 , T2 > { }; }; template< typename Tag > struct lambda< iterator_range< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iterator_range< na , na > result_; typedef iterator_range< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< iterator_range< T1 , T2 > > : int_<2> { }; template<> struct template_arity< iterator_range< na , na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/distance.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 24 "/usr/local/include/boost/mpl/distance.hpp" 2 3







namespace boost { namespace mpl {


template< typename Tag > struct distance_impl
{
    template< typename First, typename Last > struct apply

        : aux::msvc_eti_base< typename iter_fold<
              iterator_range<First,Last>
            , mpl::long_<0>
            , next<>
            >::type >
    {
# 60 "/usr/local/include/boost/mpl/distance.hpp" 3
    };
};

template<
      typename First = na
    , typename Last = na
    >
struct distance
    : distance_impl< typename tag<First>::type >
        ::template apply<First, Last>
{
   
};

template<> struct distance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : distance< T1 , T2 > { }; }; template< typename Tag > struct lambda< distance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef distance< na , na > result_; typedef distance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< distance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< distance< na , na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/aux_/size_impl.hpp" 2 3



namespace boost { namespace mpl {




template< typename Tag >
struct size_impl
{
    template< typename Sequence > struct apply

        : distance<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {







    };
};

 template<> struct size_impl<non_sequence_tag> {};

}}
# 20 "/usr/local/include/boost/mpl/size.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct size
    : aux::msvc_eti_base<
        typename size_impl< typename sequence_tag<Sequence>::type >
            ::template apply< Sequence >::type
      >::type
{
   
};

template<> struct size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : size< T1 > { }; }; template< typename Tag > struct lambda< size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef size< na > result_; typedef size< na > type; }; namespace aux { template< typename T1 > struct template_arity< size< T1 > > : int_<1> { }; template<> struct template_arity< size< na > > : int_<-1> { }; }

}}
# 22 "/usr/local/include/boost/python/detail/signature.hpp" 2 3

namespace boost { namespace python { namespace detail {

struct signature_element
{
    char const* basename;
    converter::pytype_function pytype_f;
    bool lvalue;
};

struct py_func_sig_info
{
    signature_element const *signature;
    signature_element const *ret;
};

template <unsigned> struct signature_arity;



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<0>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[0 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<1>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[1 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<2>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[2 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<3>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[3 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<4>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[4 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<5>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[5 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<6>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[6 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<7>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[7 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<8>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[8 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<9>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[9 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<10>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[10 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<11>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[11 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },


        { type_id<typename mpl::at_c<Sig,11>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,11>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,11>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<12>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[12 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },


        { type_id<typename mpl::at_c<Sig,11>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,11>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,11>::type>::value },


        { type_id<typename mpl::at_c<Sig,12>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,12>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,12>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<13>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[13 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },


        { type_id<typename mpl::at_c<Sig,11>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,11>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,11>::type>::value },


        { type_id<typename mpl::at_c<Sig,12>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,12>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,12>::type>::value },


        { type_id<typename mpl::at_c<Sig,13>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,13>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,13>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<14>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[14 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },


        { type_id<typename mpl::at_c<Sig,11>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,11>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,11>::type>::value },


        { type_id<typename mpl::at_c<Sig,12>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,12>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,12>::type>::value },


        { type_id<typename mpl::at_c<Sig,13>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,13>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,13>::type>::value },


        { type_id<typename mpl::at_c<Sig,14>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,14>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,14>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<15>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[15 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },


        { type_id<typename mpl::at_c<Sig,11>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,11>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,11>::type>::value },


        { type_id<typename mpl::at_c<Sig,12>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,12>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,12>::type>::value },


        { type_id<typename mpl::at_c<Sig,13>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,13>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,13>::type>::value },


        { type_id<typename mpl::at_c<Sig,14>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,14>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,14>::type>::value },


        { type_id<typename mpl::at_c<Sig,15>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,15>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,15>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/signature.hpp" 3
template <>
struct signature_arity<16>
{
    template <class Sig>
    struct impl
    {
        static signature_element const* elements()
        {
            static signature_element const result[16 +2] = {
# 96 "/usr/local/include/boost/python/detail/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        { type_id<typename mpl::at_c<Sig,0>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,0>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,0>::type>::value },


        { type_id<typename mpl::at_c<Sig,1>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,1>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,1>::type>::value },


        { type_id<typename mpl::at_c<Sig,2>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,2>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,2>::type>::value },


        { type_id<typename mpl::at_c<Sig,3>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,3>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,3>::type>::value },


        { type_id<typename mpl::at_c<Sig,4>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,4>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,4>::type>::value },


        { type_id<typename mpl::at_c<Sig,5>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,5>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,5>::type>::value },


        { type_id<typename mpl::at_c<Sig,6>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,6>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,6>::type>::value },


        { type_id<typename mpl::at_c<Sig,7>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,7>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,7>::type>::value },


        { type_id<typename mpl::at_c<Sig,8>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,8>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,8>::type>::value },


        { type_id<typename mpl::at_c<Sig,9>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,9>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,9>::type>::value },


        { type_id<typename mpl::at_c<Sig,10>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,10>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,10>::type>::value },


        { type_id<typename mpl::at_c<Sig,11>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,11>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,11>::type>::value },


        { type_id<typename mpl::at_c<Sig,12>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,12>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,12>::type>::value },


        { type_id<typename mpl::at_c<Sig,13>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,13>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,13>::type>::value },


        { type_id<typename mpl::at_c<Sig,14>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,14>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,14>::type>::value },


        { type_id<typename mpl::at_c<Sig,15>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,15>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,15>::type>::value },


        { type_id<typename mpl::at_c<Sig,16>::type>().name() , &converter::expected_pytype_for_arg<typename mpl::at_c<Sig,16>::type>::get_pytype , indirect_traits::is_reference_to_non_const<typename mpl::at_c<Sig,16>::type>::value },
# 97 "/usr/local/include/boost/python/detail/signature.hpp" 2 3
                {0,0,0}
            };
            return result;
        }
    };
};
# 128 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 43 "/usr/local/include/boost/python/detail/signature.hpp" 2 3





template <class Sig>
struct signature_base_select
{
    enum { arity = mpl::size<Sig>::value - 1 };
    typedef typename signature_arity<arity>::template impl<Sig> type;
};

template <class Sig>
struct signature
    : signature_base_select<Sig>::type
{
};

}}}
# 18 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



# 1 "/usr/local/include/boost/python/arg_from_python.hpp" 1 3
# 9 "/usr/local/include/boost/python/arg_from_python.hpp" 3
# 1 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 1 3
# 9 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 3
# 1 "/usr/local/include/boost/python/converter/from_python.hpp" 1 3
# 11 "/usr/local/include/boost/python/converter/from_python.hpp" 3
namespace boost { namespace python { namespace converter {

struct registration;


 void* get_lvalue_from_python(
    PyObject* source, registration const&);

 bool implicit_rvalue_convertible_from_python(
    PyObject* source, registration const&);

 rvalue_from_python_stage1_data rvalue_from_python_stage1(
    PyObject* source, registration const&);

 void* rvalue_from_python_stage2(
    PyObject* source, rvalue_from_python_stage1_data&, registration const&);

 void* rvalue_result_from_python(
    PyObject*, rvalue_from_python_stage1_data&);

 void* reference_result_from_python(PyObject*, registration const&);
 void* pointer_result_from_python(PyObject*, registration const&);

 void void_result_from_python(PyObject*);

 void throw_no_pointer_from_python(PyObject*, registration const&);
 void throw_no_reference_from_python(PyObject*, registration const&);

}}}
# 10 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 2 3





# 1 "/usr/local/include/boost/mpl/identity.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/identity.hpp" 3
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 16 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/and.hpp" 1 3
# 42 "/usr/local/include/boost/mpl/and.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 43 "/usr/local/include/boost/mpl/and.hpp" 2 3
# 17 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 2 3





# 1 "/usr/local/include/boost/python/detail/void_ptr.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/void_ptr.hpp" 3
namespace boost { namespace python { namespace detail {

template <class U>
inline U& void_ptr_to_reference(void const volatile* p, U&(*)())
{
    return *(U*)p;
}

template <class T>
inline void write_void_ptr(void const volatile* storage, void* ptr, T*)
{
    *(T**)storage = (T*)ptr;
}


template <class U>
inline void write_void_ptr_reference(void const volatile* storage, void* ptr, U&(*)())
{

    typedef typename remove_cv<U>::type u_stripped;
    write_void_ptr(storage, ptr, u_stripped(0));
}

}}}
# 23 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 2 3
# 1 "/usr/local/include/boost/python/back_reference.hpp" 1 3
# 10 "/usr/local/include/boost/python/back_reference.hpp" 3
# 1 "/usr/local/include/boost/python/object_fwd.hpp" 1 3
# 10 "/usr/local/include/boost/python/object_fwd.hpp" 3
namespace boost { namespace python {
namespace api
{
  class object;
}
using api::object;
}}
# 11 "/usr/local/include/boost/python/back_reference.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/dependent.hpp" 1 3







namespace boost { namespace python { namespace detail {
# 19 "/usr/local/include/boost/python/detail/dependent.hpp" 3
template <class T, class U>
struct dependent
{
    typedef T type;
};

}}}
# 12 "/usr/local/include/boost/python/back_reference.hpp" 2 3


namespace boost { namespace python {

template <class T>
struct back_reference
{
 private:
    typedef typename detail::dependent<object,T>::type source_t;
 public:
    typedef T type;

    back_reference(PyObject*, T);
    source_t const& source() const;
    T get() const;
 private:
    source_t m_source;
    T m_value;
};

template<typename T>
class is_back_reference
{
 public:
    static const bool value = false;
};

template<typename T>
class is_back_reference<back_reference<T> >
{
 public:
    static const bool value = true;
};





template <class T>
back_reference<T>::back_reference(PyObject* p, T x)
    : m_source(detail::borrowed_reference(p))
      , m_value(x)
{
}

template <class T>
typename back_reference<T>::source_t const& back_reference<T>::source() const
{
    return m_source;
}

template <class T>
T back_reference<T>::get() const
{
    return m_value;
}

}}
# 24 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 2 3

# 1 "/usr/local/include/boost/python/converter/obj_mgr_arg_from_python.hpp" 1 3
# 11 "/usr/local/include/boost/python/converter/obj_mgr_arg_from_python.hpp" 3
# 1 "/usr/local/include/boost/python/detail/construct.hpp" 1 3







namespace boost { namespace python { namespace detail {

template <class T, class Arg>
void construct_pointee(void* storage, Arg& x, T const volatile*)
{
    new (storage) T(x);
}

template <class T, class Arg>
void construct_referent_impl(void* storage, Arg& x, T&(*)())
{
    construct_pointee(storage, x, (T*)0);
}

template <class T, class Arg>
void construct_referent(void* storage, Arg const& x, T(*tag)() = 0)
{
    construct_referent_impl(storage, x, tag);
}

template <class T, class Arg>
void construct_referent(void* storage, Arg& x, T(*tag)() = 0)
{
    construct_referent_impl(storage, x, tag);
}

}}}
# 12 "/usr/local/include/boost/python/converter/obj_mgr_arg_from_python.hpp" 2 3
# 20 "/usr/local/include/boost/python/converter/obj_mgr_arg_from_python.hpp" 3
namespace boost { namespace python { namespace converter {

template <class T>
struct object_manager_value_arg_from_python
{
    typedef T result_type;

    object_manager_value_arg_from_python(PyObject*);
    bool convertible() const;
    T operator()() const;
 private:
    PyObject* m_source;
};
# 43 "/usr/local/include/boost/python/converter/obj_mgr_arg_from_python.hpp" 3
template <class Ref>
struct object_manager_ref_arg_from_python
{
    typedef Ref result_type;

    object_manager_ref_arg_from_python(PyObject*);
    bool convertible() const;
    Ref operator()() const;
    ~object_manager_ref_arg_from_python();
 private:
    typename python::detail::referent_storage<Ref>::type m_result;
};





template <class T>
inline object_manager_value_arg_from_python<T>::object_manager_value_arg_from_python(PyObject* x)
    : m_source(x)
{
}

template <class T>
inline bool object_manager_value_arg_from_python<T>::convertible() const
{
    return object_manager_traits<T>::check(m_source);
}

template <class T>
inline T object_manager_value_arg_from_python<T>::operator()() const
{
    return T(python::detail::borrowed_reference(m_source));
}

template <class Ref>
inline object_manager_ref_arg_from_python<Ref>::object_manager_ref_arg_from_python(PyObject* x)
{





    python::detail::construct_referent<Ref>(&m_result.bytes, (python::detail::borrowed_reference)x);

}

template <class Ref>
inline object_manager_ref_arg_from_python<Ref>::~object_manager_ref_arg_from_python()
{
    python::detail::destroy_referent<Ref>(this->m_result.bytes);
}

namespace detail
{
  template <class T>
  inline bool object_manager_ref_check(T const& x)
  {
      return object_manager_traits<T>::check(get_managed_object(x, tag));
  }
}

template <class Ref>
inline bool object_manager_ref_arg_from_python<Ref>::convertible() const
{
    return detail::object_manager_ref_check(
        python::detail::void_ptr_to_reference(this->m_result.bytes, (Ref(*)())0));
}

template <class Ref>
inline Ref object_manager_ref_arg_from_python<Ref>::operator()() const
{
    return python::detail::void_ptr_to_reference(
        this->m_result.bytes, (Ref(*)())0);
}

}}}
# 26 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 2 3

namespace boost { namespace python
{
  template <class T> struct arg_from_python;
}}




namespace boost { namespace python { namespace converter {
# 44 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 3
template <class T>
struct pointer_cref_arg_from_python
{
    typedef T result_type;

    pointer_cref_arg_from_python(PyObject*);
    T operator()() const;
    bool convertible() const;

 private:


    typename python::detail::referent_storage<T>::type m_result;
};


struct arg_lvalue_from_python_base
{
 public:
    arg_lvalue_from_python_base(void* result);
    bool convertible() const;

 protected:
    void*const& result() const;

 private:
    void* m_result;
};


template <class T>
struct pointer_arg_from_python : arg_lvalue_from_python_base
{
    typedef T result_type;

    pointer_arg_from_python(PyObject*);
    T operator()() const;
};


template <class T>
struct reference_arg_from_python : arg_lvalue_from_python_base
{
    typedef T result_type;

    reference_arg_from_python(PyObject*);
    T operator()() const;
};
# 105 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 3
template <class T>
struct arg_rvalue_from_python
{
    typedef typename boost::python::detail::add_lvalue_reference<
        T


    >::type result_type;

    arg_rvalue_from_python(PyObject*);
    bool convertible() const;




    result_type operator()();

 private:
    rvalue_from_python_data<result_type> m_data;
    PyObject* m_source;
};






template <class T>
struct back_reference_arg_from_python
    : boost::python::arg_from_python<typename T::type>
{
    typedef T result_type;

    back_reference_arg_from_python(PyObject*);
    T operator()();
 private:
    typedef boost::python::arg_from_python<typename T::type> base;
    PyObject* m_source;
};




template <class C, class T, class F>
struct if_2
{
    typedef typename mpl::eval_if<C, mpl::identity<T>, F>::type type;
};



template <class T>
struct select_arg_from_python
{
    typedef typename if_2<
        is_object_manager<T>
      , object_manager_value_arg_from_python<T>
      , if_2<
            is_reference_to_object_manager<T>
          , object_manager_ref_arg_from_python<T>
          , if_2<
                is_pointer<T>
              , pointer_arg_from_python<T>
              , if_2<
                    mpl::and_<
                        indirect_traits::is_reference_to_pointer<T>
                      , indirect_traits::is_reference_to_const<T>
                      , mpl::not_<indirect_traits::is_reference_to_volatile<T> >
                        >
                  , pointer_cref_arg_from_python<T>
                  , if_2<
                        mpl::or_<
                            indirect_traits::is_reference_to_non_const<T>
                          , indirect_traits::is_reference_to_volatile<T>
                        >
                      , reference_arg_from_python<T>
                      , mpl::if_<
                            boost::python::is_back_reference<T>
                          , back_reference_arg_from_python<T>
                          , arg_rvalue_from_python<T>
                        >
                    >
                >
            >
        >
    >::type type;
};
# 201 "/usr/local/include/boost/python/converter/arg_from_python.hpp" 3
inline arg_lvalue_from_python_base::arg_lvalue_from_python_base(void* result)
    : m_result(result)
{
}

inline bool arg_lvalue_from_python_base::convertible() const
{
    return m_result != 0;
}

inline void*const& arg_lvalue_from_python_base::result() const
{
    return m_result;
}



namespace detail
{



  template <class T>
  struct null_ptr_owner
  {
      static T value;
  };
  template <class T> T null_ptr_owner<T>::value = 0;

  template <class U>
  inline U& null_ptr_reference(U&(*)())
  {
      return null_ptr_owner<U>::value;
  }
}

template <class T>
inline pointer_cref_arg_from_python<T>::pointer_cref_arg_from_python(PyObject* p)
{



    python::detail::write_void_ptr_reference(
        m_result.bytes
        , p == (&_Py_NoneStruct) ? p : converter::get_lvalue_from_python(p, registered_pointee<T>::converters)
        , (T(*)())0);
}

template <class T>
inline bool pointer_cref_arg_from_python<T>::convertible() const
{
    return python::detail::void_ptr_to_reference(m_result.bytes, (T(*)())0) != 0;
}
template <class T>
inline T pointer_cref_arg_from_python<T>::operator()() const
{
    return (*(void**)m_result.bytes == (&_Py_NoneStruct))
        ? detail::null_ptr_reference((T(*)())0)

        : python::detail::void_ptr_to_reference(m_result.bytes, (T(*)())0);
}



template <class T>
inline pointer_arg_from_python<T>::pointer_arg_from_python(PyObject* p)
    : arg_lvalue_from_python_base(
        p == (&_Py_NoneStruct) ? p : converter::get_lvalue_from_python(p, registered_pointee<T>::converters))
{
}

template <class T>
inline T pointer_arg_from_python<T>::operator()() const
{
    return (result() == (&_Py_NoneStruct)) ? 0 : T(result());
}



template <class T>
inline reference_arg_from_python<T>::reference_arg_from_python(PyObject* p)
    : arg_lvalue_from_python_base(converter::get_lvalue_from_python(p,registered<T>::converters))
{
}

template <class T>
inline T reference_arg_from_python<T>::operator()() const
{
    return python::detail::void_ptr_to_reference(result(), (T(*)())0);
}




template <class T>
inline arg_rvalue_from_python<T>::arg_rvalue_from_python(PyObject* obj)
    : m_data(converter::rvalue_from_python_stage1(obj, registered<T>::converters))
    , m_source(obj)
{
}

template <class T>
inline bool arg_rvalue_from_python<T>::convertible() const
{
    return m_data.stage1.convertible != 0;
}

template <class T>
inline typename arg_rvalue_from_python<T>::result_type
arg_rvalue_from_python<T>::operator()()
{
    if (m_data.stage1.construct != 0)
        m_data.stage1.construct(m_source, &m_data.stage1);

    return python::detail::void_ptr_to_reference(m_data.stage1.convertible, (result_type(*)())0);
}



template <class T>
back_reference_arg_from_python<T>::back_reference_arg_from_python(PyObject* x)
  : base(x), m_source(x)
{
}

template <class T>
inline T
back_reference_arg_from_python<T>::operator()()
{
    return T(m_source, base::operator()());
}

}}}
# 10 "/usr/local/include/boost/python/arg_from_python.hpp" 2 3





namespace boost { namespace python {

template <class T>
struct arg_from_python
    : converter::select_arg_from_python<




          T

      >::type
{
    typedef typename converter::select_arg_from_python<




          T

        >::type base;

    arg_from_python(PyObject*);
};


template <>
struct arg_from_python<PyObject*>
{
    typedef PyObject* result_type;

    arg_from_python(PyObject* p) : m_source(p) {}
    bool convertible() const { return true; }
    PyObject* operator()() const { return m_source; }
 private:
    PyObject* m_source;
};

template <>
struct arg_from_python<PyObject* const&>
{
    typedef PyObject* const& result_type;

    arg_from_python(PyObject* p) : m_source(p) {}
    bool convertible() const { return true; }
    PyObject*const& operator()() const { return m_source; }
 private:
    PyObject* m_source;
};




template <class T>
inline arg_from_python<T>::arg_from_python(PyObject* source)
    : base(source)
{
}

}}
# 22 "/usr/local/include/boost/python/detail/caller.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/context_result_converter.hpp" 1 3







namespace boost { namespace python { namespace converter {




struct context_result_converter {};

}}}
# 23 "/usr/local/include/boost/python/detail/caller.hpp" 2 3




# 1 "/usr/local/include/boost/preprocessor/dec.hpp" 1 3
# 28 "/usr/local/include/boost/python/detail/caller.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/if.hpp" 1 3
# 29 "/usr/local/include/boost/python/detail/caller.hpp" 2 3




# 1 "/usr/local/include/boost/compressed_pair.hpp" 1 3
# 18 "/usr/local/include/boost/compressed_pair.hpp" 3
# 1 "/usr/local/include/boost/detail/compressed_pair.hpp" 1 3
# 26 "/usr/local/include/boost/detail/compressed_pair.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_empty.hpp" 1 3
# 12 "/usr/local/include/boost/type_traits/is_empty.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_convertible.hpp" 1 3
# 28 "/usr/local/include/boost/type_traits/is_convertible.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_abstract.hpp" 1 3
# 63 "/usr/local/include/boost/type_traits/is_abstract.hpp" 3
namespace boost {

namespace detail{


template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
# 140 "/usr/local/include/boost/type_traits/is_abstract.hpp" 3
}


template <class T> struct is_abstract : public integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value> {};




}
# 29 "/usr/local/include/boost/type_traits/is_convertible.hpp" 2 3

# 1 "/usr/local/include/boost/type_traits/add_lvalue_reference.hpp" 1 3
# 9 "/usr/local/include/boost/type_traits/add_lvalue_reference.hpp" 3
# 1 "/usr/local/include/boost/type_traits/add_reference.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/add_reference.hpp" 3
namespace boost {

namespace detail {






template <typename T>
struct add_reference_impl
{
    typedef T& type;
};


template <typename T>
struct add_reference_impl<T&&>
{
    typedef T&& type;
};


}

template <class T> struct add_reference
{
   typedef typename boost::detail::add_reference_impl<T>::type type;
};
template <class T> struct add_reference<T&>
{
   typedef T& type;
};


template <> struct add_reference<void> { typedef void type; };

template <> struct add_reference<const void> { typedef const void type; };
template <> struct add_reference<const volatile void> { typedef const volatile void type; };
template <> struct add_reference<volatile void> { typedef volatile void type; };




template <class T> using add_reference_t = typename add_reference<T>::type;




}
# 10 "/usr/local/include/boost/type_traits/add_lvalue_reference.hpp" 2 3

namespace boost{

template <class T> struct add_lvalue_reference
{
   typedef typename boost::add_reference<T>::type type;
};


template <class T> struct add_lvalue_reference<T&&>
{
   typedef T& type;
};




   template <class T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;



}
# 31 "/usr/local/include/boost/type_traits/is_convertible.hpp" 2 3
# 45 "/usr/local/include/boost/type_traits/is_convertible.hpp" 3
namespace boost {
# 59 "/usr/local/include/boost/type_traits/is_convertible.hpp" 3
namespace detail {







   template <class A, class B, class C>
   struct or_helper
   {
      static const bool value = (A::value || B::value || C::value);
   };

   template<typename From, typename To, bool b = or_helper<boost::is_void<From>, boost::is_function<To>, boost::is_array<To> >::value>
   struct is_convertible_basic_impl
   {

      static const bool value = is_void<To>::value;
   };

   template<typename From, typename To>
   class is_convertible_basic_impl<From, To, false>
   {
      typedef char one;
      typedef int two;

      template<typename To1>
      static void test_aux(To1);

      template<typename From1, typename To1>
      static decltype(test_aux<To1>(boost::declval<From1>()), one()) test(int);

      template<typename, typename>
      static two test(...);

   public:
      static const bool value = sizeof(test<From, To>(0)) == 1;
   };
# 362 "/usr/local/include/boost/type_traits/is_convertible.hpp" 3
template <typename From, typename To>
struct is_convertible_impl
{
   static const bool value = ( ::boost::detail::is_convertible_basic_impl<From, To>::value && !::boost::is_array<To>::value && !::boost::is_function<To>::value);
};


template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};

template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};

template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{

   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,




      false

   > selector;



   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};

template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
# 442 "/usr/local/include/boost/type_traits/is_convertible.hpp" 3
template <> struct is_convertible_impl_dispatch<void, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void, void volatile> : public true_type{};

template <> struct is_convertible_impl_dispatch<void const, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const, void volatile> : public true_type{};

template <> struct is_convertible_impl_dispatch<void const volatile, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const volatile, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const volatile, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const volatile, void volatile> : public true_type{};

template <> struct is_convertible_impl_dispatch<void volatile, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void volatile, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void volatile, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void volatile, void volatile> : public true_type{};





template <class To> struct is_convertible_impl_dispatch<void, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void> : public false_type{};


template <class To> struct is_convertible_impl_dispatch<void const, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void const> : public false_type{};
template <class To> struct is_convertible_impl_dispatch<void const volatile, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void const volatile> : public false_type{};
template <class To> struct is_convertible_impl_dispatch<void volatile, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void volatile> : public false_type{};


}

template <class From, class To>
struct is_convertible : public integral_constant<bool, ::boost::detail::is_convertible_impl_dispatch<From, To>::value>
{
   static_assert(boost::is_complete<To>::value || boost::is_void<To>::value || boost::is_array<To>::value, "Destination argument type to is_convertible must be a complete type");
   static_assert(boost::is_complete<From>::value || boost::is_void<From>::value || boost::is_array<From>::value, "From argument type to is_convertible must be a complete type");
};
# 504 "/usr/local/include/boost/type_traits/is_convertible.hpp" 3
}
# 13 "/usr/local/include/boost/type_traits/is_empty.hpp" 2 3
# 26 "/usr/local/include/boost/type_traits/is_empty.hpp" 3
namespace boost {

namespace detail {







template <typename T>
struct empty_helper_t1 : public T
{
    empty_helper_t1();
    int i[256];
private:

   empty_helper_t1(const empty_helper_t1&);
   empty_helper_t1& operator=(const empty_helper_t1&);
};





struct empty_helper_t2 { int i[256]; };



template <typename T, bool is_a_class = false>
struct empty_helper
{
    static const bool value = false;
};

template <typename T>
struct empty_helper<T, true>
{
    static const bool value = (sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2))

         ;
};

template <typename T>
struct is_empty_impl
{
    typedef typename remove_cv<T>::type cvt;
    static const bool value = ( ::boost::detail::empty_helper<cvt,::boost::is_class<T>::value>::value || false)

                                                                                                                         ;
};
# 111 "/usr/local/include/boost/type_traits/is_empty.hpp" 3
}

template <class T> struct is_empty : integral_constant<bool, ::boost::detail::is_empty_impl<T>::value> {};

}
# 27 "/usr/local/include/boost/detail/compressed_pair.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_final.hpp" 1 3
# 20 "/usr/local/include/boost/type_traits/is_final.hpp" 3
namespace boost {


template <class T> struct is_final : public integral_constant<bool, __is_final(T)> {};




}
# 28 "/usr/local/include/boost/detail/compressed_pair.hpp" 2 3

# 1 "/usr/local/include/boost/call_traits.hpp" 1 3
# 18 "/usr/local/include/boost/call_traits.hpp" 3
# 1 "/usr/local/include/boost/detail/call_traits.hpp" 1 3
# 31 "/usr/local/include/boost/detail/call_traits.hpp" 3
namespace boost{

namespace detail{

template <typename T, bool small_>
struct ct_imp2
{
   typedef const T& param_type;
};

template <typename T>
struct ct_imp2<T, true>
{
   typedef const T param_type;
};

template <typename T, bool isp, bool b1, bool b2>
struct ct_imp
{
   typedef const T& param_type;
};

template <typename T, bool isp, bool b2>
struct ct_imp<T, isp, true, b2>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};

template <typename T, bool isp, bool b1>
struct ct_imp<T, isp, b1, true>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};

template <typename T, bool b1, bool b2>
struct ct_imp<T, true, b1, b2>
{
   typedef const T param_type;
};

}

template <typename T>
struct call_traits
{
public:
   typedef T value_type;
   typedef T& reference;
   typedef const T& const_reference;






   typedef typename boost::detail::ct_imp<
      T,
      ::boost::is_pointer<T>::value,
      ::boost::is_arithmetic<T>::value,
      ::boost::is_enum<T>::value
   >::param_type param_type;
};

template <typename T>
struct call_traits<T&>
{
   typedef T& value_type;
   typedef T& reference;
   typedef const T& const_reference;
   typedef T& param_type;
};
# 143 "/usr/local/include/boost/detail/call_traits.hpp" 3
template <typename T, std::size_t BOOST_PP_ITERATION_0>
struct call_traits<T [BOOST_PP_ITERATION_0]>
{
private:
   typedef T array_type[BOOST_PP_ITERATION_0];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};

template <typename T, std::size_t BOOST_PP_ITERATION_0>
struct call_traits<const T [BOOST_PP_ITERATION_0]>
{
private:
   typedef const T array_type[BOOST_PP_ITERATION_0];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};


}
# 19 "/usr/local/include/boost/call_traits.hpp" 2 3
# 30 "/usr/local/include/boost/detail/compressed_pair.hpp" 2 3





namespace boost
{

template <class T1, class T2>
class compressed_pair;




namespace details
{
   template<class T, bool E = boost::is_final<T>::value>
   struct compressed_pair_empty
      : ::boost::false_type { };

   template<class T>
   struct compressed_pair_empty<T, false>
      : ::boost::is_empty<T> { };


   template <class T1, class T2, bool IsSame, bool FirstEmpty, bool SecondEmpty>
   struct compressed_pair_switch;

   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, false, false>
      {static const int value = 0;};

   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, true, true>
      {static const int value = 3;};

   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, true, false>
      {static const int value = 1;};

   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, false, true>
      {static const int value = 2;};

   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, true, true, true>
      {static const int value = 4;};

   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, true, false, false>
      {static const int value = 5;};

   template <class T1, class T2, int Version> class compressed_pair_imp;



   using std::swap;






   template <typename T>
   inline void cp_swap(T& t1, T& t2)
   {



      swap(t1, t2);
   }



   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 0>
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;

      compressed_pair_imp() {}

      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_(x), second_(y) {}

      compressed_pair_imp(first_param_type x)
         : first_(x) {}

      compressed_pair_imp(second_param_type y)
         : second_(y) {}

      first_reference first() {return first_;}
      first_const_reference first() const {return first_;}

      second_reference second() {return second_;}
      second_const_reference second() const {return second_;}

      void swap(::boost::compressed_pair<T1, T2>& y)
      {
         cp_swap(first_, y.first());
         cp_swap(second_, y.second());
      }
   private:
      first_type first_;
      second_type second_;
   };



   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 1>
      : protected ::boost::remove_cv<T1>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;

      compressed_pair_imp() {}

      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_type(x), second_(y) {}

      compressed_pair_imp(first_param_type x)
         : first_type(x) {}

      compressed_pair_imp(second_param_type y)
         : second_(y) {}

      first_reference first() {return *this;}
      first_const_reference first() const {return *this;}

      second_reference second() {return second_;}
      second_const_reference second() const {return second_;}

      void swap(::boost::compressed_pair<T1,T2>& y)
      {

         cp_swap(second_, y.second());
      }
   private:
      second_type second_;
   };



   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 2>
      : protected ::boost::remove_cv<T2>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;

      compressed_pair_imp() {}

      compressed_pair_imp(first_param_type x, second_param_type y)
         : second_type(y), first_(x) {}

      compressed_pair_imp(first_param_type x)
         : first_(x) {}

      compressed_pair_imp(second_param_type y)
         : second_type(y) {}

      first_reference first() {return first_;}
      first_const_reference first() const {return first_;}

      second_reference second() {return *this;}
      second_const_reference second() const {return *this;}

      void swap(::boost::compressed_pair<T1,T2>& y)
      {

         cp_swap(first_, y.first());
      }

   private:
      first_type first_;
   };



   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 3>
      : protected ::boost::remove_cv<T1>::type,
        protected ::boost::remove_cv<T2>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;

      compressed_pair_imp() {}

      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_type(x), second_type(y) {}

      compressed_pair_imp(first_param_type x)
         : first_type(x) {}

      compressed_pair_imp(second_param_type y)
         : second_type(y) {}

      first_reference first() {return *this;}
      first_const_reference first() const {return *this;}

      second_reference second() {return *this;}
      second_const_reference second() const {return *this;}


      void swap(::boost::compressed_pair<T1,T2>&) {}
   };
# 274 "/usr/local/include/boost/detail/compressed_pair.hpp" 3
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 4>
      : protected ::boost::remove_cv<T1>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;

      compressed_pair_imp() {}

      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_type(x), m_second(y) {}

      compressed_pair_imp(first_param_type x)
         : first_type(x), m_second(x) {}

      first_reference first() {return *this;}
      first_const_reference first() const {return *this;}

      second_reference second() {return m_second;}
      second_const_reference second() const {return m_second;}

      void swap(::boost::compressed_pair<T1,T2>&) {}
   private:
      T2 m_second;
   };



   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 5>
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;

      compressed_pair_imp() {}

      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_(x), second_(y) {}

      compressed_pair_imp(first_param_type x)
         : first_(x), second_(x) {}

      first_reference first() {return first_;}
      first_const_reference first() const {return first_;}

      second_reference second() {return second_;}
      second_const_reference second() const {return second_;}

      void swap(::boost::compressed_pair<T1, T2>& y)
      {
         cp_swap(first_, y.first());
         cp_swap(second_, y.second());
      }
   private:
      first_type first_;
      second_type second_;
   };

}

template <class T1, class T2>
class compressed_pair
   : private ::boost::details::compressed_pair_imp<T1, T2,
             ::boost::details::compressed_pair_switch<
                    T1,
                    T2,
                    ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
                    ::boost::details::compressed_pair_empty<T1>::value,
                    ::boost::details::compressed_pair_empty<T2>::value>::value>
{
private:
   typedef details::compressed_pair_imp<T1, T2,
             ::boost::details::compressed_pair_switch<
                    T1,
                    T2,
                    ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
                    ::boost::details::compressed_pair_empty<T1>::value,
                    ::boost::details::compressed_pair_empty<T2>::value>::value> base;
public:
   typedef T1 first_type;
   typedef T2 second_type;
   typedef typename call_traits<first_type>::param_type first_param_type;
   typedef typename call_traits<second_type>::param_type second_param_type;
   typedef typename call_traits<first_type>::reference first_reference;
   typedef typename call_traits<second_type>::reference second_reference;
   typedef typename call_traits<first_type>::const_reference first_const_reference;
   typedef typename call_traits<second_type>::const_reference second_const_reference;

            compressed_pair() : base() {}
            compressed_pair(first_param_type x, second_param_type y) : base(x, y) {}
   explicit compressed_pair(first_param_type x) : base(x) {}
   explicit compressed_pair(second_param_type y) : base(y) {}

   first_reference first() {return base::first();}
   first_const_reference first() const {return base::first();}

   second_reference second() {return base::second();}
   second_const_reference second() const {return base::second();}

   void swap(compressed_pair& y) { base::swap(y); }
};




template <class T>
class compressed_pair<T, T>
   : private details::compressed_pair_imp<T, T,
             ::boost::details::compressed_pair_switch<
                    T,
                    T,
                    ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
                    ::boost::details::compressed_pair_empty<T>::value,
                    ::boost::details::compressed_pair_empty<T>::value>::value>
{
private:
   typedef details::compressed_pair_imp<T, T,
             ::boost::details::compressed_pair_switch<
                    T,
                    T,
                    ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
                    ::boost::details::compressed_pair_empty<T>::value,
                    ::boost::details::compressed_pair_empty<T>::value>::value> base;
public:
   typedef T first_type;
   typedef T second_type;
   typedef typename call_traits<first_type>::param_type first_param_type;
   typedef typename call_traits<second_type>::param_type second_param_type;
   typedef typename call_traits<first_type>::reference first_reference;
   typedef typename call_traits<second_type>::reference second_reference;
   typedef typename call_traits<first_type>::const_reference first_const_reference;
   typedef typename call_traits<second_type>::const_reference second_const_reference;

            compressed_pair() : base() {}
            compressed_pair(first_param_type x, second_param_type y) : base(x, y) {}

   explicit

      compressed_pair(first_param_type x) : base(x) {}

   first_reference first() {return base::first();}
   first_const_reference first() const {return base::first();}

   second_reference second() {return base::second();}
   second_const_reference second() const {return base::second();}

   void swap(::boost::compressed_pair<T,T>& y) { base::swap(y); }
};

template <class T1, class T2>
inline
void
swap(compressed_pair<T1, T2>& x, compressed_pair<T1, T2>& y)
{
   x.swap(y);
}

}
# 19 "/usr/local/include/boost/compressed_pair.hpp" 2 3
# 34 "/usr/local/include/boost/python/detail/caller.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 36 "/usr/local/include/boost/python/detail/caller.hpp" 2 3







namespace boost { namespace python { namespace detail {

template <int BOOST_PP_ITERATION_0>
inline PyObject* get(mpl::int_<BOOST_PP_ITERATION_0>, PyObject* const& args_)
{
    return (((PyTupleObject *)(args_))->ob_item[BOOST_PP_ITERATION_0]);
}

inline Py_ssize_t arity(PyObject* const& args_)
{
    return (((PyVarObject*)(args_))->ob_size);
}




typedef int void_result_to_python;




template <class Policies, class Result>
struct select_result_converter
  : mpl::eval_if<
        is_same<Result,void>
      , mpl::identity<void_result_to_python>
      , mpl::apply1<typename Policies::result_converter,Result>
    >
{
};

template <class ArgPackage, class ResultConverter>
inline ResultConverter create_result_converter(
    ArgPackage const& args_
  , ResultConverter*
  , converter::context_result_converter*
)
{
    return ResultConverter(args_);
}

template <class ArgPackage, class ResultConverter>
inline ResultConverter create_result_converter(
    ArgPackage const&
  , ResultConverter*
  , ...
)
{
    return ResultConverter();
}


template <class ResultConverter>
struct converter_target_type
{
    static PyTypeObject const *get_pytype()
    {
        return create_result_converter((PyObject*)0, (ResultConverter *)0, (ResultConverter *)0).get_pytype();
    }
};

template < >
struct converter_target_type <void_result_to_python >
{
    static PyTypeObject const *get_pytype()
    {
        return 0;
    }
};



template<class Policies, class Sig> const signature_element* get_ret()
{
    typedef typename Policies::template extract_return_type<Sig>::type rtype;
    typedef typename select_result_converter<Policies, rtype>::type result_converter;

    static const signature_element ret = {
        (is_void<rtype>::value ? "void" : type_id<rtype>().name())
        , &detail::converter_target_type<result_converter>::get_pytype
        , boost::detail::indirect_traits::is_reference_to_non_const<rtype>::value
    };

    return &ret;
};




template <unsigned> struct caller_arity;

template <class F, class CallPolicies, class Sig>
struct caller;
# 149 "/usr/local/include/boost/python/detail/caller.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<0>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);
# 230 "/usr/local/include/boost/python/detail/caller.hpp" 3
            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
               
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 0; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<1>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 1; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<2>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 2; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<3>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 3; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<4>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 4; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<5>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 5; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<6>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 6; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<7>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 7; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<8>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 8; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<9>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 9; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<10>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 10; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<11>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;


        typedef typename mpl::next< arg_iter9 >::type arg_iter10; typedef arg_from_python<typename arg_iter10::type> c_t10; c_t10 c10(get(mpl::int_<10>(), inner_args)); if (!c10.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 11; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<12>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;


        typedef typename mpl::next< arg_iter9 >::type arg_iter10; typedef arg_from_python<typename arg_iter10::type> c_t10; c_t10 c10(get(mpl::int_<10>(), inner_args)); if (!c10.convertible()) return 0;


        typedef typename mpl::next< arg_iter10 >::type arg_iter11; typedef arg_from_python<typename arg_iter11::type> c_t11; c_t11 c11(get(mpl::int_<11>(), inner_args)); if (!c11.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 , c11
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 12; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<13>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;


        typedef typename mpl::next< arg_iter9 >::type arg_iter10; typedef arg_from_python<typename arg_iter10::type> c_t10; c_t10 c10(get(mpl::int_<10>(), inner_args)); if (!c10.convertible()) return 0;


        typedef typename mpl::next< arg_iter10 >::type arg_iter11; typedef arg_from_python<typename arg_iter11::type> c_t11; c_t11 c11(get(mpl::int_<11>(), inner_args)); if (!c11.convertible()) return 0;


        typedef typename mpl::next< arg_iter11 >::type arg_iter12; typedef arg_from_python<typename arg_iter12::type> c_t12; c_t12 c12(get(mpl::int_<12>(), inner_args)); if (!c12.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 , c11 , c12
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 13; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<14>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;


        typedef typename mpl::next< arg_iter9 >::type arg_iter10; typedef arg_from_python<typename arg_iter10::type> c_t10; c_t10 c10(get(mpl::int_<10>(), inner_args)); if (!c10.convertible()) return 0;


        typedef typename mpl::next< arg_iter10 >::type arg_iter11; typedef arg_from_python<typename arg_iter11::type> c_t11; c_t11 c11(get(mpl::int_<11>(), inner_args)); if (!c11.convertible()) return 0;


        typedef typename mpl::next< arg_iter11 >::type arg_iter12; typedef arg_from_python<typename arg_iter12::type> c_t12; c_t12 c12(get(mpl::int_<12>(), inner_args)); if (!c12.convertible()) return 0;


        typedef typename mpl::next< arg_iter12 >::type arg_iter13; typedef arg_from_python<typename arg_iter13::type> c_t13; c_t13 c13(get(mpl::int_<13>(), inner_args)); if (!c13.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 , c11 , c12 , c13
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 14; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<15>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;


        typedef typename mpl::next< arg_iter9 >::type arg_iter10; typedef arg_from_python<typename arg_iter10::type> c_t10; c_t10 c10(get(mpl::int_<10>(), inner_args)); if (!c10.convertible()) return 0;


        typedef typename mpl::next< arg_iter10 >::type arg_iter11; typedef arg_from_python<typename arg_iter11::type> c_t11; c_t11 c11(get(mpl::int_<11>(), inner_args)); if (!c11.convertible()) return 0;


        typedef typename mpl::next< arg_iter11 >::type arg_iter12; typedef arg_from_python<typename arg_iter12::type> c_t12; c_t12 c12(get(mpl::int_<12>(), inner_args)); if (!c12.convertible()) return 0;


        typedef typename mpl::next< arg_iter12 >::type arg_iter13; typedef arg_from_python<typename arg_iter13::type> c_t13; c_t13 c13(get(mpl::int_<13>(), inner_args)); if (!c13.convertible()) return 0;


        typedef typename mpl::next< arg_iter13 >::type arg_iter14; typedef arg_from_python<typename arg_iter14::type> c_t14; c_t14 c14(get(mpl::int_<14>(), inner_args)); if (!c14.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 , c11 , c12 , c13 , c14
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 15; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 203 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <>
struct caller_arity<16>
{
    template <class F, class Policies, class Sig>
    struct impl
    {
        impl(F f, Policies p) : m_data(f,p) {}

        PyObject* operator()(PyObject* args_, PyObject*)



        {
            typedef typename mpl::begin<Sig>::type first;
            typedef typename first::type result_t;
            typedef typename select_result_converter<Policies, result_t>::type result_converter;
            typedef typename Policies::argument_package argument_package;

            argument_package inner_args(args_);




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::next<first>::type arg_iter0; typedef arg_from_python<typename arg_iter0::type> c_t0; c_t0 c0(get(mpl::int_<0>(), inner_args)); if (!c0.convertible()) return 0;


        typedef typename mpl::next< arg_iter0 >::type arg_iter1; typedef arg_from_python<typename arg_iter1::type> c_t1; c_t1 c1(get(mpl::int_<1>(), inner_args)); if (!c1.convertible()) return 0;


        typedef typename mpl::next< arg_iter1 >::type arg_iter2; typedef arg_from_python<typename arg_iter2::type> c_t2; c_t2 c2(get(mpl::int_<2>(), inner_args)); if (!c2.convertible()) return 0;


        typedef typename mpl::next< arg_iter2 >::type arg_iter3; typedef arg_from_python<typename arg_iter3::type> c_t3; c_t3 c3(get(mpl::int_<3>(), inner_args)); if (!c3.convertible()) return 0;


        typedef typename mpl::next< arg_iter3 >::type arg_iter4; typedef arg_from_python<typename arg_iter4::type> c_t4; c_t4 c4(get(mpl::int_<4>(), inner_args)); if (!c4.convertible()) return 0;


        typedef typename mpl::next< arg_iter4 >::type arg_iter5; typedef arg_from_python<typename arg_iter5::type> c_t5; c_t5 c5(get(mpl::int_<5>(), inner_args)); if (!c5.convertible()) return 0;


        typedef typename mpl::next< arg_iter5 >::type arg_iter6; typedef arg_from_python<typename arg_iter6::type> c_t6; c_t6 c6(get(mpl::int_<6>(), inner_args)); if (!c6.convertible()) return 0;


        typedef typename mpl::next< arg_iter6 >::type arg_iter7; typedef arg_from_python<typename arg_iter7::type> c_t7; c_t7 c7(get(mpl::int_<7>(), inner_args)); if (!c7.convertible()) return 0;


        typedef typename mpl::next< arg_iter7 >::type arg_iter8; typedef arg_from_python<typename arg_iter8::type> c_t8; c_t8 c8(get(mpl::int_<8>(), inner_args)); if (!c8.convertible()) return 0;


        typedef typename mpl::next< arg_iter8 >::type arg_iter9; typedef arg_from_python<typename arg_iter9::type> c_t9; c_t9 c9(get(mpl::int_<9>(), inner_args)); if (!c9.convertible()) return 0;


        typedef typename mpl::next< arg_iter9 >::type arg_iter10; typedef arg_from_python<typename arg_iter10::type> c_t10; c_t10 c10(get(mpl::int_<10>(), inner_args)); if (!c10.convertible()) return 0;


        typedef typename mpl::next< arg_iter10 >::type arg_iter11; typedef arg_from_python<typename arg_iter11::type> c_t11; c_t11 c11(get(mpl::int_<11>(), inner_args)); if (!c11.convertible()) return 0;


        typedef typename mpl::next< arg_iter11 >::type arg_iter12; typedef arg_from_python<typename arg_iter12::type> c_t12; c_t12 c12(get(mpl::int_<12>(), inner_args)); if (!c12.convertible()) return 0;


        typedef typename mpl::next< arg_iter12 >::type arg_iter13; typedef arg_from_python<typename arg_iter13::type> c_t13; c_t13 c13(get(mpl::int_<13>(), inner_args)); if (!c13.convertible()) return 0;


        typedef typename mpl::next< arg_iter13 >::type arg_iter14; typedef arg_from_python<typename arg_iter14::type> c_t14; c_t14 c14(get(mpl::int_<14>(), inner_args)); if (!c14.convertible()) return 0;


        typedef typename mpl::next< arg_iter14 >::type arg_iter15; typedef arg_from_python<typename arg_iter15::type> c_t15; c_t15 c15(get(mpl::int_<15>(), inner_args)); if (!c15.convertible()) return 0;
# 227 "/usr/local/include/boost/python/detail/caller.hpp" 2 3



            if (!m_data.second().precall(inner_args))
                return 0;

            PyObject* result = detail::invoke(
                detail::invoke_tag<result_t,F>()
              , create_result_converter(args_, (result_converter*)0, (result_converter*)0)
              , m_data.first()
                , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 , c10 , c11 , c12 , c13 , c14 , c15
            );

            return m_data.second().postcall(inner_args, result);
        }

        static unsigned min_arity() { return 16; }

        static py_func_sig_info signature()
        {
            const signature_element * sig = detail::signature<Sig>::elements();




            const signature_element * ret = detail::get_ret<Policies, Sig>();

            py_func_sig_info res = {sig, ret };




            return res;
        }
     private:
        compressed_pair<F,Policies> m_data;
    };
};
# 128 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 150 "/usr/local/include/boost/python/detail/caller.hpp" 2 3






template <class F, class CallPolicies, class Sig>
struct caller_base_select
{
    enum { arity = mpl::size<Sig>::value - 1 };
    typedef typename caller_arity<arity>::template impl<F,CallPolicies,Sig> type;
};
# 181 "/usr/local/include/boost/python/detail/caller.hpp" 3
template <class F, class CallPolicies, class Sig>
struct caller
    : caller_base_select<F,CallPolicies,Sig>::type
{
    typedef typename caller_base_select<
        F,CallPolicies,Sig
        >::type base;

    typedef PyObject* result_type;

    caller(F f, CallPolicies p) : base(f,p) {}

};

}}}
# 9 "/usr/local/include/boost/python/object/function_handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/default_call_policies.hpp" 1 3
# 14 "/usr/local/include/boost/python/default_call_policies.hpp" 3
# 1 "/usr/local/include/boost/mpl/front.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/front.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/front_impl.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/front_impl.hpp" 3
namespace boost { namespace mpl {




template< typename Tag >
struct front_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename begin<Sequence>::type iter_;
        typedef typename deref<iter_>::type type;
    };
};

 template<> struct front_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/front.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct front
    : front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : front< T1 > { }; }; template< typename Tag > struct lambda< front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef front< na > result_; typedef front< na > type; }; namespace aux { template< typename T1 > struct template_arity< front< T1 > > : int_<1> { }; template<> struct template_arity< front< na > > : int_<-1> { }; }

}}
# 15 "/usr/local/include/boost/python/default_call_policies.hpp" 2 3

namespace boost { namespace python {

template <class T> struct to_python_value;

namespace detail
{

  template <class T> struct specify_a_return_value_policy_to_wrap_functions_returning

  {}

  ;
}

struct default_result_converter;

struct default_call_policies
{


    template <class ArgumentPackage>
    static bool precall(ArgumentPackage const&)
    {
        return true;
    }


    template <class ArgumentPackage>
    static PyObject* postcall(ArgumentPackage const&, PyObject* result)
    {
        return result;
    }

    typedef default_result_converter result_converter;
    typedef PyObject* argument_package;

    template <class Sig>
    struct extract_return_type : mpl::front<Sig>
    {
    };

};

struct default_result_converter
{
    template <class R>
    struct apply
    {
        typedef typename mpl::if_<
            mpl::or_<detail::is_pointer<R>, detail::is_reference<R> >
          , detail::specify_a_return_value_policy_to_wrap_functions_returning<R>
          , boost::python::to_python_value<
                typename detail::value_arg<R>::type
            >
        >::type type;
    };
};


template <>
struct default_result_converter::apply<char const*>
{
    typedef boost::python::to_python_value<char const*const&> type;
};

template <>
struct default_result_converter::apply<PyObject*>
{
    typedef boost::python::to_python_value<PyObject*const&> type;
};

}}
# 10 "/usr/local/include/boost/python/object/function_handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/py_function.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/signature.hpp" 1 3
# 9 "/usr/local/include/boost/python/object/py_function.hpp" 2 3




namespace boost { namespace python { namespace objects {






struct py_function_impl_base
{
    virtual ~py_function_impl_base();
    virtual PyObject* operator()(PyObject*, PyObject*) = 0;
    virtual unsigned min_arity() const = 0;
    virtual unsigned max_arity() const;
    virtual python::detail::py_func_sig_info signature() const = 0;
};

template <class Caller>
struct caller_py_function_impl : py_function_impl_base
{
    caller_py_function_impl(Caller const& caller)
        : m_caller(caller)
    {}

    PyObject* operator()(PyObject* args, PyObject* kw)
    {
        return m_caller(args, kw);
    }

    virtual unsigned min_arity() const
    {
        return m_caller.min_arity();
    }

    virtual python::detail::py_func_sig_info signature() const
    {
        return m_caller.signature();
    }

 private:
    Caller m_caller;
};

template <class Caller, class Sig>
struct signature_py_function_impl : py_function_impl_base
{
    signature_py_function_impl(Caller const& caller)
        : m_caller(caller)
    {}

    PyObject* operator()(PyObject* args, PyObject* kw)
    {
        return m_caller(args, kw);
    }

    virtual unsigned min_arity() const
    {
        return mpl::size<Sig>::value - 1;
    }

    virtual python::detail::py_func_sig_info signature() const
    {
        python::detail::signature_element const* sig = python::detail::signature<Sig>::elements();
        python::detail::py_func_sig_info res = {sig, sig};
        return res;
    }

 private:
    Caller m_caller;
};

template <class Caller, class Sig>
struct full_py_function_impl : py_function_impl_base
{
    full_py_function_impl(Caller const& caller, unsigned min_arity, unsigned max_arity)
      : m_caller(caller)
      , m_min_arity(min_arity)
      , m_max_arity(max_arity > min_arity ? max_arity : min_arity)
    {}

    PyObject* operator()(PyObject* args, PyObject* kw)
    {
        return m_caller(args, kw);
    }

    virtual unsigned min_arity() const
    {
        return m_min_arity;
    }

    virtual unsigned max_arity() const
    {
        return m_max_arity;
    }

    virtual python::detail::py_func_sig_info signature() const
    {
        python::detail::signature_element const* sig = python::detail::signature<Sig>::elements();
        python::detail::py_func_sig_info res = {sig, sig};
        return res;
    }

 private:
    Caller m_caller;
    unsigned m_min_arity;
    unsigned m_max_arity;
};

struct py_function
{
    template <class Caller>
    py_function(Caller const& caller)
        : m_impl(new caller_py_function_impl<Caller>(caller))
    {}

    template <class Caller, class Sig>
    py_function(Caller const& caller, Sig)
      : m_impl(new signature_py_function_impl<Caller, Sig>(caller))
    {}

    template <class Caller, class Sig>
    py_function(Caller const& caller, Sig, int min_arity, int max_arity = 0)
      : m_impl(new full_py_function_impl<Caller, Sig>(caller, min_arity, max_arity))
    {}

    py_function(py_function const& rhs)



      : m_impl(std::move(rhs.m_impl))

    {}

    PyObject* operator()(PyObject* args, PyObject* kw) const
    {
        return (*m_impl)(args, kw);
    }

    unsigned min_arity() const
    {
        return m_impl->min_arity();
    }

    unsigned max_arity() const
    {
        return m_impl->max_arity();
    }

    python::detail::signature_element const* signature() const
    {
        return m_impl->signature().signature;
    }

    python::detail::signature_element const& get_return_type() const
    {
        return *m_impl->signature().ret;
    }

 private:



    mutable std::unique_ptr<py_function_impl_base> m_impl;

};

}}}
# 11 "/usr/local/include/boost/python/object/function_handle.hpp" 2 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 37 "/usr/local/include/boost/python/signature.hpp" 3
namespace boost { namespace python { namespace detail {



template <class C1, class C2>
struct most_derived
{
    typedef typename mpl::if_<
        detail::is_convertible<C1*,C2*>
      , C1
      , C2
    >::type type;
};
# 118 "/usr/local/include/boost/python/signature.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT >
inline mpl::vector1<
    RT >
get_signature(RT( *)(), void* = 0)
{
    return mpl::vector1<
            RT
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT >
inline mpl::vector2<
    RT, ClassT& >
get_signature(RT( ClassT::*)() )
{
    return mpl::vector2<
            RT, ClassT&
        >();
}

template <
    class Target
  , class RT
  , class ClassT
   
>
inline mpl::vector2<
    RT
  , typename most_derived<Target, ClassT>::type&
   
>
get_signature(
    RT( ClassT::*)()
  , Target*
)
{
    return mpl::vector2<
        RT
      , typename most_derived<Target, ClassT>::type&
       
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT >
inline mpl::vector2<
    RT, ClassT& >
get_signature(RT( ClassT::*)() const)
{
    return mpl::vector2<
            RT, ClassT&
        >();
}

template <
    class Target
  , class RT
  , class ClassT
   
>
inline mpl::vector2<
    RT
  , typename most_derived<Target, ClassT>::type&
   
>
get_signature(
    RT( ClassT::*)() const
  , Target*
)
{
    return mpl::vector2<
        RT
      , typename most_derived<Target, ClassT>::type&
       
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT >
inline mpl::vector2<
    RT, ClassT& >
get_signature(RT( ClassT::*)() volatile)
{
    return mpl::vector2<
            RT, ClassT&
        >();
}

template <
    class Target
  , class RT
  , class ClassT
   
>
inline mpl::vector2<
    RT
  , typename most_derived<Target, ClassT>::type&
   
>
get_signature(
    RT( ClassT::*)() volatile
  , Target*
)
{
    return mpl::vector2<
        RT
      , typename most_derived<Target, ClassT>::type&
       
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT >
inline mpl::vector2<
    RT, ClassT& >
get_signature(RT( ClassT::*)() const volatile)
{
    return mpl::vector2<
            RT, ClassT&
        >();
}

template <
    class Target
  , class RT
  , class ClassT
   
>
inline mpl::vector2<
    RT
  , typename most_derived<Target, ClassT>::type&
   
>
get_signature(
    RT( ClassT::*)() const volatile
  , Target*
)
{
    return mpl::vector2<
        RT
      , typename most_derived<Target, ClassT>::type&
       
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0>
inline mpl::vector2<
    RT , T0>
get_signature(RT( *)( T0), void* = 0)
{
    return mpl::vector2<
            RT , T0
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0>
inline mpl::vector3<
    RT, ClassT& , T0>
get_signature(RT( ClassT::*)( T0) )
{
    return mpl::vector3<
            RT, ClassT& , T0
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0
>
inline mpl::vector3<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0
>
get_signature(
    RT( ClassT::*)( T0)
  , Target*
)
{
    return mpl::vector3<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0>
inline mpl::vector3<
    RT, ClassT& , T0>
get_signature(RT( ClassT::*)( T0) const)
{
    return mpl::vector3<
            RT, ClassT& , T0
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0
>
inline mpl::vector3<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0
>
get_signature(
    RT( ClassT::*)( T0) const
  , Target*
)
{
    return mpl::vector3<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0>
inline mpl::vector3<
    RT, ClassT& , T0>
get_signature(RT( ClassT::*)( T0) volatile)
{
    return mpl::vector3<
            RT, ClassT& , T0
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0
>
inline mpl::vector3<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0
>
get_signature(
    RT( ClassT::*)( T0) volatile
  , Target*
)
{
    return mpl::vector3<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0>
inline mpl::vector3<
    RT, ClassT& , T0>
get_signature(RT( ClassT::*)( T0) const volatile)
{
    return mpl::vector3<
            RT, ClassT& , T0
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0
>
inline mpl::vector3<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0
>
get_signature(
    RT( ClassT::*)( T0) const volatile
  , Target*
)
{
    return mpl::vector3<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1>
inline mpl::vector3<
    RT , T0 , T1>
get_signature(RT( *)( T0 , T1), void* = 0)
{
    return mpl::vector3<
            RT , T0 , T1
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1>
inline mpl::vector4<
    RT, ClassT& , T0 , T1>
get_signature(RT( ClassT::*)( T0 , T1) )
{
    return mpl::vector4<
            RT, ClassT& , T0 , T1
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1
>
inline mpl::vector4<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1
>
get_signature(
    RT( ClassT::*)( T0 , T1)
  , Target*
)
{
    return mpl::vector4<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1>
inline mpl::vector4<
    RT, ClassT& , T0 , T1>
get_signature(RT( ClassT::*)( T0 , T1) const)
{
    return mpl::vector4<
            RT, ClassT& , T0 , T1
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1
>
inline mpl::vector4<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1
>
get_signature(
    RT( ClassT::*)( T0 , T1) const
  , Target*
)
{
    return mpl::vector4<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1>
inline mpl::vector4<
    RT, ClassT& , T0 , T1>
get_signature(RT( ClassT::*)( T0 , T1) volatile)
{
    return mpl::vector4<
            RT, ClassT& , T0 , T1
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1
>
inline mpl::vector4<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1
>
get_signature(
    RT( ClassT::*)( T0 , T1) volatile
  , Target*
)
{
    return mpl::vector4<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1>
inline mpl::vector4<
    RT, ClassT& , T0 , T1>
get_signature(RT( ClassT::*)( T0 , T1) const volatile)
{
    return mpl::vector4<
            RT, ClassT& , T0 , T1
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1
>
inline mpl::vector4<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1
>
get_signature(
    RT( ClassT::*)( T0 , T1) const volatile
  , Target*
)
{
    return mpl::vector4<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2>
inline mpl::vector4<
    RT , T0 , T1 , T2>
get_signature(RT( *)( T0 , T1 , T2), void* = 0)
{
    return mpl::vector4<
            RT , T0 , T1 , T2
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2>
inline mpl::vector5<
    RT, ClassT& , T0 , T1 , T2>
get_signature(RT( ClassT::*)( T0 , T1 , T2) )
{
    return mpl::vector5<
            RT, ClassT& , T0 , T1 , T2
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2
>
inline mpl::vector5<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2)
  , Target*
)
{
    return mpl::vector5<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2>
inline mpl::vector5<
    RT, ClassT& , T0 , T1 , T2>
get_signature(RT( ClassT::*)( T0 , T1 , T2) const)
{
    return mpl::vector5<
            RT, ClassT& , T0 , T1 , T2
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2
>
inline mpl::vector5<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2) const
  , Target*
)
{
    return mpl::vector5<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2>
inline mpl::vector5<
    RT, ClassT& , T0 , T1 , T2>
get_signature(RT( ClassT::*)( T0 , T1 , T2) volatile)
{
    return mpl::vector5<
            RT, ClassT& , T0 , T1 , T2
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2
>
inline mpl::vector5<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2) volatile
  , Target*
)
{
    return mpl::vector5<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2>
inline mpl::vector5<
    RT, ClassT& , T0 , T1 , T2>
get_signature(RT( ClassT::*)( T0 , T1 , T2) const volatile)
{
    return mpl::vector5<
            RT, ClassT& , T0 , T1 , T2
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2
>
inline mpl::vector5<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2) const volatile
  , Target*
)
{
    return mpl::vector5<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3>
inline mpl::vector5<
    RT , T0 , T1 , T2 , T3>
get_signature(RT( *)( T0 , T1 , T2 , T3), void* = 0)
{
    return mpl::vector5<
            RT , T0 , T1 , T2 , T3
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3>
inline mpl::vector6<
    RT, ClassT& , T0 , T1 , T2 , T3>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3) )
{
    return mpl::vector6<
            RT, ClassT& , T0 , T1 , T2 , T3
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3
>
inline mpl::vector6<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3)
  , Target*
)
{
    return mpl::vector6<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3>
inline mpl::vector6<
    RT, ClassT& , T0 , T1 , T2 , T3>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3) const)
{
    return mpl::vector6<
            RT, ClassT& , T0 , T1 , T2 , T3
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3
>
inline mpl::vector6<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3) const
  , Target*
)
{
    return mpl::vector6<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3>
inline mpl::vector6<
    RT, ClassT& , T0 , T1 , T2 , T3>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3) volatile)
{
    return mpl::vector6<
            RT, ClassT& , T0 , T1 , T2 , T3
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3
>
inline mpl::vector6<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3) volatile
  , Target*
)
{
    return mpl::vector6<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3>
inline mpl::vector6<
    RT, ClassT& , T0 , T1 , T2 , T3>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3) const volatile)
{
    return mpl::vector6<
            RT, ClassT& , T0 , T1 , T2 , T3
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3
>
inline mpl::vector6<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3) const volatile
  , Target*
)
{
    return mpl::vector6<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4>
inline mpl::vector6<
    RT , T0 , T1 , T2 , T3 , T4>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4), void* = 0)
{
    return mpl::vector6<
            RT , T0 , T1 , T2 , T3 , T4
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4>
inline mpl::vector7<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) )
{
    return mpl::vector7<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4
>
inline mpl::vector7<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4)
  , Target*
)
{
    return mpl::vector7<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4>
inline mpl::vector7<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) const)
{
    return mpl::vector7<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4
>
inline mpl::vector7<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) const
  , Target*
)
{
    return mpl::vector7<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4>
inline mpl::vector7<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) volatile)
{
    return mpl::vector7<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4
>
inline mpl::vector7<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) volatile
  , Target*
)
{
    return mpl::vector7<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4>
inline mpl::vector7<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) const volatile)
{
    return mpl::vector7<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4
>
inline mpl::vector7<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4) const volatile
  , Target*
)
{
    return mpl::vector7<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
inline mpl::vector7<
    RT , T0 , T1 , T2 , T3 , T4 , T5>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5), void* = 0)
{
    return mpl::vector7<
            RT , T0 , T1 , T2 , T3 , T4 , T5
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
inline mpl::vector8<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) )
{
    return mpl::vector8<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5
>
inline mpl::vector8<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5)
  , Target*
)
{
    return mpl::vector8<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
inline mpl::vector8<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) const)
{
    return mpl::vector8<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5
>
inline mpl::vector8<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) const
  , Target*
)
{
    return mpl::vector8<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
inline mpl::vector8<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile)
{
    return mpl::vector8<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5
>
inline mpl::vector8<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile
  , Target*
)
{
    return mpl::vector8<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
inline mpl::vector8<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile)
{
    return mpl::vector8<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5
>
inline mpl::vector8<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile
  , Target*
)
{
    return mpl::vector8<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
inline mpl::vector8<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6), void* = 0)
{
    return mpl::vector8<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
inline mpl::vector9<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) )
{
    return mpl::vector9<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6
>
inline mpl::vector9<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)
  , Target*
)
{
    return mpl::vector9<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
inline mpl::vector9<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const)
{
    return mpl::vector9<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6
>
inline mpl::vector9<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const
  , Target*
)
{
    return mpl::vector9<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
inline mpl::vector9<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile)
{
    return mpl::vector9<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6
>
inline mpl::vector9<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile
  , Target*
)
{
    return mpl::vector9<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
inline mpl::vector9<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile)
{
    return mpl::vector9<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6
>
inline mpl::vector9<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile
  , Target*
)
{
    return mpl::vector9<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
inline mpl::vector9<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7), void* = 0)
{
    return mpl::vector9<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
inline mpl::vector10<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) )
{
    return mpl::vector10<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7
>
inline mpl::vector10<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)
  , Target*
)
{
    return mpl::vector10<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
inline mpl::vector10<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const)
{
    return mpl::vector10<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7
>
inline mpl::vector10<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const
  , Target*
)
{
    return mpl::vector10<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
inline mpl::vector10<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile)
{
    return mpl::vector10<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7
>
inline mpl::vector10<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile
  , Target*
)
{
    return mpl::vector10<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
inline mpl::vector10<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile)
{
    return mpl::vector10<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7
>
inline mpl::vector10<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile
  , Target*
)
{
    return mpl::vector10<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
inline mpl::vector10<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8), void* = 0)
{
    return mpl::vector10<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
inline mpl::vector11<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) )
{
    return mpl::vector11<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8
>
inline mpl::vector11<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)
  , Target*
)
{
    return mpl::vector11<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
inline mpl::vector11<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const)
{
    return mpl::vector11<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8
>
inline mpl::vector11<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const
  , Target*
)
{
    return mpl::vector11<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
inline mpl::vector11<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile)
{
    return mpl::vector11<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8
>
inline mpl::vector11<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile
  , Target*
)
{
    return mpl::vector11<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
inline mpl::vector11<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile)
{
    return mpl::vector11<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8
>
inline mpl::vector11<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile
  , Target*
)
{
    return mpl::vector11<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
inline mpl::vector11<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9), void* = 0)
{
    return mpl::vector11<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
inline mpl::vector12<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) )
{
    return mpl::vector12<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9
>
inline mpl::vector12<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)
  , Target*
)
{
    return mpl::vector12<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
inline mpl::vector12<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const)
{
    return mpl::vector12<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9
>
inline mpl::vector12<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const
  , Target*
)
{
    return mpl::vector12<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
inline mpl::vector12<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile)
{
    return mpl::vector12<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9
>
inline mpl::vector12<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile
  , Target*
)
{
    return mpl::vector12<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
inline mpl::vector12<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile)
{
    return mpl::vector12<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9
>
inline mpl::vector12<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile
  , Target*
)
{
    return mpl::vector12<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
inline mpl::vector12<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10), void* = 0)
{
    return mpl::vector12<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
inline mpl::vector13<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) )
{
    return mpl::vector13<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10
>
inline mpl::vector13<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)
  , Target*
)
{
    return mpl::vector13<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
inline mpl::vector13<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const)
{
    return mpl::vector13<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10
>
inline mpl::vector13<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const
  , Target*
)
{
    return mpl::vector13<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
inline mpl::vector13<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile)
{
    return mpl::vector13<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10
>
inline mpl::vector13<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile
  , Target*
)
{
    return mpl::vector13<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
inline mpl::vector13<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile)
{
    return mpl::vector13<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10
>
inline mpl::vector13<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile
  , Target*
)
{
    return mpl::vector13<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
inline mpl::vector13<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11), void* = 0)
{
    return mpl::vector13<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
inline mpl::vector14<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) )
{
    return mpl::vector14<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11
>
inline mpl::vector14<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)
  , Target*
)
{
    return mpl::vector14<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
inline mpl::vector14<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const)
{
    return mpl::vector14<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11
>
inline mpl::vector14<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const
  , Target*
)
{
    return mpl::vector14<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
inline mpl::vector14<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile)
{
    return mpl::vector14<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11
>
inline mpl::vector14<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile
  , Target*
)
{
    return mpl::vector14<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
inline mpl::vector14<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile)
{
    return mpl::vector14<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11
>
inline mpl::vector14<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile
  , Target*
)
{
    return mpl::vector14<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
inline mpl::vector14<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12), void* = 0)
{
    return mpl::vector14<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
inline mpl::vector15<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) )
{
    return mpl::vector15<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12
>
inline mpl::vector15<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)
  , Target*
)
{
    return mpl::vector15<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
inline mpl::vector15<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const)
{
    return mpl::vector15<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12
>
inline mpl::vector15<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const
  , Target*
)
{
    return mpl::vector15<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
inline mpl::vector15<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile)
{
    return mpl::vector15<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12
>
inline mpl::vector15<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile
  , Target*
)
{
    return mpl::vector15<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
inline mpl::vector15<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile)
{
    return mpl::vector15<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12
>
inline mpl::vector15<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile
  , Target*
)
{
    return mpl::vector15<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
inline mpl::vector15<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13), void* = 0)
{
    return mpl::vector15<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
inline mpl::vector16<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) )
{
    return mpl::vector16<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13
>
inline mpl::vector16<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)
  , Target*
)
{
    return mpl::vector16<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
inline mpl::vector16<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const)
{
    return mpl::vector16<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13
>
inline mpl::vector16<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const
  , Target*
)
{
    return mpl::vector16<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
inline mpl::vector16<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile)
{
    return mpl::vector16<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13
>
inline mpl::vector16<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile
  , Target*
)
{
    return mpl::vector16<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
inline mpl::vector16<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile)
{
    return mpl::vector16<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13
>
inline mpl::vector16<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile
  , Target*
)
{
    return mpl::vector16<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 190 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
inline mpl::vector16<
    RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
get_signature(RT( *)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14), void* = 0)
{
    return mpl::vector16<
            RT , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
        >();
}







# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
inline mpl::vector17<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) )
{
    return mpl::vector17<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14
>
inline mpl::vector17<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)
  , Target*
)
{
    return mpl::vector17<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
    >();
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
inline mpl::vector17<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const)
{
    return mpl::vector17<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14
>
inline mpl::vector17<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const
  , Target*
)
{
    return mpl::vector17<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
    >();
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
inline mpl::vector17<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile)
{
    return mpl::vector17<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14
>
inline mpl::vector17<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile
  , Target*
)
{
    return mpl::vector17<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
    >();
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 214 "/usr/local/include/boost/python/signature.hpp" 3
template <
    class RT, class ClassT , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
inline mpl::vector17<
    RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
get_signature(RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile)
{
    return mpl::vector17<
            RT, ClassT& , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
        >();
}

template <
    class Target
  , class RT
  , class ClassT
    , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14
>
inline mpl::vector17<
    RT
  , typename most_derived<Target, ClassT>::type&
    , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
>
get_signature(
    RT( ClassT::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile
  , Target*
)
{
    return mpl::vector17<
        RT
      , typename most_derived<Target, ClassT>::type&
        , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14
    >();
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 208 "/usr/local/include/boost/python/signature.hpp" 2 3
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 119 "/usr/local/include/boost/python/signature.hpp" 2 3
# 173 "/usr/local/include/boost/python/signature.hpp" 3
}}}
# 12 "/usr/local/include/boost/python/object/function_handle.hpp" 2 3

namespace boost { namespace python { namespace objects {

 handle<> function_handle_impl(py_function const& f);




template <class F, class Signature>
inline handle<> function_handle(F const& f, Signature)
{
    enum { n_arguments = mpl::size<Signature>::value - 1 };

    return objects::function_handle_impl(
        python::detail::caller<
            F,default_call_policies,Signature
        >(
            f, default_call_policies()
         )
    );
}



template <class F>
handle<> make_function_handle(F f)
{
    return objects::function_handle(f, python::detail::get_signature(f));
}

}}}
# 20 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3





# 1 "/usr/local/include/boost/python/detail/string_literal.hpp" 1 3
# 14 "/usr/local/include/boost/python/detail/string_literal.hpp" 3
namespace boost { namespace python { namespace detail {

template <class T>
struct is_string_literal : mpl::false_
{
};


template <std::size_t n>
struct is_string_literal<char const[n]> : mpl::true_
{
};
# 47 "/usr/local/include/boost/python/detail/string_literal.hpp" 3
}}}
# 26 "/usr/local/include/boost/python/converter/arg_to_python.hpp" 2 3





namespace boost { namespace python { namespace converter {

template <class T> struct is_object_manager;

namespace detail
{
  template <class T>
  struct function_arg_to_python : handle<>
  {
      function_arg_to_python(T const& x);
  };

  template <class T>
  struct reference_arg_to_python : handle<>
  {
      reference_arg_to_python(T& x);
   private:
      static PyObject* get_object(T& x);
  };

  template <class T>
  struct shared_ptr_arg_to_python : handle<>
  {
      shared_ptr_arg_to_python(T const& x);
   private:
      static PyObject* get_object(T& x);
  };

  template <class T>
  struct value_arg_to_python : arg_to_python_base
  {

      value_arg_to_python(T const&);
  };

  template <class Ptr>
  struct pointer_deep_arg_to_python : arg_to_python_base
  {

      pointer_deep_arg_to_python(Ptr);
  };

  template <class Ptr>
  struct pointer_shallow_arg_to_python : handle<>
  {

      pointer_shallow_arg_to_python(Ptr);
   private:
      static PyObject* get_object(Ptr p);
  };


  template <class T>
  struct object_manager_arg_to_python
  {
      object_manager_arg_to_python(T const& x) : m_src(x) {}

      PyObject* get() const
      {
          return python::upcast<PyObject>(get_managed_object(m_src, tag));
      }

   private:
      T const& m_src;
  };

  template <class T>
  struct select_arg_to_python
  {
      typedef typename unwrap_reference<T>::type unwrapped_referent;
      typedef typename unwrap_pointer<T>::type unwrapped_ptr;

      typedef typename mpl::if_<


          python::detail::is_string_literal<T const>
        , arg_to_python<char const*>

        , typename mpl::if_<
              python::detail::value_is_shared_ptr<T>
            , shared_ptr_arg_to_python<T>

            , typename mpl::if_<
                mpl::or_<
                    boost::python::detail::is_function<T>
                  , indirect_traits::is_pointer_to_function<T>
                  , boost::python::detail::is_member_function_pointer<T>
                >
                , function_arg_to_python<T>

                , typename mpl::if_<
                      is_object_manager<T>
                    , object_manager_arg_to_python<T>

                    , typename mpl::if_<
                          boost::python::detail::is_pointer<T>
                        , pointer_deep_arg_to_python<T>

                        , typename mpl::if_<
                              is_pointer_wrapper<T>
                            , pointer_shallow_arg_to_python<unwrapped_ptr>

                            , typename mpl::if_<
                                  is_reference_wrapper<T>
                                , reference_arg_to_python<unwrapped_referent>
                                , value_arg_to_python<T>
                              >::type
                          >::type
                      >::type
                  >::type
              >::type
          >::type
      >::type

      type;
  };
}

template <class T>
struct arg_to_python
    : detail::select_arg_to_python<T>::type
{
    typedef typename detail::select_arg_to_python<T>::type base;
 public:

    arg_to_python(T const& x);
};




namespace detail
{


  using python::detail::yes_convertible;
  using python::detail::no_convertible;
  using python::detail::unspecialized;

  template <class T> struct cannot_convert_raw_PyObject;

  template <class T, class Convertibility>
  struct reject_raw_object_helper
  {
      static void error(Convertibility)
      {
          cannot_convert_raw_PyObject<T*>::to_python_use_handle_instead();
      }
      static void error(...) {}
  };

  template <class T>
  inline void reject_raw_object_ptr(T*)
  {
      reject_raw_object_helper<T,yes_convertible>::error(
          python::detail::convertible<PyObject const volatile*>::check((T*)0));

      typedef typename remove_cv<T>::type value_type;

      reject_raw_object_helper<T,no_convertible>::error(
          python::detail::convertible<unspecialized*>::check(
              (base_type_traits<value_type>*)0
              ));
  }


  template <class T>
  inline function_arg_to_python<T>::function_arg_to_python(T const& x)
      : handle<>(python::objects::make_function_handle(x))
  {
  }

  template <class T>
  inline value_arg_to_python<T>::value_arg_to_python(T const& x)
      : arg_to_python_base(&x, registered<T>::converters)
  {
  }

  template <class Ptr>
  inline pointer_deep_arg_to_python<Ptr>::pointer_deep_arg_to_python(Ptr x)
      : arg_to_python_base(x, registered_pointee<Ptr>::converters)
  {
      detail::reject_raw_object_ptr((Ptr)0);
  }

  template <class T>
  inline PyObject* reference_arg_to_python<T>::get_object(T& x)
  {
      to_python_indirect<T&,python::detail::make_reference_holder> convert;
      return convert(x);
  }

  template <class T>
  inline reference_arg_to_python<T>::reference_arg_to_python(T& x)
      : handle<>(reference_arg_to_python<T>::get_object(x))
  {
  }

  template <class T>
  inline shared_ptr_arg_to_python<T>::shared_ptr_arg_to_python(T const& x)
      : handle<>(shared_ptr_to_python(x))
  {
  }

  template <class Ptr>
  inline pointer_shallow_arg_to_python<Ptr>::pointer_shallow_arg_to_python(Ptr x)
      : handle<>(pointer_shallow_arg_to_python<Ptr>::get_object(x))
  {
      detail::reject_raw_object_ptr((Ptr)0);
  }

  template <class Ptr>
  inline PyObject* pointer_shallow_arg_to_python<Ptr>::get_object(Ptr x)
  {
      to_python_indirect<Ptr,python::detail::make_reference_holder> convert;
      return convert(x);
  }
}

template <class T>
inline arg_to_python<T>::arg_to_python(T const& x)
    : base(x)
{}

}}}
# 16 "/usr/local/include/boost/python/call.hpp" 2 3
# 1 "/usr/local/include/boost/python/converter/return_from_python.hpp" 1 3
# 14 "/usr/local/include/boost/python/converter/return_from_python.hpp" 3
# 1 "/usr/local/include/boost/python/detail/void_return.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/void_return.hpp" 3
namespace boost { namespace python { namespace detail {

struct void_return
{
    void_return() {}
 private:
    void operator=(void_return const&);
};

template <class T>
struct returnable
{
    typedef T type;
};
# 40 "/usr/local/include/boost/python/detail/void_return.hpp" 3
}}}
# 15 "/usr/local/include/boost/python/converter/return_from_python.hpp" 2 3






namespace boost { namespace python { namespace converter {

template <class T> struct is_object_manager;

namespace detail
{
  template <class T>
  struct return_pointer_from_python
  {
      typedef T result_type;
      T operator()(PyObject*) const;
  };

  template <class T>
  struct return_reference_from_python
  {
      typedef T result_type;
      T operator()(PyObject*) const;
  };

  template <class T>
  struct return_rvalue_from_python
  {
      typedef T result_type;

      return_rvalue_from_python();
      result_type operator()(PyObject*);
   private:
      rvalue_from_python_data<T> m_data;
  };

  template <class T>
  struct return_object_manager_from_python
  {
      typedef T result_type;
      result_type operator()(PyObject*) const;
  };

  template <class T>
  struct select_return_from_python
  {
      static const bool obj_mgr = is_object_manager<T>::value
                                                      ;

      static const bool ptr = is_pointer<T>::value
                                           ;

      static const bool ref = is_reference<T>::value
                                             ;

      typedef typename mpl::if_c<
          obj_mgr
          , return_object_manager_from_python<T>
          , typename mpl::if_c<
              ptr
              , return_pointer_from_python<T>
              , typename mpl::if_c<
                  ref
                  , return_reference_from_python<T>
                  , return_rvalue_from_python<T>
                >::type
            >::type
         >::type type;
  };
}

template <class T>
struct return_from_python
    : detail::select_return_from_python<T>::type
{
};


template <>
struct return_from_python<void>
{
    typedef python::detail::returnable<void>::type result_type;

    result_type operator()(PyObject* x) const
    {
        (void_result_from_python)(x);



    }
};




namespace detail
{
  template <class T>
  inline return_rvalue_from_python<T>::return_rvalue_from_python()
      : m_data(
          const_cast<registration*>(&registered<T>::converters)
          )
  {
  }

  template <class T>
  inline typename return_rvalue_from_python<T>::result_type
  return_rvalue_from_python<T>::operator()(PyObject* obj)
  {




    handle<> holder(obj);

      return *(T*)
          (rvalue_result_from_python)(obj, m_data.stage1);
  }

  template <class T>
  inline T return_reference_from_python<T>::operator()(PyObject* obj) const
  {
      return python::detail::void_ptr_to_reference(
          (reference_result_from_python)(obj, registered<T>::converters)
          , (T(*)())0);
  }

  template <class T>
  inline T return_pointer_from_python<T>::operator()(PyObject* obj) const
  {
      return T(
          (pointer_result_from_python)(obj, registered_pointee<T>::converters)
          );
  }

  template <class T>
  inline T return_object_manager_from_python<T>::operator()(PyObject* obj) const
  {
      return T(
          object_manager_traits<T>::adopt(expect_non_null(obj))
          );
  }
}

}}}
# 17 "/usr/local/include/boost/python/call.hpp" 2 3
# 27 "/usr/local/include/boost/python/call.hpp" 3
namespace boost { namespace python {





# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
   
    >
typename detail::returnable<R>::type
call(PyObject* callable
   
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" ")")
           
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" ")")
            , converter::arg_to_python<A0>(a0).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get() , converter::arg_to_python<A13>(a13).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 47 "/usr/local/include/boost/python/call.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14
    >
typename detail::returnable<R>::type
call(PyObject* callable
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13 , A14 const& a14
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallFunction(
            callable
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get() , converter::arg_to_python<A13>(a13).get() , converter::arg_to_python<A14>(a14).get()
            );
# 75 "/usr/local/include/boost/python/call.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 34 "/usr/local/include/boost/python/call.hpp" 2 3



}}
# 15 "/usr/local/include/boost/python/object_core.hpp" 2 3





# 1 "/usr/local/include/boost/python/def_visitor.hpp" 1 3
# 11 "/usr/local/include/boost/python/def_visitor.hpp" 3
namespace boost { namespace python {

template <class DerivedVisitor> class def_visitor;
template <class T, class X1, class X2, class X3> class class_;

class def_visitor_access
{






    template <class Derived> friend class def_visitor;



    template <class V, class classT>
    static void visit(V const& v, classT& c)
    {
        v.derived_visitor().visit(c);
    }


    template <class V, class classT, class OptionalArgs>
    static void visit(
        V const& v
      , classT& c
      , char const* name
      , OptionalArgs const& options
    )
    {
        v.derived_visitor().visit(c, name, options);
    }

};


template <class DerivedVisitor>
class def_visitor
{
    friend class def_visitor_access;







    template <class T, class X1, class X2, class X3> friend class class_;



    template <class classT>
    void visit(classT& c) const
    {
        def_visitor_access::visit(*this, c);
    }


    template <class classT, class OptionalArgs>
    void visit(classT& c, char const* name, OptionalArgs const& options) const
    {
        def_visitor_access::visit(*this, c, name, options);
    }

 protected:
    DerivedVisitor const& derived_visitor() const
    {
        return static_cast<DerivedVisitor const&>(*this);
    }
};

}}
# 21 "/usr/local/include/boost/python/object_core.hpp" 2 3





# 1 "/usr/local/include/boost/python/object/add_to_namespace.hpp" 1 3
# 10 "/usr/local/include/boost/python/object/add_to_namespace.hpp" 3
namespace boost { namespace python { namespace objects {




 void add_to_namespace(
    object const& name_space, char const* name, object const& attribute);

 void add_to_namespace(
    object const& name_space, char const* name, object const& attribute, char const* doc);

}}}
# 27 "/usr/local/include/boost/python/object_core.hpp" 2 3






# 1 "/usr/local/include/boost/python/detail/def_helper_fwd.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/not_specified.hpp" 1 3







namespace boost { namespace python { namespace detail {

  struct not_specified {};

}}}
# 9 "/usr/local/include/boost/python/detail/def_helper_fwd.hpp" 2 3

namespace boost { namespace python { namespace detail {

template <class T1, class T2 = not_specified, class T3 = not_specified, class T4 = not_specified>
struct def_helper;

}}}
# 34 "/usr/local/include/boost/python/object_core.hpp" 2 3


namespace boost { namespace python {

namespace detail
{
  class kwds_proxy;
  class args_proxy;
}

namespace converter
{
  template <class T> struct arg_to_python;
}


namespace api
{





  template <class Policies> class proxy;

  struct const_attribute_policies;
  struct attribute_policies;
  struct const_objattribute_policies;
  struct objattribute_policies;
  struct const_item_policies;
  struct item_policies;
  struct const_slice_policies;
  struct slice_policies;
  class slice_nil;

  typedef proxy<const_attribute_policies> const_object_attribute;
  typedef proxy<attribute_policies> object_attribute;
  typedef proxy<const_objattribute_policies> const_object_objattribute;
  typedef proxy<objattribute_policies> object_objattribute;
  typedef proxy<const_item_policies> const_object_item;
  typedef proxy<item_policies> object_item;
  typedef proxy<const_slice_policies> const_object_slice;
  typedef proxy<slice_policies> object_slice;




  template <class T> struct is_proxy : boost::false_type { }; template < class T0 > struct is_proxy< boost::python::api::proxy< T0 > > : boost::true_type { };

  template <class T> struct object_initializer;

  class object;
  typedef PyObject* (object::*bool_type)() const;

  template <class U>
  class object_operators : public def_visitor<U>
  {
   protected:
      typedef object const& object_cref;
   public:


      object operator()() const;


# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 52 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0);
    }
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1);
    }
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2);
    }
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3);
    }
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4);
    }
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5);
    }
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6);
    }
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
    }
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
    }
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
    }
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10);
    }
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11);
    }
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12);
    }
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13);
    }
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object_call.hpp" 1 3
# 13 "/usr/local/include/boost/python/object_call.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
    typename detail::dependent<object, A0>::type
    operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13 , A14 const& a14) const
    {
        typedef typename detail::dependent<object, A0>::type obj;
        U const& self = *static_cast<U const*>(this);
        return call<obj>(get_managed_object(self, tag), a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14);
    }
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 100 "/usr/local/include/boost/python/object_core.hpp" 2 3

      detail::args_proxy operator* () const;
      object operator()(detail::args_proxy const &args) const;
      object operator()(detail::args_proxy const &args,
                        detail::kwds_proxy const &kwds) const;



      operator bool_type() const;
      bool operator!() const;



      const_object_attribute attr(char const*) const;
      object_attribute attr(char const*);
      const_object_objattribute attr(object const&) const;
      object_objattribute attr(object const&);


      template <class T>
      object contains(T const& key) const;



      const_object_item operator[](object_cref) const;
      object_item operator[](object_cref);

      template <class T>
      const_object_item
      operator[](T const& key) const;

      template <class T>
      object_item
      operator[](T const& key);



      const_object_slice slice(object_cref, object_cref) const;
      object_slice slice(object_cref, object_cref);

      const_object_slice slice(slice_nil, object_cref) const;
      object_slice slice(slice_nil, object_cref);

      const_object_slice slice(object_cref, slice_nil) const;
      object_slice slice(object_cref, slice_nil);

      const_object_slice slice(slice_nil, slice_nil) const;
      object_slice slice(slice_nil, slice_nil);

      template <class T, class V>
      const_object_slice
      slice(T const& start, V const& end) const;

      template <class T, class V>
      object_slice
      slice(T const& start, V const& end);

   private:

      template <class ClassT, class DocStringT>
      void visit(ClassT& cl, char const* name, python::detail::def_helper<DocStringT> const& helper) const
      {


          static_assert((detail::is_same<char const*,DocStringT>::value || detail::is_string_literal<DocStringT const>::value), "(detail::is_same<char const*,DocStringT>::value || detail::is_string_literal<DocStringT const>::value)")

                                                                      ;

          objects::add_to_namespace(cl, name, this->derived_visitor(), helper.doc());
      }

      friend class python::def_visitor_access;

   private:




    typedef object const& object_cref2;



  };





  struct object_base : object_operators<object>
  {

      inline object_base(object_base const&);
      inline object_base(PyObject* ptr);

      inline object_base& operator=(object_base const& rhs);
      inline ~object_base();


      inline PyObject* ptr() const;

      inline bool is_none() const;

   private:
      PyObject* m_ptr;
  };

  template <class T, class U>
  struct is_derived
    : boost::python::detail::is_convertible<
          typename detail::remove_reference<T>::type*
        , U const*
      >
  {};

  template <class T>
  typename objects::unforward_cref<T>::type do_unforward_cref(T const& x)
  {
      return x;
  }

  class object;

  template <class T>
  PyObject* object_base_initializer(T const& x)
  {
      typedef typename is_derived<
          typename objects::unforward_cref<T>::type
        , object
      >::type is_obj;

      return object_initializer<
          typename unwrap_reference<T>::type
      >::get(
            x
          , is_obj()
      );
  }

  class object : public object_base
  {
   public:

      object();


      template <class T>
      explicit object(T const& x)
        : object_base(object_base_initializer(x))
      {
      }


      explicit object(handle<> const&);
   private:

   public:
      explicit object(detail::borrowed_reference);
      explicit object(detail::new_reference);
      explicit object(detail::new_non_null_reference);
  };
# 276 "/usr/local/include/boost/python/object_core.hpp" 3
  template <bool is_proxy = false, bool is_object_manager = false>
  struct object_initializer_impl
  {
      static PyObject*
      get(object const& x, detail::true_)
      {
          return python::incref(x.ptr());
      }

      template <class T>
      static PyObject*
      get(T const& x, detail::false_)
      {
          return python::incref(converter::arg_to_python<T>(x).get());
      }
  };

  template <>
  struct object_initializer_impl<true, false>
  {
      template <class Policies>
      static PyObject*
      get(proxy<Policies> const& x, detail::false_)
      {
          return python::incref(x.operator object().ptr());
      }
  };

  template <>
  struct object_initializer_impl<false, true>
  {
      template <class T, class U>
      static PyObject*
      get(T const& x, U)
      {
          return python::incref(get_managed_object(x, boost::python::tag));
      }
  };

  template <>
  struct object_initializer_impl<true, true>
  {};

  template <class T>
  struct object_initializer : object_initializer_impl<
      is_proxy<T>::value
    , converter::is_object_manager<T>::value
  >
  {};

}
using api::object;
template <class T> struct extract;





namespace detail
{

class call_proxy
{
public:
  call_proxy(object target) : m_target(target) {}
  operator object() const { return m_target;}

 private:
    object m_target;
};

class kwds_proxy : public call_proxy
{
public:
  kwds_proxy(object o = object()) : call_proxy(o) {}
};
class args_proxy : public call_proxy
{
public:
  args_proxy(object o) : call_proxy(o) {}
  kwds_proxy operator* () const { return kwds_proxy(*this);}
};
}

template <typename U>
detail::args_proxy api::object_operators<U>::operator* () const
{
  object_cref2 x = *static_cast<U const*>(this);
  return boost::python::detail::args_proxy(x);
}

template <typename U>
object api::object_operators<U>::operator()(detail::args_proxy const &args) const
{
  U const& self = *static_cast<U const*>(this);
  PyObject *result = PyObject_Call(get_managed_object(self, boost::python::tag),
                                   args.operator object().ptr(),
                                   0);
  return object(boost::python::detail::new_reference(result));

}

template <typename U>
object api::object_operators<U>::operator()(detail::args_proxy const &args,
                                            detail::kwds_proxy const &kwds) const
{
  U const& self = *static_cast<U const*>(this);
  PyObject *result = PyObject_Call(get_managed_object(self, boost::python::tag),
                                   args.operator object().ptr(),
                                   kwds.operator object().ptr());
  return object(boost::python::detail::new_reference(result));

}


template <typename U>
template <class T>
object api::object_operators<U>::contains(T const& key) const
{
    return this->attr("__contains__")(object(key));
}


inline object::object()
    : object_base(python::incref((&_Py_NoneStruct)))
{}


inline api::object_base::object_base(object_base const& rhs)
    : m_ptr(python::incref(rhs.m_ptr))
{}

inline api::object_base::object_base(PyObject* p)
    : m_ptr(p)
{}

inline api::object_base& api::object_base::operator=(api::object_base const& rhs)
{
    ( ((PyObject*)(rhs.m_ptr))->ob_refcnt++);
    do { if ( --((PyObject*)(this->m_ptr))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(this->m_ptr)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(this->m_ptr)))); } while (0);
    this->m_ptr = rhs.m_ptr;
    return *this;
}

inline api::object_base::~object_base()
{
    (static_cast <bool> ((((PyObject*)(m_ptr))->ob_refcnt) > 0) ? void (0) : __assert_fail ("Py_REFCNT(m_ptr) > 0", "/usr/local/include/boost/python/object_core.hpp", 422, __extension__ __PRETTY_FUNCTION__));
    do { if ( --((PyObject*)(m_ptr))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(m_ptr)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(m_ptr)))); } while (0);
}

inline object::object(detail::borrowed_reference p)
    : object_base(python::incref((PyObject*)p))
{}

inline object::object(detail::new_reference p)
    : object_base(expect_non_null((PyObject*)p))
{}

inline object::object(detail::new_non_null_reference p)
    : object_base((PyObject*)p)
{}

inline PyObject* api::object_base::ptr() const
{
    return m_ptr;
}

inline bool api::object_base::is_none() const
{
    return (m_ptr == (&_Py_NoneStruct));
}




namespace converter
{
  template <class T> struct object_manager_traits;

  template <>
  struct object_manager_traits<object>
  {
      static const bool is_specialized = true;
      static bool check(PyObject*) { return true; }

      static python::detail::new_non_null_reference adopt(PyObject* x)
      {
          return python::detail::new_non_null_reference(x);
      }

      static PyTypeObject const *get_pytype() {return 0;}

  };
}

inline PyObject* get_managed_object(object const& x, tag_t)
{
    return x.ptr();
}

}}

# 1 "/usr/local/include/boost/python/slice_nil.hpp" 1 3
# 9 "/usr/local/include/boost/python/slice_nil.hpp" 3
# 1 "/usr/local/include/boost/python/object_core.hpp" 1 3
# 10 "/usr/local/include/boost/python/slice_nil.hpp" 2 3

namespace boost { namespace python { namespace api {

class slice_nil : public object
{
 public:
    slice_nil() : object() {}
};


static const slice_nil _ = slice_nil();


template <class T>
struct slice_bound
{
    typedef object type;
};

template <>
struct slice_bound<slice_nil>
{
    typedef slice_nil type;
};

}

using api::slice_nil;

using api::_;


}}
# 479 "/usr/local/include/boost/python/object_core.hpp" 2 3
# 23 "/usr/local/include/boost/python/args.hpp" 2 3






namespace boost { namespace python {

typedef detail::keywords<1> arg;
typedef arg arg_;

namespace detail
{
  template <std::size_t nkeywords>
  struct keywords_base
  {
      static const std::size_t size = nkeywords;

      keyword_range range() const
      {
          return keyword_range(elements, elements + nkeywords);
      }

      keyword elements[nkeywords];

      keywords<nkeywords+1>
      operator,(python::arg const &k) const;

      keywords<nkeywords + 1>
      operator,(char const *name) const;
  };

  template <std::size_t nkeywords>
  struct keywords : keywords_base<nkeywords>
  {
  };

  template <>
  struct keywords<1> : keywords_base<1>
  {
      explicit keywords(char const *name)
      {
          elements[0].name = name;
      }

      template <class T>
      python::arg& operator=(T const& value)
      {
          object z(value);
          elements[0].default_value = handle<>(python::borrowed(object(value).ptr()));
          return *this;
      }

      operator detail::keyword const&() const
      {
          return elements[0];
      }
  };

  template <std::size_t nkeywords>
  inline
  keywords<nkeywords+1>
  keywords_base<nkeywords>::operator,(python::arg const &k) const
  {
      keywords<nkeywords> const& l = *static_cast<keywords<nkeywords> const*>(this);
      python::detail::keywords<nkeywords+1> res;
      std::copy(l.elements, l.elements+nkeywords, res.elements);
      res.elements[nkeywords] = k.elements[0];
      return res;
  }

  template <std::size_t nkeywords>
  inline
  keywords<nkeywords + 1>
  keywords_base<nkeywords>::operator,(char const *name) const
  {
      return this->operator,(python::arg(name));
  }

  template<typename T>
  struct is_keywords
  {
      static const bool value = false;
  };

  template<std::size_t nkeywords>
  struct is_keywords<keywords<nkeywords> >
  {
      static const bool value = true;
  };
  template <class T>
  struct is_reference_to_keywords
  {
      static const bool is_ref = detail::is_reference<T>::value;
      typedef typename detail::remove_reference<T>::type deref;
      typedef typename detail::remove_cv<deref>::type key_t;
      static const bool is_key = is_keywords<key_t>::value;
      static const bool value = (is_ref & is_key);

      typedef mpl::bool_<value> type;
     
  };
}

inline detail::keywords<1> args(char const* name)
{
    return detail::keywords<1>(name);
}
# 141 "/usr/local/include/boost/python/args.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 40 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        inline detail::keywords<2> args( char const* name0 , char const* name1) { detail::keywords<2> result; result.elements[0].name = name0; result.elements[1].name = name1; return result; }


        inline detail::keywords<3> args( char const* name0 , char const* name1 , char const* name2) { detail::keywords<3> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; return result; }


        inline detail::keywords<4> args( char const* name0 , char const* name1 , char const* name2 , char const* name3) { detail::keywords<4> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; return result; }


        inline detail::keywords<5> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4) { detail::keywords<5> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; return result; }


        inline detail::keywords<6> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5) { detail::keywords<6> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; return result; }


        inline detail::keywords<7> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6) { detail::keywords<7> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; return result; }


        inline detail::keywords<8> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7) { detail::keywords<8> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; return result; }


        inline detail::keywords<9> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8) { detail::keywords<9> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; return result; }


        inline detail::keywords<10> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8 , char const* name9) { detail::keywords<10> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; result.elements[9].name = name9; return result; }


        inline detail::keywords<11> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8 , char const* name9 , char const* name10) { detail::keywords<11> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; result.elements[9].name = name9; result.elements[10].name = name10; return result; }


        inline detail::keywords<12> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8 , char const* name9 , char const* name10 , char const* name11) { detail::keywords<12> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; result.elements[9].name = name9; result.elements[10].name = name10; result.elements[11].name = name11; return result; }


        inline detail::keywords<13> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8 , char const* name9 , char const* name10 , char const* name11 , char const* name12) { detail::keywords<13> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; result.elements[9].name = name9; result.elements[10].name = name10; result.elements[11].name = name11; result.elements[12].name = name12; return result; }


        inline detail::keywords<14> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8 , char const* name9 , char const* name10 , char const* name11 , char const* name12 , char const* name13) { detail::keywords<14> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; result.elements[9].name = name9; result.elements[10].name = name10; result.elements[11].name = name11; result.elements[12].name = name12; result.elements[13].name = name13; return result; }


        inline detail::keywords<15> args( char const* name0 , char const* name1 , char const* name2 , char const* name3 , char const* name4 , char const* name5 , char const* name6 , char const* name7 , char const* name8 , char const* name9 , char const* name10 , char const* name11 , char const* name12 , char const* name13 , char const* name14) { detail::keywords<15> result; result.elements[0].name = name0; result.elements[1].name = name1; result.elements[2].name = name2; result.elements[3].name = name3; result.elements[4].name = name4; result.elements[5].name = name5; result.elements[6].name = name6; result.elements[7].name = name7; result.elements[8].name = name8; result.elements[9].name = name9; result.elements[10].name = name10; result.elements[11].name = name11; result.elements[12].name = name12; result.elements[13].name = name13; result.elements[14].name = name14; return result; }
# 142 "/usr/local/include/boost/python/args.hpp" 2 3

}}
# 12 "/usr/local/include/boost/python.hpp" 2 3


# 1 "/usr/local/include/boost/python/bases.hpp" 1 3
# 16 "/usr/local/include/boost/python/bases.hpp" 3
namespace boost { namespace python {




  template < typename Base0 = mpl::void_ , typename Base1 = mpl::void_ , typename Base2 = mpl::void_ , typename Base3 = mpl::void_ , typename Base4 = mpl::void_ , typename Base5 = mpl::void_ , typename Base6 = mpl::void_ , typename Base7 = mpl::void_ , typename Base8 = mpl::void_ , typename Base9 = mpl::void_ >
  struct bases : detail::type_list< Base0 , Base1 , Base2 , Base3 , Base4 , Base5 , Base6 , Base7 , Base8 , Base9 >::type
  {};

  namespace detail
  {
    template <class T> struct specifies_bases
        : mpl::false_
    {
    };

    template < class Base0 , class Base1 , class Base2 , class Base3 , class Base4 , class Base5 , class Base6 , class Base7 , class Base8 , class Base9 >
    struct specifies_bases< bases< Base0 , Base1 , Base2 , Base3 , Base4 , Base5 , Base6 , Base7 , Base8 , Base9 > >
        : mpl::true_
    {
    };
    template <class T, class Prev = bases<> >
    struct select_bases
        : mpl::if_<
                specifies_bases<T>
                , T
                , Prev
          >
    {
    };
  }

}}
# 15 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 17 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 26 "/usr/local/include/boost/python/call_method.hpp" 3
namespace boost { namespace python {





# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
   
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
   
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" ")")
           
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" ")")
            , converter::arg_to_python<A0>(a0).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get() , converter::arg_to_python<A13>(a13).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/call_method.hpp" 1 3
# 46 "/usr/local/include/boost/python/call_method.hpp" 3




template <
    class R
    , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14
    >
typename detail::returnable<R>::type
call_method(PyObject* self, char const* name
    , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13 , A14 const& a14
    , boost::type<R>* = 0
    )
{
    PyObject* const result =
        PyEval_CallMethod(
            self
            , const_cast<char*>(name)
            , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get() , converter::arg_to_python<A13>(a13).get() , converter::arg_to_python<A14>(a14).get()
            );
# 75 "/usr/local/include/boost/python/call_method.hpp" 3
    converter::return_from_python<R> converter;
    return converter(result);
}
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 33 "/usr/local/include/boost/python/call_method.hpp" 2 3



}}
# 18 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/class.hpp" 1 3
# 12 "/usr/local/include/boost/python/class.hpp" 3
# 1 "/usr/local/include/boost/python/class_fwd.hpp" 1 3
# 11 "/usr/local/include/boost/python/class_fwd.hpp" 3
namespace boost { namespace python {

template <
    class T

    , class X1 = ::boost::python::detail::not_specified
    , class X2 = ::boost::python::detail::not_specified
    , class X3 = ::boost::python::detail::not_specified
    >
class class_;

}}
# 13 "/usr/local/include/boost/python/class.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/class.hpp" 1 3
# 13 "/usr/local/include/boost/python/object/class.hpp" 3
namespace boost { namespace python {

namespace objects {

struct class_base : python::api::object
{

    class_base(
        char const* name

        , std::size_t num_types
        , type_info const*const types


        , char const* doc = 0
        );




    void enable_pickling_(bool getstate_manages_dict);

 protected:
    void add_property(
        char const* name, object const& fget, char const* docstr);
    void add_property(char const* name,
        object const& fget, object const& fset, char const* docstr);

    void add_static_property(char const* name, object const& fget);
    void add_static_property(char const* name, object const& fget, object const& fset);


    void setattr(char const* name, object const&);




    void set_instance_size(std::size_t bytes);



    void def_no_init();



    void make_method_static(const char *method_name);
};

}}}
# 14 "/usr/local/include/boost/python/class.hpp" 2 3

# 1 "/usr/local/include/boost/python/object.hpp" 1 3
# 10 "/usr/local/include/boost/python/object.hpp" 3
# 1 "/usr/local/include/boost/python/object_attributes.hpp" 1 3
# 10 "/usr/local/include/boost/python/object_attributes.hpp" 3
# 1 "/usr/local/include/boost/python/proxy.hpp" 1 3
# 9 "/usr/local/include/boost/python/proxy.hpp" 3
# 1 "/usr/local/include/boost/python/object_operators.hpp" 1 3
# 11 "/usr/local/include/boost/python/object_operators.hpp" 3
# 1 "/usr/local/include/boost/python/call.hpp" 1 3
# 12 "/usr/local/include/boost/python/object_operators.hpp" 2 3
# 1 "/usr/local/include/boost/iterator/detail/enable_if.hpp" 1 3
# 13 "/usr/local/include/boost/iterator/detail/enable_if.hpp" 3
# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 14 "/usr/local/include/boost/iterator/detail/enable_if.hpp" 2 3







namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
# 62 "/usr/local/include/boost/iterator/detail/enable_if.hpp" 3
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {
    };

  }

}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 82 "/usr/local/include/boost/iterator/detail/enable_if.hpp" 2 3
# 13 "/usr/local/include/boost/python/object_operators.hpp" 2 3


# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 16 "/usr/local/include/boost/python/object_operators.hpp" 2 3

namespace boost { namespace python { namespace api {

template <class X>
char is_object_operators_helper(object_operators<X> const*);

typedef char (&no_type)[2];
no_type is_object_operators_helper(...);

template <class X> X* make_ptr();

template <class L, class R = L>
struct is_object_operators
{
    enum {
        value
        = (sizeof(api::is_object_operators_helper(api::make_ptr<L>()))
           + sizeof(api::is_object_operators_helper(api::make_ptr<R>()))
           < 4
        )
    };
    typedef mpl::bool_<value> type;
};


template <class L, class R, class T>
struct enable_binary
  : boost::iterators::enable_if<is_object_operators<L,R>, T>
{};





template <class U>
object object_operators<U>::operator()() const
{
    object_cref2 f = *static_cast<U const*>(this);
    return call<object>(f.ptr());
}


template <class U>
inline
object_operators<U>::operator bool_type() const
{
    object_cref2 x = *static_cast<U const*>(this);
    int is_true = PyObject_IsTrue(x.ptr());
    if (is_true < 0) throw_error_already_set();
    return is_true ? &object::ptr : 0;
}

template <class U>
inline bool
object_operators<U>::operator!() const
{
    object_cref2 x = *static_cast<U const*>(this);
    int is_true = PyObject_IsTrue(x.ptr());
    if (is_true < 0) throw_error_already_set();
    return !is_true;
}
# 94 "/usr/local/include/boost/python/object_operators.hpp" 3
 object operator >(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator >(L const& l, R const& r) { return object(l) > object(r); }
 object operator >=(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator >=(L const& l, R const& r) { return object(l) >= object(r); }
 object operator <(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator <(L const& l, R const& r) { return object(l) < object(r); }
 object operator <=(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator <=(L const& l, R const& r) { return object(l) <= object(r); }
 object operator ==(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator ==(L const& l, R const& r) { return object(l) == object(r); }
 object operator !=(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator !=(L const& l, R const& r) { return object(l) != object(r); }
 object operator +(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator +(L const& l, R const& r) { return object(l) + object(r); }
 object operator -(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator -(L const& l, R const& r) { return object(l) - object(r); }
 object operator *(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator *(L const& l, R const& r) { return object(l) * object(r); }
 object operator /(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator /(L const& l, R const& r) { return object(l) / object(r); }
 object operator %(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator %(L const& l, R const& r) { return object(l) % object(r); }
 object operator <<(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator <<(L const& l, R const& r) { return object(l) << object(r); }
 object operator >>(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator >>(L const& l, R const& r) { return object(l) >> object(r); }
 object operator &(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator &(L const& l, R const& r) { return object(l) & object(r); }
 object operator ^(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator ^(L const& l, R const& r) { return object(l) ^ object(r); }
 object operator |(object const& l, object const& r); template <class L, class R> typename enable_binary<L,R,object>::type operator |(L const& l, R const& r) { return object(l) | object(r); }
# 120 "/usr/local/include/boost/python/object_operators.hpp" 3
 object& operator +=(object& l, object const& r); template <class R> object& operator +=(object& l, R const& r) { return l += object(r); }
 object& operator -=(object& l, object const& r); template <class R> object& operator -=(object& l, R const& r) { return l -= object(r); }
 object& operator *=(object& l, object const& r); template <class R> object& operator *=(object& l, R const& r) { return l *= object(r); }
 object& operator /=(object& l, object const& r); template <class R> object& operator /=(object& l, R const& r) { return l /= object(r); }
 object& operator %=(object& l, object const& r); template <class R> object& operator %=(object& l, R const& r) { return l %= object(r); }
 object& operator <<=(object& l, object const& r); template <class R> object& operator <<=(object& l, R const& r) { return l <<= object(r); }
 object& operator >>=(object& l, object const& r); template <class R> object& operator >>=(object& l, R const& r) { return l >>= object(r); }
 object& operator &=(object& l, object const& r); template <class R> object& operator &=(object& l, R const& r) { return l &= object(r); }
 object& operator ^=(object& l, object const& r); template <class R> object& operator ^=(object& l, R const& r) { return l ^= object(r); }
 object& operator |=(object& l, object const& r); template <class R> object& operator |=(object& l, R const& r) { return l |= object(r); }


}}}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 135 "/usr/local/include/boost/python/object_operators.hpp" 2 3
# 10 "/usr/local/include/boost/python/proxy.hpp" 2 3

namespace boost { namespace python { namespace api {

template <class Policies>
class proxy : public object_operators<proxy<Policies> >
{
    typedef typename Policies::key_type key_type;

    typedef proxy const& assignment_self;
 public:
    proxy(object const& target, key_type const& key);
    operator object() const;


    proxy const& operator=(assignment_self) const;

    template <class T>
    inline proxy const& operator=(T const& rhs) const
    {
        Policies::set(m_target, m_key, object(rhs));
        return *this;
    }

 public:
    void del() const;

 private:
    object m_target;
    key_type m_key;
};


template <class T>
inline void del(proxy<T> const& x)
{
    x.del();
}





template <class Policies>
inline proxy<Policies>::proxy(object const& target, key_type const& key)
    : m_target(target), m_key(key)
{}

template <class Policies>
inline proxy<Policies>::operator object() const
{
    return Policies::get(m_target, m_key);
}


template <class Policies>
inline proxy<Policies> const& proxy<Policies>::operator=(typename proxy::assignment_self rhs) const
{
    return *this = python::object(rhs);
}
# 77 "/usr/local/include/boost/python/proxy.hpp" 3
template <class Policies, class R> proxy<Policies> const& operator +=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old += rhs); }
template <class Policies, class R> proxy<Policies> const& operator -=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old -= rhs); }
template <class Policies, class R> proxy<Policies> const& operator *=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old *= rhs); }
template <class Policies, class R> proxy<Policies> const& operator /=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old /= rhs); }
template <class Policies, class R> proxy<Policies> const& operator %=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old %= rhs); }
template <class Policies, class R> proxy<Policies> const& operator <<=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old <<= rhs); }
template <class Policies, class R> proxy<Policies> const& operator >>=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old >>= rhs); }
template <class Policies, class R> proxy<Policies> const& operator &=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old &= rhs); }
template <class Policies, class R> proxy<Policies> const& operator ^=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old ^= rhs); }
template <class Policies, class R> proxy<Policies> const& operator |=(proxy<Policies> const& lhs, R const& rhs) { object old(lhs); return lhs = (old |= rhs); }


template <class Policies>
inline void proxy<Policies>::del() const
{
    Policies::del(m_target, m_key);
}

}}}
# 11 "/usr/local/include/boost/python/object_attributes.hpp" 2 3

# 1 "/usr/local/include/boost/python/object_protocol.hpp" 1 3
# 10 "/usr/local/include/boost/python/object_protocol.hpp" 3
# 1 "/usr/local/include/boost/python/object_protocol_core.hpp" 1 3
# 12 "/usr/local/include/boost/python/object_protocol_core.hpp" 3
namespace boost { namespace python {

namespace api
{
  class object;

  object getattr(object const& target, object const& key);
  object getattr(object const& target, object const& key, object const& default_);
  void setattr(object const& target, object const& key, object const& value);
  void delattr(object const& target, object const& key);



  object getattr(object const& target, char const* key);
  object getattr(object const& target, char const* key, object const& default_);
  void setattr(object const& target, char const* key, object const& value);
  void delattr(object const& target, char const* key);

  object getitem(object const& target, object const& key);
  void setitem(object const& target, object const& key, object const& value);
  void delitem(object const& target, object const& key);

  object getslice(object const& target, handle<> const& begin, handle<> const& end);
  void setslice(object const& target, handle<> const& begin, handle<> const& end, object const& value);
  void delslice(object const& target, handle<> const& begin, handle<> const& end);
}

using api::getattr;
using api::setattr;
using api::delattr;

using api::getitem;
using api::setitem;
using api::delitem;

using api::getslice;
using api::setslice;
using api::delslice;

}}
# 11 "/usr/local/include/boost/python/object_protocol.hpp" 2 3




namespace boost { namespace python { namespace api {
# 26 "/usr/local/include/boost/python/object_protocol.hpp" 3
template <class Target, class Key>
object getattr(Target const& target, Key const& key )
{
    return getattr(object(target), object(key));
}

template <class Target, class Key, class Default>
object getattr(Target const& target, Key const& key, Default const& default_ )
{
    return getattr(object(target), object(key), object(default_));
}


template <class Key, class Value>
void setattr(object const& target, Key const& key, Value const& value )
{
    setattr(target, object(key), object(value));
}

template <class Key>
void delattr(object const& target, Key const& key )
{
    delattr(target, object(key));
}

template <class Target, class Key>
object getitem(Target const& target, Key const& key )
{
    return getitem(object(target), object(key));
}


template <class Key, class Value>
void setitem(object const& target, Key const& key, Value const& value )
{
    setitem(target, object(key), object(value));
}

template <class Key>
void delitem(object const& target, Key const& key )
{
    delitem(target, object(key));
}

template <class Target, class Begin, class End>
object getslice(Target const& target, Begin const& begin, End const& end)
{
    return getslice(object(target), object(begin), object(end));
}

template <class Begin, class End, class Value>
void setslice(object const& target, Begin const& begin, End const& end, Value const& value)
{
    setslice(target, object(begin), object(end), object(value));
}

template <class Begin, class End>
void delslice(object const& target, Begin const& begin, End const& end)
{
    delslice(target, object(begin), object(end));
}

}}}
# 13 "/usr/local/include/boost/python/object_attributes.hpp" 2 3

namespace boost { namespace python { namespace api {

struct const_attribute_policies
{
    typedef char const* key_type;
    static object get(object const& target, char const* key);
    static object get(object const& target, object const& key);
};

struct attribute_policies : const_attribute_policies
{
    static object const& set(object const& target, char const* key, object const& value);
    static void del(object const&target, char const* key);
};

struct const_objattribute_policies
{
    typedef object const key_type;
    static object get(object const& target, object const& key);
};

struct objattribute_policies : const_objattribute_policies
{
    static object const& set(object const& target, object const& key, object const& value);
    static void del(object const&target, object const& key);
};




template <class U>
inline object_attribute object_operators<U>::attr(char const* name)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_attribute(x, name);
}

template <class U>
inline const_object_attribute object_operators<U>::attr(char const* name) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_attribute(x, name);
}

template <class U>
inline object_objattribute object_operators<U>::attr(object const& name)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_objattribute(x, name);
}

template <class U>
inline const_object_objattribute object_operators<U>::attr(object const& name) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_objattribute(x, name);
}

inline object const_attribute_policies::get(object const& target, char const* key)
{
    return python::getattr(target, key);
}

inline object const_objattribute_policies::get(object const& target, object const& key)
{
    return python::getattr(target, key);
}

inline object const& attribute_policies::set(
    object const& target
    , char const* key
    , object const& value)
{
    python::setattr(target, key, value);
    return value;
}

inline object const& objattribute_policies::set(
    object const& target
    , object const& key
    , object const& value)
{
    python::setattr(target, key, value);
    return value;
}

inline void attribute_policies::del(
    object const& target
    , char const* key)
{
    python::delattr(target, key);
}

inline void objattribute_policies::del(
    object const& target
    , object const& key)
{
    python::delattr(target, key);
}

}}}
# 11 "/usr/local/include/boost/python/object.hpp" 2 3
# 1 "/usr/local/include/boost/python/object_items.hpp" 1 3
# 14 "/usr/local/include/boost/python/object_items.hpp" 3
namespace boost { namespace python { namespace api {

struct const_item_policies
{
    typedef object key_type;
    static object get(object const& target, object const& key);
};

struct item_policies : const_item_policies
{
    static object const& set(object const& target, object const& key, object const& value);
    static void del(object const& target, object const& key);
};




template <class U>
inline object_item
object_operators<U>::operator[](object_cref key)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_item(x, key);
}

template <class U>
inline const_object_item
object_operators<U>::operator[](object_cref key) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_item(x, key);
}

template <class U>
template <class T>
inline const_object_item
object_operators<U>::operator[](T const& key) const
{
    return (*this)[object(key)];
}

template <class U>
template <class T>
inline object_item
object_operators<U>::operator[](T const& key)
{
    return (*this)[object(key)];
}

inline object const_item_policies::get(object const& target, object const& key)
{
    return getitem(target, key);
}

inline object const& item_policies::set(
    object const& target
    , object const& key
    , object const& value)
{
    setitem(target, key, value);
    return value;
}

inline void item_policies::del(
    object const& target
    , object const& key)
{
    delitem(target, key);
}

}}}
# 12 "/usr/local/include/boost/python/object.hpp" 2 3
# 1 "/usr/local/include/boost/python/object_slices.hpp" 1 3
# 16 "/usr/local/include/boost/python/object_slices.hpp" 3
namespace boost { namespace python { namespace api {

struct const_slice_policies
{
    typedef std::pair<handle<>, handle<> > key_type;
    static object get(object const& target, key_type const& key);
};

struct slice_policies : const_slice_policies
{
    static object const& set(object const& target, key_type const& key, object const& value);
    static void del(object const& target, key_type const& key);
};

template <class T, class U>
inline slice_policies::key_type slice_key(T x, U y)
{
    return slice_policies::key_type(handle<>(x), handle<>(y));
}




template <class U>
object_slice
object_operators<U>::slice(object_cref start, object_cref finish)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_slice(x, api::slice_key(borrowed(start.ptr()), borrowed(finish.ptr())));
}

template <class U>
const_object_slice
object_operators<U>::slice(object_cref start, object_cref finish) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_slice(x, api::slice_key(borrowed(start.ptr()), borrowed(finish.ptr())));
}

template <class U>
object_slice
object_operators<U>::slice(slice_nil, object_cref finish)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_slice(x, api::slice_key(allow_null((PyObject*)0), borrowed(finish.ptr())));
}

template <class U>
const_object_slice
object_operators<U>::slice(slice_nil, object_cref finish) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_slice(x, api::slice_key(allow_null((PyObject*)0), borrowed(finish.ptr())));
}

template <class U>
object_slice
object_operators<U>::slice(slice_nil, slice_nil)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_slice(x, api::slice_key(allow_null((PyObject*)0), allow_null((PyObject*)0)));
}

template <class U>
const_object_slice
object_operators<U>::slice(slice_nil, slice_nil) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_slice(x, api::slice_key(allow_null((PyObject*)0), allow_null((PyObject*)0)));
}

template <class U>
object_slice
object_operators<U>::slice(object_cref start, slice_nil)
{
    object_cref2 x = *static_cast<U*>(this);
    return object_slice(x, api::slice_key(borrowed(start.ptr()), allow_null((PyObject*)0)));
}

template <class U>
const_object_slice
object_operators<U>::slice(object_cref start, slice_nil) const
{
    object_cref2 x = *static_cast<U const*>(this);
    return const_object_slice(x, api::slice_key(borrowed(start.ptr()), allow_null((PyObject*)0)));
}

template <class U>
template <class T, class V>
inline const_object_slice
object_operators<U>::slice(T const& start, V const& end) const
{
    return this->slice(
        typename slice_bound<T>::type(start)
        , typename slice_bound<V>::type(end));
}

template <class U>
template <class T, class V>
inline object_slice
object_operators<U>::slice(T const& start, V const& end)
{
    return this->slice(
        typename slice_bound<T>::type(start)
        , typename slice_bound<V>::type(end));
}

inline object const_slice_policies::get(object const& target, key_type const& key)
{
    return getslice(target, key.first, key.second);
}

inline object const& slice_policies::set(
    object const& target
    , key_type const& key
    , object const& value)
{
    setslice(target, key.first, key.second, value);
    return value;
}

inline void slice_policies::del(
    object const& target
    , key_type const& key)
{
    delslice(target, key.first, key.second);
}

}}}
# 13 "/usr/local/include/boost/python/object.hpp" 2 3



namespace boost { namespace python {

    inline ssize_t len(object const& obj)
    {
        ssize_t result = PyObject_Size(obj.ptr());
        if (PyErr_Occurred()) throw_error_already_set();
        return result;
    }

}}
# 16 "/usr/local/include/boost/python/class.hpp" 2 3

# 1 "/usr/local/include/boost/python/data_members.hpp" 1 3
# 12 "/usr/local/include/boost/python/data_members.hpp" 3
# 1 "/usr/local/include/boost/python/return_value_policy.hpp" 1 3
# 11 "/usr/local/include/boost/python/return_value_policy.hpp" 3
namespace boost { namespace python {

template <class ResultConverterGenerator, class BasePolicy_ = default_call_policies>
struct return_value_policy : BasePolicy_
{
    typedef ResultConverterGenerator result_converter;
};

}}
# 13 "/usr/local/include/boost/python/data_members.hpp" 2 3
# 1 "/usr/local/include/boost/python/return_by_value.hpp" 1 3
# 15 "/usr/local/include/boost/python/return_by_value.hpp" 3
namespace boost { namespace python {

struct return_by_value
{
    template <class R>
    struct apply
    {
       typedef to_python_value<
           typename detail::value_arg<R>::type
       > type;
    };
};

}}
# 14 "/usr/local/include/boost/python/data_members.hpp" 2 3
# 1 "/usr/local/include/boost/python/return_internal_reference.hpp" 1 3
# 11 "/usr/local/include/boost/python/return_internal_reference.hpp" 3
# 1 "/usr/local/include/boost/python/reference_existing_object.hpp" 1 3
# 14 "/usr/local/include/boost/python/reference_existing_object.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <class R>
  struct reference_existing_object_requires_a_pointer_or_reference_return_type

  {}

  ;
}

template <class T> struct to_python_value;

struct reference_existing_object
{
    template <class T>
    struct apply
    {
        static const bool ok = detail::is_pointer<T>::value || detail::is_reference<T>::value
                                                                                      ;

        typedef typename mpl::if_c<
            ok
            , to_python_indirect<T, detail::make_reference_holder>
            , detail::reference_existing_object_requires_a_pointer_or_reference_return_type<T>
        >::type type;
    };
};

}}
# 12 "/usr/local/include/boost/python/return_internal_reference.hpp" 2 3
# 1 "/usr/local/include/boost/python/with_custodian_and_ward.hpp" 1 3
# 11 "/usr/local/include/boost/python/with_custodian_and_ward.hpp" 3
# 1 "/usr/local/include/boost/python/object/life_support.hpp" 1 3
# 9 "/usr/local/include/boost/python/object/life_support.hpp" 3
namespace boost { namespace python { namespace objects {

 PyObject* make_nurse_and_patient(PyObject* nurse, PyObject* patient);

}}}
# 12 "/usr/local/include/boost/python/with_custodian_and_ward.hpp" 2 3


namespace boost { namespace python {

namespace detail
{
  template <std::size_t N>
  struct get_prev
  {
      template <class ArgumentPackage>
      static PyObject* execute(ArgumentPackage const& args, PyObject* = 0)
      {
          int const pre_n = static_cast<int>(N) - 1;
          return detail::get(mpl::int_<pre_n>(), args);
      }
  };
  template <>
  struct get_prev<0>
  {
      template <class ArgumentPackage>
      static PyObject* execute(ArgumentPackage const&, PyObject* zeroth)
      {
          return zeroth;
      }
  };
}
template <
    std::size_t custodian
  , std::size_t ward
  , class BasePolicy_ = default_call_policies
>
struct with_custodian_and_ward : BasePolicy_
{
    static_assert(custodian != ward, "custodian != ward");
    static_assert(custodian > 0, "custodian > 0");
    static_assert(ward > 0, "ward > 0");

    template <class ArgumentPackage>
    static bool precall(ArgumentPackage const& args_)
    {
        unsigned arity_ = detail::arity(args_);
        if (custodian > arity_ || ward > arity_)
        {
            PyErr_SetString(
                PyExc_IndexError
              , "boost::python::with_custodian_and_ward: argument index out of range"
            );
            return false;
        }

        PyObject* patient = detail::get_prev<ward>::execute(args_);
        PyObject* nurse = detail::get_prev<custodian>::execute(args_);

        PyObject* life_support = python::objects::make_nurse_and_patient(nurse, patient);
        if (life_support == 0)
            return false;

        bool result = BasePolicy_::precall(args_);

        if (!result) {
            do { if ( --((PyObject*)(life_support))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(life_support)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(life_support)))); } while (0);
        }

        return result;
    }
};

template <std::size_t custodian, std::size_t ward, class BasePolicy_ = default_call_policies>
struct with_custodian_and_ward_postcall : BasePolicy_
{
    static_assert(custodian != ward, "custodian != ward");

    template <class ArgumentPackage>
    static PyObject* postcall(ArgumentPackage const& args_, PyObject* result)
    {
        std::size_t arity_ = detail::arity(args_);



        if ( (std::max)(custodian, ward) > arity_ )
        {
            PyErr_SetString(
                PyExc_IndexError
              , "boost::python::with_custodian_and_ward_postcall: argument index out of range"
            );
            return 0;
        }

        PyObject* patient = detail::get_prev<ward>::execute(args_, result);
        PyObject* nurse = detail::get_prev<custodian>::execute(args_, result);

        if (nurse == 0) return 0;

        result = BasePolicy_::postcall(args_, result);
        if (result == 0)
            return 0;

        if (python::objects::make_nurse_and_patient(nurse, patient) == 0)
        {
            do { if ((result) == __null) ; else do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0); } while (0);
            return 0;
        }
        return result;
    }
};


}}
# 13 "/usr/local/include/boost/python/return_internal_reference.hpp" 2 3


namespace boost { namespace python {

namespace detail
{
  template <std::size_t>
  struct return_internal_reference_owner_arg_must_be_greater_than_zero

  {}

  ;
}

template <std::size_t owner_arg = 1, class BasePolicy_ = default_call_policies>
struct return_internal_reference
    : with_custodian_and_ward_postcall<0, owner_arg, BasePolicy_>
{
 private:
    static const bool legal = owner_arg > 0;
 public:
    typedef typename mpl::if_c<
        legal
        , reference_existing_object
        , detail::return_internal_reference_owner_arg_must_be_greater_than_zero<owner_arg>
    >::type result_converter;
};

}}
# 15 "/usr/local/include/boost/python/data_members.hpp" 2 3
# 1 "/usr/local/include/boost/python/make_function.hpp" 1 3
# 12 "/usr/local/include/boost/python/make_function.hpp" 3
# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 13 "/usr/local/include/boost/python/make_function.hpp" 2 3

# 1 "/usr/local/include/boost/python/object/function_object.hpp" 1 3







# 1 "/usr/local/include/boost/function/function2.hpp" 1 3
# 11 "/usr/local/include/boost/function/function2.hpp" 3
# 1 "/usr/local/include/boost/function/detail/maybe_include.hpp" 1 3
# 29 "/usr/local/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/usr/local/include/boost/function/function_template.hpp" 1 3
# 86 "/usr/local/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct function_invoker2
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);
          return f( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct void_function_invoker2
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);
          f( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_obj_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          return (*f)( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_obj_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          (*f)( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_ref_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          return (*f)( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_ref_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);
          (*f)( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct function_mem_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(function_obj_ptr.data);
          return boost::mem_fn(*f)( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };

      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct function_void_mem_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          MemberPtr* f =
            reinterpret_cast<MemberPtr*>(function_obj_ptr.data);
          boost::mem_fn(*f)( static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
        }
      };


      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct get_function_invoker2
      {
        typedef typename conditional<(is_void<R>::value),
                            void_function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >,
                          function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_obj_invoker2
      {
        typedef typename conditional<(is_void<R>::value),
                            void_function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_ref_invoker2
      {
        typedef typename conditional<(is_void<R>::value),
                            void_function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };



      template<
        typename MemberPtr,
        typename R ,
        typename T0 , typename T1
       >
      struct get_member_invoker2
      {
        typedef typename conditional<(is_void<R>::value),
                            function_void_mem_invoker2<
                            MemberPtr,
                            R ,
                            T0 , T1
                          >,
                          function_mem_invoker2<
                            MemberPtr,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };
# 331 "/usr/local/include/boost/function/function_template.hpp" 3
      template<typename Tag>
      struct get_invoker2 { };


      template<>
      struct get_invoker2<function_ptr_tag>
      {
        template<typename FunctionPtr,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };

        template<typename FunctionPtr, typename Allocator,
                 typename R , typename T0 , typename T1>
        struct apply_a
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<FunctionPtr> manager_type;
        };
      };



      template<>
      struct get_invoker2<member_ptr_tag>
      {
        template<typename MemberPtr,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_member_invoker2<
                             MemberPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };

        template<typename MemberPtr, typename Allocator,
                 typename R , typename T0 , typename T1>
        struct apply_a
        {
          typedef typename get_member_invoker2<
                             MemberPtr,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<MemberPtr> manager_type;
        };
      };



      template<>
      struct get_invoker2<function_obj_tag>
      {
        template<typename FunctionObj,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager<FunctionObj> manager_type;
        };

        template<typename FunctionObj, typename Allocator,
                 typename R , typename T0 , typename T1>
        struct apply_a
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef functor_manager_a<FunctionObj, Allocator> manager_type;
        };
      };


      template<>
      struct get_invoker2<function_obj_ref_tag>
      {
        template<typename RefWrapper,
                 typename R , typename T0 , typename T1>
        struct apply
        {
          typedef typename get_function_ref_invoker2<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };

        template<typename RefWrapper, typename Allocator,
                 typename R , typename T0 , typename T1>
        struct apply_a
        {
          typedef typename get_function_ref_invoker2<
                             typename RefWrapper::type,
                             R ,
                             T0 , T1
                           >::type
            invoker_type;

          typedef reference_manager<typename RefWrapper::type> manager_type;
        };
      };
# 476 "/usr/local/include/boost/function/function_template.hpp" 3
      template<typename R , typename T0 , typename T1>
      struct basic_vtable2
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1);

        template<typename F>
        bool assign_to(F f, function_buffer& functor) const
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a) const
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor) const
        {
          if (base.manager)
            base.manager(functor, functor, destroy_functor_tag);
        }

      private:

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag) const
        {
          this->clear(functor);
          if (f) {


            functor.members.func_ptr = reinterpret_cast<void (*)()>(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag) const
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag) const
        {



          if (f) {
            this->assign_to(boost::mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag) const
        {



          if (f) {
            this->assign_to_a(boost::mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }




        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, true_type) const
        {
          new (reinterpret_cast<void*>(functor.data)) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, true_type) const
        {
          assign_functor(f,functor,true_type());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, false_type) const
        {
          functor.members.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, false_type) const
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;





          using wrapper_allocator_type = typename std::allocator_traits<Allocator>::template rebind_alloc<functor_wrapper_type>;
          using wrapper_allocator_pointer_type = typename std::allocator_traits<wrapper_allocator_type>::pointer;

          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);



          std::allocator_traits<wrapper_allocator_type>::construct(wrapper_allocator, copy, functor_wrapper_type(f,a));

          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.members.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag) const
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           integral_constant<bool, (function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag) const
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           integral_constant<bool, (function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag) const
        {
          functor.members.obj_ref.obj_ptr = (void *)(f.get_pointer());
          functor.members.obj_ref.is_const_qualified = is_const<FunctionObj>::value;
          functor.members.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;
          return true;
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag) const
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        vtable_base base;
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1
  >
  class function2 : public function_base
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable2<
              R , T0 , T1>
      vtable_type;

    vtable_type* get_vtable() const {
      return reinterpret_cast<vtable_type*>(
               reinterpret_cast<std::size_t>(vtable) & ~static_cast<std::size_t>(0x01));
    }

    struct clear_type {};

  public:
    static const int args = 2;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };




    typedef T0 first_argument_type;
    typedef T1 second_argument_type;


    static const int arity = 2;
    typedef T0 arg1_type; typedef T1 arg2_type;

    typedef function2 self_type;

    function2() = default;



    template<typename Functor>
    function2(Functor f

                            ,typename boost::enable_if_<
                             !(is_integral<Functor>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function2(Functor f, Allocator a

                            ,typename boost::enable_if_<
                              !(is_integral<Functor>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function2(clear_type*) : function_base() { }







    function2(const function2& f) : function_base()
    {
      this->assign_to_own(f);
    }


    function2(function2&& f) : function_base()
    {
      this->move_assign(f);
    }


    ~function2() { clear(); }

    result_type operator()( T0 a0 , T1 a1) const
    {
      if (this->empty())
        boost::throw_exception(bad_function_call());

      return get_vtable()->invoker
               (this->functor , static_cast<T0&&>(a0) , static_cast<T1&&>(a1));
    }






    template<typename Functor>

    typename boost::enable_if_<
                  !(is_integral<Functor>::value),
               function2&>::type



    operator=(Functor f)
    {
      this->clear();
      { try {
        this->assign_to(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      { try{
        this->assign_to_a(f,a);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }


    function2& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 821 "/usr/local/include/boost/function/function_template.hpp" 3
    function2& operator=(const function2& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->assign_to_own(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }



    function2& operator=(function2&& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      { try {
        this->move_assign(f);
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
      return *this;
    }


    void swap(function2& other)
    {
      if (&other == this)
        return;

      function2 tmp;
      tmp.move_assign(*this);
      this->move_assign(other);
      other.move_assign(tmp);
    }


    void clear()
    {
      if (vtable) {
        if (!this->has_trivial_copy_and_destroy())
          get_vtable()->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {}
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function2& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        if (this->has_trivial_copy_and_destroy())


          std::memcpy(this->functor.data, f.functor.data, sizeof(boost::detail::function::function_buffer));
        else
          get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      using boost::detail::function::vtable_base;

      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;
      typedef boost::detail::function::get_invoker2<tag> get_invoker;
      typedef typename get_invoker::
                         template apply<Functor, R ,
                        T0 , T1>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static const vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to(f, functor)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);

        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            boost::detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= static_cast<std::size_t>(0x01);
        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }

    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      using boost::detail::function::vtable_base;

      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;
      typedef boost::detail::function::get_invoker2<tag> get_invoker;
      typedef typename get_invoker::
                         template apply_a<Functor, Allocator, R ,
                         T0 , T1>
        handler_type;

      typedef typename handler_type::invoker_type invoker_type;
      typedef typename handler_type::manager_type manager_type;





      static const vtable_type stored_vtable =
        { { &manager_type::manage }, &invoker_type::invoke };

      if (stored_vtable.assign_to_a(f, functor, a)) {
        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);

        if (boost::has_trivial_copy_constructor<Functor>::value &&
            boost::has_trivial_destructor<Functor>::value &&
            boost::detail::function::function_allows_small_object_optimization<Functor>::value)
          value |= static_cast<std::size_t>(0x01);
        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);
      } else
        vtable = 0;
    }




    void move_assign(function2& f)
    {
      if (&f == this)
        return;

      { try {
        if (!f.empty()) {
          this->vtable = f.vtable;
          if (this->has_trivial_copy_and_destroy())


            std::memcpy(this->functor.data, f.functor.data, sizeof(this->functor.data));
          else
            get_vtable()->base.manager(f.functor, this->functor,
                                     boost::detail::function::move_functor_tag);
          f.vtable = 0;
        } else {
          clear();
        }
      } catch(...) {
        vtable = 0;
        throw;;
      }
      }
    }
  };

  template<typename R , typename T0 , typename T1>
  inline void swap(function2<
                     R ,
                     T0 , T1
                   >& f1,
                   function2<
                     R ,
                     T0 , T1
                   >& f2)
  {
    f1.swap(f2);
  }


template<typename R , typename T0 , typename T1>
  void operator==(const function2<
                          R ,
                          T0 , T1>&,
                  const function2<
                          R ,
                          T0 , T1>&);
template<typename R , typename T0 , typename T1>
  void operator!=(const function2<
                          R ,
                          T0 , T1>&,
                  const function2<
                          R ,
                          T0 , T1>& );
# 1046 "/usr/local/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1>
class function<R ( T0 , T1)>
  : public function2<R , T0 , T1>
{
  typedef function2<R , T0 , T1> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() = default;

  template<typename Functor>
  function(Functor f

           ,typename boost::enable_if_<
                          !(is_integral<Functor>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename boost::enable_if_<
                           !(is_integral<Functor>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}



  function(self_type&& f): base_type(static_cast<base_type&&>(f)){}
  function(base_type&& f): base_type(static_cast<base_type&&>(f)){}


  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(self_type&& f)
  {
    self_type(static_cast<self_type&&>(f)).swap(*this);
    return *this;
  }


  template<typename Functor>

  typename boost::enable_if_<
                         !(is_integral<Functor>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(base_type&& f)
  {
    self_type(static_cast<base_type&&>(f)).swap(*this);
    return *this;
  }

};




}
# 30 "/usr/local/include/boost/function/detail/maybe_include.hpp" 2 3
# 12 "/usr/local/include/boost/function/function2.hpp" 2 3
# 9 "/usr/local/include/boost/python/object/function_object.hpp" 2 3




namespace boost { namespace python {

namespace objects
{
  api::object function_object(
      py_function const& f
      , python::detail::keyword_range const&);

  api::object function_object(
      py_function const& f
      , python::detail::keyword_range const&);

  api::object function_object(py_function const& f);





  void add_to_namespace(
      object const& name_space, char const* name, object const& attribute);

  void add_to_namespace(
      object const& name_space, char const* name, object const& attribute, char const* doc);
}

}}
# 15 "/usr/local/include/boost/python/make_function.hpp" 2 3




namespace boost { namespace python {

namespace detail
{






  template <class F, class CallPolicies, class Sig>
  object make_function_aux(
      F f
      , CallPolicies const& p
      , Sig const&
      )
  {
      return objects::function_object(
          detail::caller<F,CallPolicies,Sig>(f, p)
      );
  }





  template <class F, class CallPolicies, class Sig, class NumKeywords>
  object make_function_aux(
      F f
      , CallPolicies const& p
      , Sig const&
      , detail::keyword_range const& kw
      , NumKeywords
      )
  {
      enum { arity = mpl::size<Sig>::value - 1 };

      typedef typename detail::error::more_keywords_than_function_arguments<
          NumKeywords::value, arity
          >::too_many_keywords assertion __attribute__((__unused__));

      return objects::function_object(
          detail::caller<F,CallPolicies,Sig>(f, p)
        , kw);
  }






  template <class F, class CallPolicies, class Keywords>
  object make_function_dispatch(F f, CallPolicies const& policies, Keywords const& kw, mpl::true_)
  {
      return detail::make_function_aux(
          f
        , policies
        , detail::get_signature(f)
        , kw.range()
        , mpl::int_<Keywords::size>()
      );
  }

  template <class F, class CallPolicies, class Signature>
  object make_function_dispatch(F f, CallPolicies const& policies, Signature const& sig, mpl::false_)
  {
      return detail::make_function_aux(
          f
        , policies
        , sig
      );
  }


 }






template <class F>
object make_function(F f)
{
    return detail::make_function_aux(
        f,default_call_policies(), detail::get_signature(f));
}

template <class F, class CallPolicies>
object make_function(F f, CallPolicies const& policies)
{
    return detail::make_function_aux(
        f, policies, detail::get_signature(f));
}

template <class F, class CallPolicies, class KeywordsOrSignature>
object make_function(
    F f
  , CallPolicies const& policies
  , KeywordsOrSignature const& keywords_or_signature)
{
    typedef typename
        detail::is_reference_to_keywords<KeywordsOrSignature&>::type
        is_kw;

    return detail::make_function_dispatch(
        f
      , policies
      , keywords_or_signature
      , is_kw()
    );
}

template <class F, class CallPolicies, class Keywords, class Signature>
object make_function(
    F f
  , CallPolicies const& policies
  , Keywords const& kw
  , Signature const& sig
 )
{
    return detail::make_function_aux(
          f
        , policies
        , sig
        , kw.range()
        , mpl::int_<Keywords::size>()
      );
}


}}
# 16 "/usr/local/include/boost/python/data_members.hpp" 2 3
# 30 "/usr/local/include/boost/python/data_members.hpp" 3
namespace boost { namespace python {
# 39 "/usr/local/include/boost/python/data_members.hpp" 3
namespace detail
{



  template <class Data, class Class>
  struct member
  {
   public:
      member(Data Class::*which) : m_which(which) {}

      Data& operator()(Class& c) const
      {
          return c.*m_which;
      }

      void operator()(Class& c, typename value_arg<Data>::type d) const
      {
          c.*m_which = d;
      }
   private:
      Data Class::*m_which;
  };



  template <class Data>
  struct datum
  {
   public:
      datum(Data *which) : m_which(which) {}

      Data& operator()() const
      {
          return *m_which;
      }

      void operator()(typename value_arg<Data>::type d) const
      {
          *m_which = d;
      }
   private:
      Data *m_which;
  };
# 95 "/usr/local/include/boost/python/data_members.hpp" 3
  template <class T>
  struct default_getter_by_ref
      : mpl::and_<
          mpl::bool_<
              to_python_value<
                  typename value_arg<T>::type
              >::uses_registry
          >
        , indirect_traits::is_reference_to_class<
              typename value_arg<T>::type
          >
       >
  {
  };
# 118 "/usr/local/include/boost/python/data_members.hpp" 3
  template <class T>
  struct default_member_getter_policy
    : mpl::if_<
          default_getter_by_ref<T>
        , return_internal_reference<>
        , return_value_policy<return_by_value>
      >
  {};



  template <class T>
  struct default_datum_getter_policy
    : mpl::if_<
          default_getter_by_ref<T>
        , return_value_policy<reference_existing_object>
        , return_value_policy<return_by_value>
      >
  {};
# 155 "/usr/local/include/boost/python/data_members.hpp" 3
  template <class D, class Policies>
  inline object make_getter(D* d, Policies const& policies, detail::false_, int)
  {
      return python::make_function(
          detail::datum<D>(d), policies, mpl::vector1<D&>()
      );
  }


  template <class D>
  inline object make_getter(D* d, not_specified, detail::false_, long)
  {
      typedef typename default_datum_getter_policy<D>::type policies;
      return detail::make_getter(d, policies(), detail::false_(), 0);
  }


  template <class C, class D, class Policies>
  inline object make_getter(D C::*pm, Policies const& policies, detail::true_, int)
  {



      typedef C Class;

      return python::make_function(
          detail::member<D,Class>(pm)
        , policies
        , mpl::vector2<D&,Class&>()
      );
  }


  template <class C, class D>
  inline object make_getter(D C::*pm, not_specified, detail::true_, long)
  {
      typedef typename default_member_getter_policy<D>::type policies;
      return detail::make_getter(pm, policies(), detail::true_(), 0);
  }


  template <class D, class P>
  inline object make_getter(D& d, P& p, detail::false_, ...)
  {

      return detail::make_getter(&d, p, detail::false_(), 0L);
  }
# 212 "/usr/local/include/boost/python/data_members.hpp" 3
  template <class D, class Policies>
  inline object make_setter(D* p, Policies const& policies, detail::false_, int)
  {
      return python::make_function(
          detail::datum<D>(p), policies, mpl::vector2<void,D const&>()
      );
  }


  template <class C, class D, class Policies>
  inline object make_setter(D C::*pm, Policies const& policies, detail::true_, int)
  {
      return python::make_function(
          detail::member<D,C>(pm)
        , policies
        , mpl::vector3<void, C&, D const&>()
      );
  }


  template <class D, class Policies>
  inline object make_setter(D& x, Policies const& policies, detail::false_, ...)
  {
      return detail::make_setter(&x, policies, detail::false_(), 0L);
  }
}
# 246 "/usr/local/include/boost/python/data_members.hpp" 3
template <class D, class Policies>
inline object make_getter(D& d, Policies const& policies)
{
    return detail::make_getter(d, policies, detail::is_member_pointer<D>(), 0L);
}

template <class D, class Policies>
inline object make_getter(D const& d, Policies const& policies)
{
    return detail::make_getter(d, policies, detail::is_member_pointer<D>(), 0L);
}

template <class D>
inline object make_getter(D& x)
{
    detail::not_specified policy
        = detail::not_specified();
    return detail::make_getter(x, policy, detail::is_member_pointer<D>(), 0L);
}


template <class D>
inline object make_getter(D const& d)
{
    detail::not_specified policy
        = detail::not_specified();
    return detail::make_getter(d, policy, detail::is_member_pointer<D>(), 0L);
}
# 283 "/usr/local/include/boost/python/data_members.hpp" 3
template <class D, class Policies>
inline object make_setter(D& x, Policies const& policies)
{
    return detail::make_setter(x, policies, detail::is_member_pointer<D>(), 0);
}

template <class D, class Policies>
inline object make_setter(D const& x, Policies const& policies)
{
    return detail::make_setter(x, policies, detail::is_member_pointer<D>(), 0);
}

template <class D>
inline object make_setter(D& x)
{
    return detail::make_setter(x, default_call_policies(), detail::is_member_pointer<D>(), 0);
}


template <class D>
inline object make_setter(D const& x)
{
    return detail::make_setter(x, default_call_policies(), detail::is_member_pointer<D>(), 0);
}


}}
# 18 "/usr/local/include/boost/python/class.hpp" 2 3

# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 20 "/usr/local/include/boost/python/class.hpp" 2 3
# 1 "/usr/local/include/boost/python/init.hpp" 1 3
# 16 "/usr/local/include/boost/python/init.hpp" 3
# 1 "/usr/local/include/boost/python/detail/make_keyword_range_fn.hpp" 1 3
# 11 "/usr/local/include/boost/python/detail/make_keyword_range_fn.hpp" 3
# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 34 "/usr/local/include/boost/python/object/make_holder.hpp" 3
namespace boost { namespace python { namespace objects {

template <int nargs> struct make_holder;





# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<0>
{
    template <class Holder, class ArgList>
    struct apply
    {
# 82 "/usr/local/include/boost/python/object/make_holder.hpp" 3
        static void execute(



            PyObject *p

            )
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p ))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<1>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<2>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<3>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<4>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<5>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<6>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<7>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<8>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<9>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<10>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;


        typedef typename mpl::deref<iter9>::type t9; typedef typename forward<t9>::type f9; typedef typename mpl::next<iter9>::type iter10;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8 , t9 a9)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8) , f9(a9)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<11>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;


        typedef typename mpl::deref<iter9>::type t9; typedef typename forward<t9>::type f9; typedef typename mpl::next<iter9>::type iter10;


        typedef typename mpl::deref<iter10>::type t10; typedef typename forward<t10>::type f10; typedef typename mpl::next<iter10>::type iter11;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8 , t9 a9 , t10 a10)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8) , f9(a9) , f10(a10)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<12>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;


        typedef typename mpl::deref<iter9>::type t9; typedef typename forward<t9>::type f9; typedef typename mpl::next<iter9>::type iter10;


        typedef typename mpl::deref<iter10>::type t10; typedef typename forward<t10>::type f10; typedef typename mpl::next<iter10>::type iter11;


        typedef typename mpl::deref<iter11>::type t11; typedef typename forward<t11>::type f11; typedef typename mpl::next<iter11>::type iter12;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8 , t9 a9 , t10 a10 , t11 a11)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8) , f9(a9) , f10(a10) , f11(a11)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<13>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;


        typedef typename mpl::deref<iter9>::type t9; typedef typename forward<t9>::type f9; typedef typename mpl::next<iter9>::type iter10;


        typedef typename mpl::deref<iter10>::type t10; typedef typename forward<t10>::type f10; typedef typename mpl::next<iter10>::type iter11;


        typedef typename mpl::deref<iter11>::type t11; typedef typename forward<t11>::type f11; typedef typename mpl::next<iter11>::type iter12;


        typedef typename mpl::deref<iter12>::type t12; typedef typename forward<t12>::type f12; typedef typename mpl::next<iter12>::type iter13;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8 , t9 a9 , t10 a10 , t11 a11 , t12 a12)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8) , f9(a9) , f10(a10) , f11(a11) , f12(a12)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<14>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;


        typedef typename mpl::deref<iter9>::type t9; typedef typename forward<t9>::type f9; typedef typename mpl::next<iter9>::type iter10;


        typedef typename mpl::deref<iter10>::type t10; typedef typename forward<t10>::type f10; typedef typename mpl::next<iter10>::type iter11;


        typedef typename mpl::deref<iter11>::type t11; typedef typename forward<t11>::type f11; typedef typename mpl::next<iter11>::type iter12;


        typedef typename mpl::deref<iter12>::type t12; typedef typename forward<t12>::type f12; typedef typename mpl::next<iter12>::type iter13;


        typedef typename mpl::deref<iter13>::type t13; typedef typename forward<t13>::type f13; typedef typename mpl::next<iter13>::type iter14;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8 , t9 a9 , t10 a10 , t11 a11 , t12 a12 , t13 a13)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8) , f9(a9) , f10(a10) , f11(a11) , f12(a12) , f13(a13)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 56 "/usr/local/include/boost/python/object/make_holder.hpp" 3




template <>
struct make_holder<15>
{
    template <class Holder, class ArgList>
    struct apply
    {




        typedef typename mpl::begin<ArgList>::type iter0;
# 79 "/usr/local/include/boost/python/object/make_holder.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        typedef typename mpl::deref<iter0>::type t0; typedef typename forward<t0>::type f0; typedef typename mpl::next<iter0>::type iter1;


        typedef typename mpl::deref<iter1>::type t1; typedef typename forward<t1>::type f1; typedef typename mpl::next<iter1>::type iter2;


        typedef typename mpl::deref<iter2>::type t2; typedef typename forward<t2>::type f2; typedef typename mpl::next<iter2>::type iter3;


        typedef typename mpl::deref<iter3>::type t3; typedef typename forward<t3>::type f3; typedef typename mpl::next<iter3>::type iter4;


        typedef typename mpl::deref<iter4>::type t4; typedef typename forward<t4>::type f4; typedef typename mpl::next<iter4>::type iter5;


        typedef typename mpl::deref<iter5>::type t5; typedef typename forward<t5>::type f5; typedef typename mpl::next<iter5>::type iter6;


        typedef typename mpl::deref<iter6>::type t6; typedef typename forward<t6>::type f6; typedef typename mpl::next<iter6>::type iter7;


        typedef typename mpl::deref<iter7>::type t7; typedef typename forward<t7>::type f7; typedef typename mpl::next<iter7>::type iter8;


        typedef typename mpl::deref<iter8>::type t8; typedef typename forward<t8>::type f8; typedef typename mpl::next<iter8>::type iter9;


        typedef typename mpl::deref<iter9>::type t9; typedef typename forward<t9>::type f9; typedef typename mpl::next<iter9>::type iter10;


        typedef typename mpl::deref<iter10>::type t10; typedef typename forward<t10>::type f10; typedef typename mpl::next<iter10>::type iter11;


        typedef typename mpl::deref<iter11>::type t11; typedef typename forward<t11>::type f11; typedef typename mpl::next<iter11>::type iter12;


        typedef typename mpl::deref<iter12>::type t12; typedef typename forward<t12>::type f12; typedef typename mpl::next<iter12>::type iter13;


        typedef typename mpl::deref<iter13>::type t13; typedef typename forward<t13>::type f13; typedef typename mpl::next<iter13>::type iter14;


        typedef typename mpl::deref<iter14>::type t14; typedef typename forward<t14>::type f14; typedef typename mpl::next<iter14>::type iter15;
# 80 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3


        static void execute(



            PyObject *p

            , t0 a0 , t1 a1 , t2 a2 , t3 a3 , t4 a4 , t5 a5 , t6 a6 , t7 a7 , t8 a8 , t9 a9 , t10 a10 , t11 a11 , t12 a12 , t13 a13 , t14 a14)
        {
            typedef instance<Holder> instance_t;

            void* memory = Holder::allocate(p, __builtin_offsetof (instance_t, storage), sizeof(Holder));
            try {
                (new (memory) Holder(
                    p , f0(a0) , f1(a1) , f2(a2) , f3(a3) , f4(a4) , f5(a5) , f6(a6) , f7(a7) , f8(a8) , f9(a9) , f10(a10) , f11(a11) , f12(a12) , f13(a13) , f14(a14)))->install(p);
            }
            catch(...) {
                Holder::deallocate(p, memory);
                throw;
            }
        }
    };
};
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 43 "/usr/local/include/boost/python/object/make_holder.hpp" 2 3



}}}
# 12 "/usr/local/include/boost/python/detail/make_keyword_range_fn.hpp" 2 3




namespace boost { namespace python { namespace detail {
# 25 "/usr/local/include/boost/python/detail/make_keyword_range_fn.hpp" 3
template <class F, class Policies>
object make_keyword_range_function(
    F f
  , Policies const& policies
  , keyword_range const& kw)
{
    return detail::make_function_aux(
        f, policies, detail::get_signature(f), kw, mpl::int_<0>());
}

template <class F, class Policies, class Signature>
object make_keyword_range_function(
    F f
  , Policies const& policies
  , keyword_range const& kw
  , Signature const& sig)
{
    return detail::make_function_aux(
        f, policies, sig, kw, mpl::int_<0>());
}
# 53 "/usr/local/include/boost/python/detail/make_keyword_range_fn.hpp" 3
template <class ArgList, class Arity, class Holder, class CallPolicies>
object make_keyword_range_constructor(
    CallPolicies const& policies
    , detail::keyword_range const& kw
    , Holder* = 0
    , ArgList* = 0, Arity* = 0)
{



    return detail::make_keyword_range_function(
        objects::make_holder<Arity::value>
            ::template apply<Holder,ArgList>::execute
        , policies
        , kw);
}

}}}
# 17 "/usr/local/include/boost/python/init.hpp" 2 3






# 1 "/usr/local/include/boost/mpl/empty.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/empty.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/empty_impl.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/empty_impl.hpp" 3
namespace boost { namespace mpl {




template< typename Tag >
struct empty_impl
{
    template< typename Sequence > struct apply
        : is_same<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {
    };
};

 template<> struct empty_impl<non_sequence_tag> {};

}}
# 20 "/usr/local/include/boost/mpl/empty.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct empty
    : empty_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct empty< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : empty< T1 > { }; }; template< typename Tag > struct lambda< empty< na > , Tag , int_<-1> > { typedef false_ is_le; typedef empty< na > result_; typedef empty< na > type; }; namespace aux { template< typename T1 > struct template_arity< empty< T1 > > : int_<1> { }; template<> struct template_arity< empty< na > > : int_<-1> { }; }

}}
# 24 "/usr/local/include/boost/python/init.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/joint_view.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/joint_view.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/joint_iter.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/joint_iter.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/lambda_spec.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/joint_iter.hpp" 2 3






namespace boost { namespace mpl {



template<
      typename Iterator1
    , typename LastIterator1
    , typename Iterator2
    >
struct joint_iter
{
    typedef Iterator1 base;
    typedef forward_iterator_tag category;
};

template<
      typename LastIterator1
    , typename Iterator2
    >
struct joint_iter<LastIterator1,LastIterator1,Iterator2>
{
    typedef Iterator2 base;
    typedef forward_iterator_tag category;
};


template< typename I1, typename L1, typename I2 >
struct deref< joint_iter<I1,L1,I2> >
{
    typedef typename joint_iter<I1,L1,I2>::base base_;
    typedef typename deref<base_>::type type;
};

template< typename I1, typename L1, typename I2 >
struct next< joint_iter<I1,L1,I2> >
{
    typedef joint_iter< typename mpl::next<I1>::type,L1,I2 > type;
};

template< typename L1, typename I2 >
struct next< joint_iter<L1,L1,I2> >
{
    typedef joint_iter< L1,L1,typename mpl::next<I2>::type > type;
};
# 116 "/usr/local/include/boost/mpl/aux_/joint_iter.hpp" 3
template< typename T1 , typename T2 , typename T3 , typename Tag > struct lambda< joint_iter< T1 , T2 , T3 > , Tag , int_<3> > { typedef false_ is_le; typedef joint_iter< T1 , T2 , T3 > result_; typedef result_ type; };

}}
# 18 "/usr/local/include/boost/mpl/joint_view.hpp" 2 3





namespace boost { namespace mpl {

namespace aux {
struct joint_view_tag;
}

template<>
struct size_impl< aux::joint_view_tag >
{
    template < typename JointView > struct apply
      : plus<
            size<typename JointView::sequence1_>
          , size<typename JointView::sequence2_>
          >
    {};
};

template<
      typename Sequence1_ = na
    , typename Sequence2_ = na
    >
struct joint_view
{
    typedef typename mpl::begin<Sequence1_>::type first1_;
    typedef typename mpl::end<Sequence1_>::type last1_;
    typedef typename mpl::begin<Sequence2_>::type first2_;
    typedef typename mpl::end<Sequence2_>::type last2_;


    typedef Sequence1_ sequence1_;
    typedef Sequence2_ sequence2_;

    typedef joint_view type;
    typedef aux::joint_view_tag tag;
    typedef joint_iter<first1_,last1_,first2_> begin;
    typedef joint_iter<last1_,last1_,last2_> end;
};

template<> struct joint_view< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : joint_view< T1 , T2 > { }; }; template< typename Tag > struct lambda< joint_view< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef joint_view< na , na > result_; typedef joint_view< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< joint_view< T1 , T2 > > : int_<2> { }; template<> struct template_arity< joint_view< na , na > > : int_<-1> { }; }

}}
# 28 "/usr/local/include/boost/python/init.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/back.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/back.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/back_impl.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/back_impl.hpp" 3
namespace boost { namespace mpl {





template< typename Tag >
struct back_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename end<Sequence>::type end_;
        typedef typename prior<end_>::type last_;
        typedef typename deref<last_>::type type;
    };
};

 template<> struct back_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/back.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct back
    : back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct back< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : back< T1 > { }; }; template< typename Tag > struct lambda< back< na > , Tag , int_<-1> > { typedef false_ is_le; typedef back< na > result_; typedef back< na > type; }; namespace aux { template< typename T1 > struct template_arity< back< T1 > > : int_<1> { }; template<> struct template_arity< back< na > > : int_<-1> { }; }

}}
# 29 "/usr/local/include/boost/python/init.hpp" 2 3
# 55 "/usr/local/include/boost/python/init.hpp" 3
namespace boost { namespace python {

template < class T0 = mpl::void_ , class T1 = mpl::void_ , class T2 = mpl::void_ , class T3 = mpl::void_ , class T4 = mpl::void_ , class T5 = mpl::void_ , class T6 = mpl::void_ , class T7 = mpl::void_ , class T8 = mpl::void_ , class T9 = mpl::void_ , class T10 = mpl::void_ , class T11 = mpl::void_ , class T12 = mpl::void_ , class T13 = mpl::void_ , class T14 = mpl::void_ >
class init;


template < class T0 = mpl::void_ , class T1 = mpl::void_ , class T2 = mpl::void_ , class T3 = mpl::void_ , class T4 = mpl::void_ , class T5 = mpl::void_ , class T6 = mpl::void_ , class T7 = mpl::void_ , class T8 = mpl::void_ , class T9 = mpl::void_ , class T10 = mpl::void_ , class T11 = mpl::void_ , class T12 = mpl::void_ , class T13 = mpl::void_ , class T14 = mpl::void_ >
struct optional;

namespace detail
{
  namespace error
  {
    template <int keywords, int init_args>
    struct more_keywords_than_init_arguments
    {
        typedef char too_many_keywords[init_args - keywords >= 0 ? 1 : -1] __attribute__((__unused__));
    };
  }






    template <class T>
    struct is_optional
      : mpl::false_
    {};

    template < class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
    struct is_optional<optional< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> >
      : mpl::true_
    {};


  template <int NDefaults>
  struct define_class_init_helper;

}

template <class DerivedT>
struct init_base : def_visitor<DerivedT>
{
    init_base(char const* doc_, detail::keyword_range const& keywords_)
        : m_doc(doc_), m_keywords(keywords_)
    {}

    init_base(char const* doc_)
        : m_doc(doc_)
    {}

    DerivedT const& derived() const
    {
        return *static_cast<DerivedT const*>(this);
    }

    char const* doc_string() const
    {
        return m_doc;
    }

    detail::keyword_range const& keywords() const
    {
        return m_keywords;
    }

    static default_call_policies call_policies()
    {
        return default_call_policies();
    }

 private:
# 142 "/usr/local/include/boost/python/init.hpp" 3
    template <class classT>
    void visit(classT& cl) const
    {
        typedef typename DerivedT::signature signature;
        typedef typename DerivedT::n_arguments n_arguments;
        typedef typename DerivedT::n_defaults n_defaults;

        detail::define_class_init_helper<n_defaults::value>::apply(
            cl
          , derived().call_policies()
          , signature()
          , n_arguments()
          , derived().doc_string()
          , derived().keywords());
    }

    friend class python::def_visitor_access;

 private:
    char const* m_doc;
    detail::keyword_range m_keywords;
};

template <class CallPoliciesT, class InitT>
class init_with_call_policies
    : public init_base<init_with_call_policies<CallPoliciesT, InitT> >
{
    typedef init_base<init_with_call_policies<CallPoliciesT, InitT> > base;
 public:
    typedef typename InitT::n_arguments n_arguments;
    typedef typename InitT::n_defaults n_defaults;
    typedef typename InitT::signature signature;

    init_with_call_policies(
        CallPoliciesT const& policies_
        , char const* doc_
        , detail::keyword_range const& keywords
        )
        : base(doc_, keywords)
        , m_policies(policies_)
    {}

    CallPoliciesT const& call_policies() const
    {
        return this->m_policies;
    }

 private:
    CallPoliciesT m_policies;
};




namespace detail
{
  template <class S>
  struct drop1
    : mpl::iterator_range<
          typename mpl::begin<S>::type
        , typename mpl::prior<
              typename mpl::end<S>::type
          >::type
      >
  {};
}

template < class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
class init : public init_base<init< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> >
{
    typedef init_base<init< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> > base;
 public:
    typedef init< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> self_t;

    init(char const* doc_ = 0)
        : base(doc_)
    {
    }

    template <std::size_t N>
    init(char const* doc_, detail::keywords<N> const& kw)
        : base(doc_, kw.range())
    {
        typedef typename detail::error::more_keywords_than_init_arguments<
            N, n_arguments::value + 1
            >::too_many_keywords assertion __attribute__((__unused__));
    }

    template <std::size_t N>
    init(detail::keywords<N> const& kw, char const* doc_ = 0)
        : base(doc_, kw.range())
    {
        typedef typename detail::error::more_keywords_than_init_arguments<
            N, n_arguments::value + 1
            >::too_many_keywords assertion __attribute__((__unused__));
    }

    template <class CallPoliciesT>
    init_with_call_policies<CallPoliciesT, self_t>
    operator[](CallPoliciesT const& policies) const
    {
        return init_with_call_policies<CallPoliciesT, self_t>(
            policies, this->doc_string(), this->keywords());
    }

    typedef detail::type_list< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> signature_;

    typedef detail::is_optional<
        typename mpl::eval_if<
            mpl::empty<signature_>
          , mpl::false_
          , mpl::back<signature_>
        >::type
    > back_is_optional;

    typedef typename mpl::eval_if<
        back_is_optional
      , mpl::back<signature_>
      , mpl::vector0<>
    >::type optional_args;

    typedef typename mpl::eval_if<
        back_is_optional
      , mpl::if_<
            mpl::empty<optional_args>
          , detail::drop1<signature_>
          , mpl::joint_view<
                detail::drop1<signature_>
              , optional_args
            >
        >
      , signature_
    >::type signature;




    typedef mpl::size<optional_args> n_defaults;
    typedef mpl::size<signature> n_arguments;
};
# 290 "/usr/local/include/boost/python/init.hpp" 3
template < class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct optional
    : detail::type_list< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
{
};

namespace detail
{
  template <class ClassT, class CallPoliciesT, class Signature, class NArgs>
  inline void def_init_aux(
      ClassT& cl
      , Signature const&
      , NArgs
      , CallPoliciesT const& policies
      , char const* doc
      , detail::keyword_range const& keywords_
      )
  {
      cl.def(
          "__init__"
        , detail::make_keyword_range_constructor<Signature,NArgs>(
              policies
            , keywords_
            , (typename ClassT::metadata::holder*)0
          )
        , doc
      );
  }
# 331 "/usr/local/include/boost/python/init.hpp" 3
  template <int NDefaults>
  struct define_class_init_helper
  {

      template <class ClassT, class CallPoliciesT, class Signature, class NArgs>
      static void apply(
          ClassT& cl
          , CallPoliciesT const& policies
          , Signature const& args
          , NArgs
          , char const* doc
          , detail::keyword_range keywords)
      {
          detail::def_init_aux(cl, args, NArgs(), policies, doc, keywords);

          if (keywords.second > keywords.first)
              --keywords.second;

          typedef typename mpl::prior<NArgs>::type next_nargs;
          define_class_init_helper<NDefaults-1>::apply(
              cl, policies, Signature(), next_nargs(), doc, keywords);
      }
  };
# 365 "/usr/local/include/boost/python/init.hpp" 3
  template <>
  struct define_class_init_helper<0> {

      template <class ClassT, class CallPoliciesT, class Signature, class NArgs>
      static void apply(
          ClassT& cl
        , CallPoliciesT const& policies
        , Signature const& args
        , NArgs
        , char const* doc
        , detail::keyword_range const& keywords)
      {
          detail::def_init_aux(cl, args, NArgs(), policies, doc, keywords);
      }
  };
}

}}
# 21 "/usr/local/include/boost/python/class.hpp" 2 3


# 1 "/usr/local/include/boost/python/object/class_metadata.hpp" 1 3
# 10 "/usr/local/include/boost/python/object/class_metadata.hpp" 3
# 1 "/usr/local/include/boost/python/converter/shared_ptr_from_python.hpp" 1 3
# 21 "/usr/local/include/boost/python/converter/shared_ptr_from_python.hpp" 3
namespace boost { namespace python { namespace converter {

template <class T, template <typename> class SP>
struct shared_ptr_from_python
{
  shared_ptr_from_python()
  {
    converter::registry::insert(&convertible, &construct, type_id<SP<T> >()

    , &converter::expected_from_python_type_direct<T>::get_pytype

    );
  }

 private:
  static void* convertible(PyObject* p)
  {
    if (p == (&_Py_NoneStruct))
      return p;

    return converter::get_lvalue_from_python(p, registered<T>::converters);
  }

  static void construct(PyObject* source, rvalue_from_python_stage1_data* data)
  {
    void* const storage = ((converter::rvalue_from_python_storage<SP<T> >*)data)->storage.bytes;

    if (data->convertible == source)
      new (storage) SP<T>();
    else
    {
      SP<void> hold_convertible_ref_count(
  (void*)0, shared_ptr_deleter(handle<>(borrowed(source))) );

      new (storage) SP<T>(hold_convertible_ref_count,
     static_cast<T*>(data->convertible));
    }

    data->convertible = storage;
  }
};

}}}
# 11 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/inheritance.hpp" 1 3
# 14 "/usr/local/include/boost/python/object/inheritance.hpp" 3
namespace boost { namespace python { namespace objects {

typedef type_info class_id;
using python::type_id;


typedef std::pair<void*,class_id> dynamic_id_t;
typedef dynamic_id_t (*dynamic_id_function)(void*);

 void register_dynamic_id_aux(
    class_id static_id, dynamic_id_function get_dynamic_id);

 void add_cast(
    class_id src_t, class_id dst_t, void* (*cast)(void*), bool is_downcast);
# 36 "/usr/local/include/boost/python/object/inheritance.hpp" 3
template <class T>
struct polymorphic_id_generator
{
    static dynamic_id_t execute(void* p_)
    {
        T* p = static_cast<T*>(p_);
        return std::make_pair(dynamic_cast<void*>(p), class_id(typeid(*p)));
    }
};


template <class T>
struct non_polymorphic_id_generator
{
    static dynamic_id_t execute(void* p_)
    {
        return std::make_pair(p_, python::type_id<T>());
    }
};


template <class T>
struct dynamic_id_generator
  : mpl::if_<
        boost::python::detail::is_polymorphic<T>
        , boost::python::objects::polymorphic_id_generator<T>
        , boost::python::objects::non_polymorphic_id_generator<T>
    >
{};



template <class T>
void register_dynamic_id(T* = 0)
{
    typedef typename dynamic_id_generator<T>::type generator;
    register_dynamic_id_aux(
        python::type_id<T>(), &generator::execute);
}







template <class Source, class Target>
struct dynamic_cast_generator
{
    static void* execute(void* source)
    {
        return dynamic_cast<Target*>(
            static_cast<Source*>(source));
    }

};

template <class Source, class Target>
struct implicit_cast_generator
{
    static void* execute(void* source)
    {
        Target* result = static_cast<Source*>(source);
        return result;
    }
};

template <class Source, class Target>
struct cast_generator
  : mpl::if_<
        boost::python::detail::is_base_and_derived<Target,Source>
      , implicit_cast_generator<Source,Target>
      , dynamic_cast_generator<Source,Target>
    >
{
};

template <class Source, class Target>
inline void register_conversion(
    bool is_downcast = ::boost::is_base_and_derived<Source,Target>::value

    , Source* = 0, Target* = 0)
{
    typedef typename cast_generator<Source,Target>::type generator;

    add_cast(
        python::type_id<Source>()
      , python::type_id<Target>()
      , &generator::execute
      , is_downcast
    );
}

}}}
# 12 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/class_wrapper.hpp" 1 3







# 1 "/usr/local/include/boost/python/to_python_converter.hpp" 1 3
# 11 "/usr/local/include/boost/python/to_python_converter.hpp" 3
# 1 "/usr/local/include/boost/python/converter/as_to_python_function.hpp" 1 3
# 9 "/usr/local/include/boost/python/converter/as_to_python_function.hpp" 3
namespace boost { namespace python { namespace converter {



template <class T, class ToPython>
struct as_to_python_function
{




    template <class U>
    static void convert_function_must_take_value_or_const_reference(U(*)(T), int, T* = 0) {}
    template <class U>
    static void convert_function_must_take_value_or_const_reference(U(*)(T const&), long ...) {}

    static PyObject* convert(void const* x)
    {
        convert_function_must_take_value_or_const_reference(&ToPython::convert, 1L);
# 40 "/usr/local/include/boost/python/converter/as_to_python_function.hpp" 3
        return ToPython::convert(*const_cast<T*>(static_cast<T const*>(x)));
    }

    static PyTypeObject const * get_pytype() { return ToPython::get_pytype(); }

};

}}}
# 12 "/usr/local/include/boost/python/to_python_converter.hpp" 2 3





namespace boost { namespace python {
# 47 "/usr/local/include/boost/python/to_python_converter.hpp" 3
template < class T, class Conversion, bool has_get_pytype=false >
struct to_python_converter
{

    typedef boost::mpl::bool_<has_get_pytype> HasGetPytype;

    static PyTypeObject const* get_pytype_1(boost::mpl::true_ *)
    {
        return Conversion::get_pytype();
    }

    static PyTypeObject const* get_pytype_1(boost::mpl::false_ *)
    {
        return 0;
    }
    static PyTypeObject const* get_pytype_impl()
    {
        return get_pytype_1((HasGetPytype*)0);
    }


    to_python_converter();
};





template <class T, class Conversion ,bool has_get_pytype>
to_python_converter<T,Conversion, has_get_pytype>::to_python_converter()
{
    typedef converter::as_to_python_function<
        T, Conversion
        > normalized;

    converter::registry::insert(
        &normalized::convert
        , type_id<T>()

        , &get_pytype_impl

        );
}

}}
# 9 "/usr/local/include/boost/python/object/class_wrapper.hpp" 2 3





namespace boost { namespace python { namespace objects {
# 23 "/usr/local/include/boost/python/object/class_wrapper.hpp" 3
template <class Src, class MakeInstance>
struct class_cref_wrapper
    : to_python_converter<Src,class_cref_wrapper<Src,MakeInstance> ,true>
{
    static PyObject* convert(Src const& x)
    {
        return MakeInstance::execute(boost::ref(x));
    }

    static PyTypeObject const *get_pytype() { return converter::registered_pytype_direct<Src>::get_pytype(); }

};

template <class Src, class MakeInstance>
struct class_value_wrapper
    : to_python_converter<Src,class_value_wrapper<Src,MakeInstance> ,true>
{
    static PyObject* convert(Src x)
    {
        return MakeInstance::execute(x);
    }

    static PyTypeObject const *get_pytype() { return MakeInstance::get_pytype(); }

};

}}}
# 13 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3

# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 11 "/usr/local/include/boost/python/object/value_holder.hpp" 3
# 1 "/usr/local/include/boost/python/object/value_holder_fwd.hpp" 1 3







namespace boost { namespace python { namespace objects {

struct no_back_reference;

template <class CallbackType = no_back_reference> struct value_holder_generator;

}}}
# 12 "/usr/local/include/boost/python/object/value_holder.hpp" 2 3



# 1 "/usr/local/include/boost/python/wrapper.hpp" 1 3







# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 13 "/usr/local/include/boost/python/override.hpp" 3
# 1 "/usr/local/include/boost/python/extract.hpp" 1 3
# 30 "/usr/local/include/boost/python/extract.hpp" 3
namespace boost { namespace python {

namespace api
{
  class object;
}

namespace converter
{
  template <class Ptr>
  struct extract_pointer
  {
      typedef Ptr result_type;
      extract_pointer(PyObject*);

      bool check() const;
      Ptr operator()() const;

   private:
      PyObject* m_source;
      void* m_result;
  };

  template <class Ref>
  struct extract_reference
  {
      typedef Ref result_type;
      extract_reference(PyObject*);

      bool check() const;
      Ref operator()() const;

   private:
      PyObject* m_source;
      void* m_result;
  };

  template <class T>
  struct extract_rvalue : private noncopyable
  {
      typedef typename mpl::if_<
          python::detail::copy_ctor_mutates_rhs<T>
        , T&
        , typename call_traits<T>::param_type
      >::type result_type;

      extract_rvalue(PyObject*);

      bool check() const;
      result_type operator()() const;
   private:
      PyObject* m_source;
      mutable rvalue_from_python_data<T> m_data;
  };

  template <class T>
  struct extract_object_manager
  {
      typedef T result_type;
      extract_object_manager(PyObject*);

      bool check() const;
      result_type operator()() const;
   private:
      PyObject* m_source;
  };

  template <class T>
  struct select_extract
  {
      static const bool obj_mgr = is_object_manager<T>::value
                                                      ;

      static const bool ptr = is_pointer<T>::value
                                           ;

      static const bool ref = is_reference<T>::value
                                             ;

      typedef typename mpl::if_c<
          obj_mgr
          , extract_object_manager<T>
          , typename mpl::if_c<
              ptr
              , extract_pointer<T>
              , typename mpl::if_c<
                  ref
                  , extract_reference<T>
                  , extract_rvalue<T>
                >::type
            >::type
         >::type type;
  };
}

template <class T>
struct extract
    : converter::select_extract<T>::type
{
 private:
    typedef typename converter::select_extract<T>::type base;
 public:
    typedef typename base::result_type result_type;

    operator result_type() const
    {
        return (*this)();
    }

    extract(PyObject*);
    extract(api::object const&);
};




template <class T>
inline extract<T>::extract(PyObject* o)
    : base(o)
{
}

template <class T>
inline extract<T>::extract(api::object const& o)
    : base(o.ptr())
{
}

namespace converter
{
  template <class T>
  inline extract_rvalue<T>::extract_rvalue(PyObject* x)
      : m_source(x)
      , m_data(
          (rvalue_from_python_stage1)(x, registered<T>::converters)
          )
  {
  }

  template <class T>
  inline bool
  extract_rvalue<T>::check() const
  {
      return m_data.stage1.convertible;
  }

  template <class T>
  inline typename extract_rvalue<T>::result_type
  extract_rvalue<T>::operator()() const
  {
      return *(T*)(

          m_data.stage1.convertible == m_data.storage.bytes
             ? m_data.storage.bytes
             : (rvalue_from_python_stage2)(m_source, m_data.stage1, registered<T>::converters)
          );
  }

  template <class Ref>
  inline extract_reference<Ref>::extract_reference(PyObject* obj)
      : m_source(obj)
      , m_result(
          (get_lvalue_from_python)(obj, registered<Ref>::converters)
          )
  {
  }

  template <class Ref>
  inline bool extract_reference<Ref>::check() const
  {
      return m_result != 0;
  }

  template <class Ref>
  inline Ref extract_reference<Ref>::operator()() const
  {
      if (m_result == 0)
          (throw_no_reference_from_python)(m_source, registered<Ref>::converters);

      return python::detail::void_ptr_to_reference(m_result, (Ref(*)())0);
  }

  template <class Ptr>
  inline extract_pointer<Ptr>::extract_pointer(PyObject* obj)
      : m_source(obj)
      , m_result(
          obj == (&_Py_NoneStruct) ? 0 : (get_lvalue_from_python)(obj, registered_pointee<Ptr>::converters)
          )
  {
  }

  template <class Ptr>
  inline bool extract_pointer<Ptr>::check() const
  {
      return m_source == (&_Py_NoneStruct) || m_result != 0;
  }

  template <class Ptr>
  inline Ptr extract_pointer<Ptr>::operator()() const
  {
      if (m_result == 0 && m_source != (&_Py_NoneStruct))
          (throw_no_pointer_from_python)(m_source, registered_pointee<Ptr>::converters);

      return Ptr(m_result);
  }

  template <class T>
  inline extract_object_manager<T>::extract_object_manager(PyObject* obj)
      : m_source(obj)
  {
  }

  template <class T>
  inline bool extract_object_manager<T>::check() const
  {
      return object_manager_traits<T>::check(m_source);
  }

  template <class T>
  inline T extract_object_manager<T>::operator()() const
  {
      return T(
          object_manager_traits<T>::adopt(python::incref(m_source))
          );
  }
}

}}
# 14 "/usr/local/include/boost/python/override.hpp" 2 3
# 24 "/usr/local/include/boost/python/override.hpp" 3
namespace boost { namespace python {

class override;

namespace detail
{
  class wrapper_base;


  class method_result
  {
   private:
      friend class boost::python::override;
      explicit method_result(PyObject* x)
        : m_obj(x)
      {}

   public:
      template <class T>
      operator T()
      {
          converter::return_from_python<T> converter;
          return converter(m_obj.release());
      }
# 62 "/usr/local/include/boost/python/override.hpp" 3
      template <class T>
      operator T&() const
      {
          converter::return_from_python<T&> converter;
          return converter(const_cast<handle<>&>(m_obj).release());
      }


      template <class T>
      T as(type<T>* = 0)
      {
          converter::return_from_python<T> converter;
          return converter(m_obj.release());
      }

      template <class T>
      T unchecked(type<T>* = 0)
      {
          return extract<T>(m_obj.get())();
      }
   private:
      mutable handle<> m_obj;
  };
}

class override : public object
{
 private:
    friend class detail::wrapper_base;
    override(handle<> x)
      : object(x)
    {}

 public:
    detail::method_result
    operator()() const
    {
        detail::method_result x(
            PyEval_CallFunction(
                this->ptr()
              , const_cast<char*>("()")
            ));
        return x;
    }





# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 52 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0
    >
detail::method_result
operator()( A0 const& a0 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" ")")
            , converter::arg_to_python<A0>(a0).get()
        ));
    return x;
}
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get()
        ));
    return x;
}
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get()
        ));
    return x;
}
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get()
        ));
    return x;
}
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get()
        ));
    return x;
}
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get()
        ));
    return x;
}
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get()
        ));
    return x;
}
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get()
        ));
    return x;
}
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get()
        ));
    return x;
}
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get()
        ));
    return x;
}
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get()
        ));
    return x;
}
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get()
        ));
    return x;
}
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get()
        ));
    return x;
}
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get() , converter::arg_to_python<A13>(a13).get()
        ));
    return x;
}
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/override.hpp" 1 3
# 123 "/usr/local/include/boost/python/override.hpp" 3




template <
    class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14
    >
detail::method_result
operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13 , A14 const& a14 ) const
{
    detail::method_result x(
        PyEval_CallFunction(
            this->ptr()
          , const_cast<char*>("(" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" "O" ")")
            , converter::arg_to_python<A0>(a0).get() , converter::arg_to_python<A1>(a1).get() , converter::arg_to_python<A2>(a2).get() , converter::arg_to_python<A3>(a3).get() , converter::arg_to_python<A4>(a4).get() , converter::arg_to_python<A5>(a5).get() , converter::arg_to_python<A6>(a6).get() , converter::arg_to_python<A7>(a7).get() , converter::arg_to_python<A8>(a8).get() , converter::arg_to_python<A9>(a9).get() , converter::arg_to_python<A10>(a10).get() , converter::arg_to_python<A11>(a11).get() , converter::arg_to_python<A12>(a12).get() , converter::arg_to_python<A13>(a13).get() , converter::arg_to_python<A14>(a14).get()
        ));
    return x;
}
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 112 "/usr/local/include/boost/python/override.hpp" 2 3


};

}}
# 9 "/usr/local/include/boost/python/wrapper.hpp" 2 3

# 1 "/usr/local/include/boost/python/detail/sfinae.hpp" 1 3
# 11 "/usr/local/include/boost/python/wrapper.hpp" 2 3

namespace boost { namespace python {

template <class T>
class wrapper : public detail::wrapper_base
{
 public:

    typedef T _wrapper_wrapped_type_;

 protected:
    override get_override(char const* name) const
    {
        typedef detail::wrapper_base base;
        converter::registration const& r
            = converter::registered<T>::converters;
        PyTypeObject* type = r.get_class_object();

        return this->base::get_override(name, type);
    }
};

}}
# 16 "/usr/local/include/boost/python/object/value_holder.hpp" 2 3
# 32 "/usr/local/include/boost/python/object/value_holder.hpp" 3
# 1 "/usr/local/include/boost/utility/addressof.hpp" 1 3
# 33 "/usr/local/include/boost/python/object/value_holder.hpp" 2 3

namespace boost { namespace python { namespace objects {



template <class Value>
struct value_holder : instance_holder
{
    typedef Value held_type;
    typedef Value value_type;



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3







    value_holder(
      PyObject* self )
        : m_held(
           
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0>

    value_holder(
      PyObject* self , A0 a0)
        : m_held(
            objects::do_unforward(a0,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1>

    value_holder(
      PyObject* self , A0 a0 , A1 a1)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 122 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>

    value_holder(
      PyObject* self , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13 , A14 a14)
        : m_held(
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0) , objects::do_unforward(a14,0)
            )
    {
        python::detail::initialize_wrapper(self, boost::addressof(this->m_held));
    }
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/python/object/value_holder.hpp" 2 3

 private:
    void* holds(type_info, bool null_ptr_only);

    template <class T>
    inline void* holds_wrapped(type_info dst_t, wrapper<T>*,T* p)
    {
        return python::type_id<T>() == dst_t ? p : 0;
    }

    inline void* holds_wrapped(type_info, ...)
    {
        return 0;
    }
 private:
    Value m_held;
};

template <class Value, class Held>
struct value_holder_back_reference : instance_holder
{
    typedef Held held_type;
    typedef Value value_type;



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3







    value_holder_back_reference(
        PyObject* p )
        : m_held(
            p
           
            )
    {
    }
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0>

    value_holder_back_reference(
        PyObject* p , A0 a0)
        : m_held(
            p ,
            objects::do_unforward(a0,0)
            )
    {
    }
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0)
            )
    {
    }
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0)
            )
    {
    }
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0)
            )
    {
    }
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0)
            )
    {
    }
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0)
            )
    {
    }
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0)
            )
    {
    }
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0)
            )
    {
    }
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0)
            )
    {
    }
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0)
            )
    {
    }
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0)
            )
    {
    }
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0)
            )
    {
    }
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0)
            )
    {
    }
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0)
            )
    {
    }
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/object/value_holder.hpp" 1 3
# 146 "/usr/local/include/boost/python/object/value_holder.hpp" 3





    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>

    value_holder_back_reference(
        PyObject* p , A0 a0 , A1 a1 , A2 a2 , A3 a3 , A4 a4 , A5 a5 , A6 a6 , A7 a7 , A8 a8 , A9 a9 , A10 a10 , A11 a11 , A12 a12 , A13 a13 , A14 a14)
        : m_held(
            p ,
            objects::do_unforward(a0,0) , objects::do_unforward(a1,0) , objects::do_unforward(a2,0) , objects::do_unforward(a3,0) , objects::do_unforward(a4,0) , objects::do_unforward(a5,0) , objects::do_unforward(a6,0) , objects::do_unforward(a7,0) , objects::do_unforward(a8,0) , objects::do_unforward(a9,0) , objects::do_unforward(a10,0) , objects::do_unforward(a11,0) , objects::do_unforward(a12,0) , objects::do_unforward(a13,0) , objects::do_unforward(a14,0)
            )
    {
    }
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 74 "/usr/local/include/boost/python/object/value_holder.hpp" 2 3

private:
    void* holds(type_info, bool null_ptr_only);

 private:
    Held m_held;
};



template <class Value>
void* value_holder<Value>::holds(type_info dst_t, bool )
{
    if (void* wrapped = holds_wrapped(dst_t, boost::addressof(m_held), boost::addressof(m_held)))
        return wrapped;

    type_info src_t = python::type_id<Value>();
    return src_t == dst_t ? boost::addressof(m_held)
        : find_static_type(boost::addressof(m_held), src_t, dst_t);
}

template <class Value, class Held>
void* value_holder_back_reference<Value,Held>::holds(
    type_info dst_t, bool )
{
    type_info src_t = python::type_id<Value>();
    Value* x = &m_held;

    if (dst_t == src_t)
        return x;
    else if (dst_t == python::type_id<Held>())
        return &m_held;
    else
        return find_static_type(x, src_t, dst_t);
}

}}}
# 15 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 16 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3






# 1 "/usr/local/include/boost/python/has_back_reference.hpp" 1 3
# 11 "/usr/local/include/boost/python/has_back_reference.hpp" 3
namespace boost { namespace python {



template <class T>
struct has_back_reference
  : mpl::false_
{
};


}}
# 23 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/for_each.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/for_each.hpp" 3
# 1 "/usr/local/include/boost/mpl/is_sequence.hpp" 1 3
# 40 "/usr/local/include/boost/mpl/is_sequence.hpp" 3
namespace boost { namespace mpl {
# 90 "/usr/local/include/boost/mpl/is_sequence.hpp" 3
template<
      typename T = na
    >
struct is_sequence
    : not_< is_same< typename begin<T>::type, void_ > >
{
   
};
# 108 "/usr/local/include/boost/mpl/is_sequence.hpp" 3
template<> struct is_sequence< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_sequence< T1 > { }; }; template< typename Tag > struct lambda< is_sequence< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_sequence< na > result_; typedef is_sequence< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_sequence< T1 > > : int_<1> { }; template<> struct template_arity< is_sequence< na > > : int_<-1> { }; }

}}
# 18 "/usr/local/include/boost/mpl/for_each.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/for_each.hpp" 2 3






# 1 "/usr/local/include/boost/mpl/aux_/unwrap.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/unwrap.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename F >

inline
F& unwrap(F& f, long)
{
    return f;
}

template< typename F >

inline
F&
unwrap(reference_wrapper<F>& f, int)
{
    return f;
}

template< typename F >

inline
F&
unwrap(reference_wrapper<F> const& f, int)
{
    return f;
}

}}}
# 27 "/usr/local/include/boost/mpl/for_each.hpp" 2 3


# 1 "/usr/local/include/boost/utility/value_init.hpp" 1 3
# 24 "/usr/local/include/boost/utility/value_init.hpp" 3
# 1 "/usr/local/include/boost/aligned_storage.hpp" 1 3
# 16 "/usr/local/include/boost/aligned_storage.hpp" 3
# 1 "/usr/local/include/boost/type_traits/aligned_storage.hpp" 1 3
# 25 "/usr/local/include/boost/type_traits/aligned_storage.hpp" 3
namespace boost {

namespace detail { namespace aligned_storage {

static const std::size_t alignment_of_max_align = ::boost::alignment_of<boost::detail::max_align>::value


     ;




template <
      std::size_t size_
    , std::size_t alignment_
>
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];

        typename ::boost::type_with_alignment<alignment_>::type align_;
    } data_;
    void* address() const { return const_cast<aligned_storage_imp*>(this); }
};
template <std::size_t size>
struct aligned_storage_imp<size, std::size_t(-1)>
{
   union data_t
   {
      char buf[size];
      ::boost::detail::max_align align_;
   } data_;
   void* address() const { return const_cast<aligned_storage_imp*>(this); }
};

template< std::size_t alignment_ >
struct aligned_storage_imp<0u,alignment_>
{

    void* address() const { return 0; }
};

}}

template <
      std::size_t size_
    , std::size_t alignment_ = std::size_t(-1)
>
class aligned_storage :

   private



   ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_>
{

public:

    typedef ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;

    static const std::size_t size = size_


         ;
    static const std::size_t alignment = ( alignment_ == std::size_t(-1) ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_ )






         ;

private:

    aligned_storage(const aligned_storage&);
    aligned_storage& operator=(const aligned_storage&);

public:

    aligned_storage()
    {
    }

    ~aligned_storage()
    {
    }

public:

    void* address()
    {
        return static_cast<type*>(this)->address();
    }

    const void* address() const
    {
        return static_cast<const type*>(this)->address();
    }
};





template <std::size_t size_, std::size_t alignment_>
struct is_pod< ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_> > : public true_type{};

}
# 17 "/usr/local/include/boost/aligned_storage.hpp" 2 3
# 25 "/usr/local/include/boost/utility/value_init.hpp" 2 3



# 1 "/usr/local/include/boost/type_traits/cv_traits.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/cv_traits.hpp" 3
# 1 "/usr/local/include/boost/type_traits/add_const.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/add_const.hpp" 3
namespace boost {
# 30 "/usr/local/include/boost/type_traits/add_const.hpp" 3
   template <class T> struct add_const
   {
      typedef T const type;
   };





   template <class T> struct add_const<T&>
   {
      typedef T& type;
   };



   template <class T> using add_const_t = typename add_const<T>::type;



}
# 16 "/usr/local/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/add_volatile.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/add_volatile.hpp" 3
namespace boost {
# 30 "/usr/local/include/boost/type_traits/add_volatile.hpp" 3
template <class T> struct add_volatile{ typedef T volatile type; };





template <class T> struct add_volatile<T&>{ typedef T& type; };



   template <class T> using add_volatile_t = typename add_volatile<T>::type;



}
# 17 "/usr/local/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/add_cv.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/add_cv.hpp" 3
namespace boost {
# 31 "/usr/local/include/boost/type_traits/add_cv.hpp" 3
template <class T> struct add_cv{ typedef T const volatile type; };





template <class T> struct add_cv<T&>{ typedef T& type; };



   template <class T> using add_cv_t = typename add_cv<T>::type;



}
# 18 "/usr/local/include/boost/type_traits/cv_traits.hpp" 2 3


# 1 "/usr/local/include/boost/type_traits/remove_const.hpp" 1 3
# 18 "/usr/local/include/boost/type_traits/remove_const.hpp" 3
namespace boost {


   template <class T> struct remove_const{ typedef T type; };
   template <class T> struct remove_const<T const>{ typedef T type; };


   template <class T, std::size_t N> struct remove_const<T const[N]>{ typedef T type[N]; };

   template <class T> struct remove_const<T const[]>{ typedef T type[]; };





   template <class T> using remove_const_t = typename remove_const<T>::type;



}
# 21 "/usr/local/include/boost/type_traits/cv_traits.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/remove_volatile.hpp" 1 3
# 18 "/usr/local/include/boost/type_traits/remove_volatile.hpp" 3
namespace boost {


   template <class T> struct remove_volatile{ typedef T type; };
   template <class T> struct remove_volatile<T volatile>{ typedef T type; };


   template <class T, std::size_t N> struct remove_volatile<T volatile[N]>{ typedef T type[N]; };

   template <class T> struct remove_volatile<T volatile[]>{ typedef T type[]; };





   template <class T> using remove_volatile_t = typename remove_volatile<T>::type;



}
# 22 "/usr/local/include/boost/type_traits/cv_traits.hpp" 2 3
# 29 "/usr/local/include/boost/utility/value_init.hpp" 2 3

# 1 "/usr/local/include/boost/swap.hpp" 1 3
# 15 "/usr/local/include/boost/swap.hpp" 3
# 1 "/usr/local/include/boost/core/swap.hpp" 1 3
# 24 "/usr/local/include/boost/core/swap.hpp" 3
# 1 "/usr/local/include/boost/core/enable_if.hpp" 1 3
# 24 "/usr/local/include/boost/core/enable_if.hpp" 3
namespace boost
{
  template<typename T, typename R=void>
  struct enable_if_has_type
  {
    typedef R type;
  };

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 25 "/usr/local/include/boost/core/swap.hpp" 2 3





namespace boost_swap_impl
{


  template<class T> struct is_const { enum _vt { value = 0 }; };
  template<class T> struct is_const<T const> { enum _vt { value = 1 }; };

  template<class T>
 
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>
 
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>
 
  typename enable_if_c< !boost_swap_impl::is_const<T1>::value && !boost_swap_impl::is_const<T2>::value >::type
  swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
# 16 "/usr/local/include/boost/swap.hpp" 2 3
# 31 "/usr/local/include/boost/utility/value_init.hpp" 2 3
# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 32 "/usr/local/include/boost/utility/value_init.hpp" 2 3
# 61 "/usr/local/include/boost/utility/value_init.hpp" 3
namespace boost {

template<class T>
class initialized
{
  private :
    struct wrapper
    {

      typename

      remove_const<T>::type data;

     
      wrapper()
      :
      data()
      {
      }

     
      wrapper(T const & arg)
      :
      data(arg)
      {
      }
    };

    mutable

      typename

      aligned_storage<sizeof(wrapper), alignment_of<wrapper>::value>::type x;

   
    wrapper * wrapper_address() const
    {
      return static_cast<wrapper *>( static_cast<void*>(&x));
    }

  public :

   
    initialized()
    {



      new (wrapper_address()) wrapper();
    }

   
    initialized(initialized const & arg)
    {
      new (wrapper_address()) wrapper( static_cast<wrapper const &>(*(arg.wrapper_address())));
    }

   
    explicit initialized(T const & arg)
    {
      new (wrapper_address()) wrapper(arg);
    }

   
    initialized & operator=(initialized const & arg)
    {

      static_assert(! is_const<T>::value, "! is_const<T>::value");
      *wrapper_address() = static_cast<wrapper const &>(*(arg.wrapper_address()));
      return *this;
    }

   
    ~initialized()
    {
      wrapper_address()->wrapper::~wrapper();
    }

   
    T const & data() const
    {
      return wrapper_address()->data;
    }

   
    T& data()
    {
      return wrapper_address()->data;
    }

   
    void swap(initialized & arg)
    {
      ::boost::swap( this->data(), arg.data() );
    }

   
    operator T const &() const
    {
      return wrapper_address()->data;
    }

   
    operator T&()
    {
      return wrapper_address()->data;
    }

} ;

template<class T>

T const& get ( initialized<T> const& x )
{
  return x.data() ;
}

template<class T>

T& get ( initialized<T>& x )
{
  return x.data() ;
}

template<class T>

void swap ( initialized<T> & lhs, initialized<T> & rhs )
{
  lhs.swap(rhs) ;
}

template<class T>
class value_initialized
{
  private :


    initialized<T> m_data;

  public :

   
    value_initialized()
    :
    m_data()
    { }

   
    T const & data() const
    {
      return m_data.data();
    }

   
    T& data()
    {
      return m_data.data();
    }

   
    void swap(value_initialized & arg)
    {
      m_data.swap(arg.m_data);
    }

   
    operator T const &() const
    {
      return m_data;
    }

   
    operator T&()
    {
      return m_data;
    }
} ;


template<class T>

T const& get ( value_initialized<T> const& x )
{
  return x.data() ;
}

template<class T>

T& get ( value_initialized<T>& x )
{
  return x.data() ;
}

template<class T>

void swap ( value_initialized<T> & lhs, value_initialized<T> & rhs )
{
  lhs.swap(rhs) ;
}


class initialized_value_t
{
  public :

    template <class T> operator T() const
    {
      return initialized<T>().data();
    }
};

initialized_value_t const initialized_value = {} ;


}
# 30 "/usr/local/include/boost/mpl/for_each.hpp" 2 3

namespace boost { namespace mpl {

namespace aux {

template< bool done = true >
struct for_each_impl
{
    template<
          typename Iterator
        , typename LastIterator
        , typename TransformFunc
        , typename F
        >
   
    static void execute(
          Iterator*
        , LastIterator*
        , TransformFunc*
        , F
        )
    {
    }
};

template<>
struct for_each_impl<false>
{
    template<
          typename Iterator
        , typename LastIterator
        , typename TransformFunc
        , typename F
        >
   
    static void execute(
          Iterator*
        , LastIterator*
        , TransformFunc*
        , F f
        )
    {
        typedef typename deref<Iterator>::type item;
        typedef typename apply1<TransformFunc,item>::type arg;



        value_initialized<arg> x;
        aux::unwrap(f, 0)(boost::get(x));

        typedef typename mpl::next<Iterator>::type iter;
        for_each_impl<boost::is_same<iter,LastIterator>::value>
            ::execute( static_cast<iter*>(0), static_cast<LastIterator*>(0), static_cast<TransformFunc*>(0), f);
    }
};

}



template<
      typename Sequence
    , typename TransformOp
    , typename F
    >

inline
void for_each(F f, Sequence* = 0, TransformOp* = 0)
{
    enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) ( is_sequence<Sequence> ))0, 1 ) ) ) };

    typedef typename begin<Sequence>::type first;
    typedef typename end<Sequence>::type last;

    aux::for_each_impl< boost::is_same<first,last>::value >
        ::execute(static_cast<first*>(0), static_cast<last*>(0), static_cast<TransformOp*>(0), f);
}

template<
      typename Sequence
    , typename F
    >

inline
void for_each(F f, Sequence* = 0)
{


  boost::mpl::for_each<Sequence, identity<> >(f);
}

}}
# 31 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/placeholders.hpp" 1 3
# 32 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/single_view.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/single_view.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/single_element_iter.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/single_element_iter.hpp" 3
namespace boost { namespace mpl {



namespace aux {

template< typename T, int is_last_ >
struct sel_iter;

template< typename T >
struct sel_iter<T,0>
{
    typedef random_access_iterator_tag category;
    typedef sel_iter<T,1> next;
    typedef T type;
};

template< typename T >
struct sel_iter<T,1>
{
    typedef random_access_iterator_tag category;
    typedef sel_iter<T,0> prior;
};

}

template< typename T, int is_last_, typename Distance >
struct advance< aux::sel_iter<T,is_last_>,Distance>
{
    typedef aux::sel_iter<
          T
        , ( is_last_ + Distance::value )
        > type;
};

template<
      typename T
    , int l1
    , int l2
    >
struct distance< aux::sel_iter<T,l1>, aux::sel_iter<T,l2> >
    : int_<( l2 - l1 )>
{
};
# 116 "/usr/local/include/boost/mpl/aux_/single_element_iter.hpp" 3
}}
# 18 "/usr/local/include/boost/mpl/single_view.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename T = na
    >
struct single_view
    : iterator_range<
          aux::sel_iter<T,0>
        , aux::sel_iter<T,1>
        >
{
};

template<> struct single_view< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : single_view< T1 > { }; }; template< typename Tag > struct lambda< single_view< na > , Tag , int_<-1> > { typedef false_ is_le; typedef single_view< na > result_; typedef single_view< na > type; }; namespace aux { template< typename T1 > struct template_arity< single_view< T1 > > : int_<1> { }; template<> struct template_arity< single_view< na > > : int_<-1> { }; }

}}
# 33 "/usr/local/include/boost/python/object/class_metadata.hpp" 2 3






namespace boost { namespace python { namespace objects {


void copy_class_object(type_info const& src, type_info const& dst);




template <class Derived>
struct register_base_of
{
    template <class Base>
    inline void operator()(Base*) const
    {
        enum { mpl_assertion_in_line_53 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::python::detail::is_same<Base,Derived>))0, 1 ) ) ) };


        register_dynamic_id<Base>();


        register_conversion<Derived,Base>(false);


        this->register_downcast((Base*)0, boost::python::detail::is_polymorphic<Base>());
    }

 private:
    static inline void register_downcast(void*, boost::python::detail::false_) {}

    template <class Base>
    static inline void register_downcast(Base*, boost::python::detail::true_)
    {
        register_conversion<Base, Derived>(true);
    }

};






template <class T, class Bases>
inline void register_shared_ptr_from_python_and_casts(T*, Bases)
{

  python::detail::force_instantiate(converter::shared_ptr_from_python<T, boost::shared_ptr>());

  python::detail::force_instantiate(converter::shared_ptr_from_python<T, std::shared_ptr>());






  register_dynamic_id<T>();
  mpl::for_each(register_base_of<T>(), (Bases*)0, (boost::python::detail::add_pointer<mpl::_>*)0);
}




template <class T, class Prev>
struct select_held_type
  : mpl::if_<
        mpl::or_<
            python::detail::specifies_bases<T>
          , boost::python::detail::is_same<T,noncopyable>
        >
      , Prev
      , T
    >
{
};

template <
    class T
  , class X1
  , class X2
  , class X3
>
struct class_metadata
{







    typedef typename select_held_type<
        X1
      , typename select_held_type<
            X2
          , typename select_held_type<
                X3
              , python::detail::not_specified
            >::type
        >::type
    >::type held_type_arg;


    typedef typename python::detail::select_bases<
        X1
      , typename python::detail::select_bases<
            X2
          , typename python::detail::select_bases<
                X3
              , python::bases<>
            >::type
        >::type
    >::type bases;

    typedef mpl::or_<
        boost::python::detail::is_same<X1,noncopyable>
      , boost::python::detail::is_same<X2,noncopyable>
      , boost::python::detail::is_same<X3,noncopyable>
    > is_noncopyable;






    typedef typename mpl::if_<
        boost::python::detail::is_same<held_type_arg,python::detail::not_specified>, T, held_type_arg
    >::type held_type;


    typedef mpl::bool_<boost::python::detail::is_convertible<held_type*,T*>::value> use_value_holder;



    typedef typename mpl::eval_if<
        use_value_holder
      , mpl::identity<held_type>
      , pointee<held_type>
    >::type wrapped;


    typedef mpl::bool_<
        mpl::or_<
            has_back_reference<T>
          , boost::python::detail::is_same<held_type_arg,T>
          , is_base_and_derived<T,wrapped>
        >::value
    > use_back_reference;


    typedef typename mpl::eval_if<
        use_back_reference
      , mpl::if_<
            use_value_holder
          , value_holder_back_reference<T, wrapped>
          , pointer_holder_back_reference<held_type,T>
        >
      , mpl::if_<
            use_value_holder
          , value_holder<T>
          , pointer_holder<held_type,wrapped>
        >
    >::type holder;

    inline static void register_()
    {
        class_metadata::register_aux((T*)0);
    }

 private:
    template <class T2>
    inline static void register_aux(python::wrapper<T2>*)
    {
        typedef typename mpl::not_<boost::python::detail::is_same<T2,wrapped> >::type use_callback;
        class_metadata::register_aux2((T2*)0, use_callback());
    }

    inline static void register_aux(void*)
    {
        typedef typename is_base_and_derived<T,wrapped>::type use_callback;
        class_metadata::register_aux2((T*)0, use_callback());
    }

    template <class T2, class Callback>
    inline static void register_aux2(T2*, Callback)
    {
 objects::register_shared_ptr_from_python_and_casts((T2*)0, bases());
        class_metadata::maybe_register_callback_class((T2*)0, Callback());

        class_metadata::maybe_register_class_to_python((T2*)0, is_noncopyable());

        class_metadata::maybe_register_pointer_to_python(
            (T2*)0, (use_value_holder*)0, (use_back_reference*)0);
    }





    inline static void maybe_register_pointer_to_python(...) {}


    inline static void maybe_register_pointer_to_python(void*,void*,mpl::true_*)
    {
        objects::copy_class_object(python::type_id<T>(), python::type_id<back_reference<T const &> >());
        objects::copy_class_object(python::type_id<T>(), python::type_id<back_reference<T &> >());
    }


    template <class T2>
    inline static void maybe_register_pointer_to_python(T2*, mpl::false_*, mpl::false_*)
    {
        python::detail::force_instantiate(
            objects::class_value_wrapper<
                held_type
              , make_ptr_instance<T2, pointer_holder<held_type, T2> >
            >()
        );


        objects::copy_class_object(python::type_id<T2>(), python::type_id<held_type>());

    }



    inline static void maybe_register_class_to_python(void*, mpl::true_) {}


    template <class T2>
    inline static void maybe_register_class_to_python(T2*, mpl::false_)
    {
        python::detail::force_instantiate(class_cref_wrapper<T2, make_instance<T2, holder> >());


        objects::copy_class_object(python::type_id<T2>(), python::type_id<held_type>());

    }




    inline static void maybe_register_callback_class(void*, mpl::false_) {}

    template <class T2>
    inline static void maybe_register_callback_class(T2*, mpl::true_)
    {
 objects::register_shared_ptr_from_python_and_casts(
            (wrapped*)0, mpl::single_view<T2>());

        objects::copy_class_object(python::type_id<T2>(), python::type_id<wrapped>());
    }
};

}}}
# 24 "/usr/local/include/boost/python/class.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/pickle_support.hpp" 1 3
# 10 "/usr/local/include/boost/python/object/pickle_support.hpp" 3
namespace boost { namespace python {

namespace api
{
  class object;
}
using api::object;
class tuple;

 object const& make_instance_reduce_function();

struct pickle_suite;

namespace error_messages {

  template <class T>
  struct missing_pickle_suite_function_or_incorrect_signature {};

  inline void must_be_derived_from_pickle_suite(pickle_suite const&) {}
}

namespace detail { struct pickle_suite_registration; }

struct pickle_suite
{
  private:
    struct inaccessible {};
    friend struct detail::pickle_suite_registration;
  public:
    static inaccessible* getinitargs() { return 0; }
    static inaccessible* getstate() { return 0; }
    static inaccessible* setstate() { return 0; }
    static bool getstate_manages_dict() { return false; }
};

namespace detail {

  struct pickle_suite_registration
  {
    typedef pickle_suite::inaccessible inaccessible;

    template <class Class_, class Tgetinitargs>
    static
    void
    register_(
      Class_& cl,
      tuple (*getinitargs_fn)(Tgetinitargs),
      inaccessible* (* )(),
      inaccessible* (* )(),
      bool)
    {
      cl.enable_pickling_(false);
      cl.def("__getinitargs__", getinitargs_fn);
    }

    template <class Class_,
              class Rgetstate, class Tgetstate,
              class Tsetstate, class Ttuple>
    static
    void
    register_(
      Class_& cl,
      inaccessible* (* )(),
      Rgetstate (*getstate_fn)(Tgetstate),
      void (*setstate_fn)(Tsetstate, Ttuple),
      bool getstate_manages_dict)
    {
      cl.enable_pickling_(getstate_manages_dict);
      cl.def("__getstate__", getstate_fn);
      cl.def("__setstate__", setstate_fn);
    }

    template <class Class_,
              class Tgetinitargs,
              class Rgetstate, class Tgetstate,
              class Tsetstate, class Ttuple>
    static
    void
    register_(
      Class_& cl,
      tuple (*getinitargs_fn)(Tgetinitargs),
      Rgetstate (*getstate_fn)(Tgetstate),
      void (*setstate_fn)(Tsetstate, Ttuple),
      bool getstate_manages_dict)
    {
      cl.enable_pickling_(getstate_manages_dict);
      cl.def("__getinitargs__", getinitargs_fn);
      cl.def("__getstate__", getstate_fn);
      cl.def("__setstate__", setstate_fn);
    }

    template <class Class_>
    static
    void
    register_(
      Class_&,
      ...)
    {
      typedef typename
        error_messages::missing_pickle_suite_function_or_incorrect_signature<
          Class_>::error_type error_type __attribute__((__unused__));
    }
  };

  template <typename PickleSuiteType>
  struct pickle_suite_finalize
  : PickleSuiteType,
    pickle_suite_registration
  {};

}

}}
# 25 "/usr/local/include/boost/python/class.hpp" 2 3


# 1 "/usr/local/include/boost/python/detail/overloads_fwd.hpp" 1 3







namespace boost { namespace python { namespace detail {


struct overloads_base;

template <class OverloadsT, class NameSpaceT, class SigT>
inline void define_with_defaults(char const* name, OverloadsT const&, NameSpaceT&, SigT const&);

}}}
# 28 "/usr/local/include/boost/python/class.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/operator_id.hpp" 1 3







namespace boost { namespace python { namespace detail {

enum operator_id
{
    op_add,
    op_sub,
    op_mul,
    op_div,
    op_mod,
    op_divmod,
    op_pow,
    op_lshift,
    op_rshift,
    op_and,
    op_xor,
    op_or,
    op_neg,
    op_pos,
    op_abs,
    op_invert,
    op_int,
    op_long,
    op_float,
    op_str,
    op_cmp,
    op_gt,
    op_ge,
    op_lt,
    op_le,
    op_eq,
    op_ne,
    op_iadd,
    op_isub,
    op_imul,
    op_idiv,
    op_imod,
    op_ilshift,
    op_irshift,
    op_iand,
    op_ixor,
    op_ior,
    op_complex,



    op_nonzero,

    op_repr



};

}}}
# 29 "/usr/local/include/boost/python/class.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/def_helper.hpp" 1 3
# 15 "/usr/local/include/boost/python/detail/def_helper.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 16 "/usr/local/include/boost/python/detail/def_helper.hpp" 2 3
# 1 "/usr/local/include/boost/tuple/tuple.hpp" 1 3
# 28 "/usr/local/include/boost/tuple/tuple.hpp" 3
# 1 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 1 3
# 39 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 3
# 1 "/usr/local/include/boost/type_traits/function_traits.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/function_traits.hpp" 3
# 1 "/usr/local/include/boost/type_traits/add_pointer.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/add_pointer.hpp" 3
namespace boost {
# 50 "/usr/local/include/boost/type_traits/add_pointer.hpp" 3
template <typename T>
struct add_pointer
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};





   template <class T> using add_pointer_t = typename add_pointer<T>::type;



}
# 15 "/usr/local/include/boost/type_traits/function_traits.hpp" 2 3

namespace boost {

namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const unsigned arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
  public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};

}
# 40 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 2 3
# 1 "/usr/local/include/boost/utility/swap.hpp" 1 3
# 41 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 2 3




#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"


namespace boost {
namespace tuples {


struct null_type {};


namespace detail {
  inline const null_type cnull() { return null_type(); }





template <bool If, class Then, class Else> struct IF { typedef Then RET; };

template <class Then, class Else> struct IF<false, Then, Else> {
  typedef Else RET;
};

}


template <class HT, class TT> struct cons;



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type>
class tuple;


template<class T> struct length;



namespace detail {



template<class T>
class generate_error;

template<int N>
struct drop_front {
    template<class Tuple>
    struct apply {
        typedef typename drop_front<N-1>::template
            apply<Tuple> next;
        typedef typename next::type::tail_type type;
        static const type& call(const Tuple& tup) {
            return next::call(tup).tail;
        }
    };
};

template<>
struct drop_front<0> {
    template<class Tuple>
    struct apply {
        typedef Tuple type;
        static const type& call(const Tuple& tup) {
            return tup;
        }
    };
};

}
# 129 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 3
template<int N, class T>
struct element
{
  typedef typename detail::drop_front<N>::template
      apply<T>::type::head_type type;
};

template<int N, class T>
struct element<N, const T>
{
private:
  typedef typename detail::drop_front<N>::template
      apply<T>::type::head_type unqualified_type;
public:



  typedef typename boost::add_const<unqualified_type>::type type;

};
# 189 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 3
template <class T> struct access_traits {
  typedef const T& const_type;
  typedef T& non_const_type;

  typedef const typename boost::remove_cv<T>::type& parameter_type;






};

template <class T> struct access_traits<T&> {

  typedef T& const_type;
  typedef T& non_const_type;

  typedef T& parameter_type;
};



template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::non_const_type
get(cons<HT, TT>& c) {
  typedef typename detail::drop_front<N>::template
      apply<cons<HT, TT> > impl;
  typedef typename impl::type cons_element;
  return const_cast<cons_element&>(impl::call(c)).head;
}




template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::const_type
get(const cons<HT, TT>& c) {
  typedef typename detail::drop_front<N>::template
      apply<cons<HT, TT> > impl;
  return impl::call(c).head;
}


namespace detail {







template <class T> class non_storeable_type {
  non_storeable_type();
};

template <class T> struct wrap_non_storeable_type {
  typedef typename IF<
    ::boost::is_function<T>::value, non_storeable_type<T>, T
  >::RET type;
};
template <> struct wrap_non_storeable_type<void> {
  typedef non_storeable_type<void> type;
};

}

template <class HT, class TT>
struct cons {

  typedef HT head_type;
  typedef TT tail_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;

  stored_head_type head;
  tail_type tail;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  typename access_traits<tail_type>::non_const_type
  get_tail() { return tail; }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  typename access_traits<tail_type>::const_type
  get_tail() const { return tail; }

  cons() : head(), tail() {}







  cons(typename access_traits<stored_head_type>::parameter_type h,
       const tail_type& t)
    : head (h), tail(t) {}

  template <class T1, class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (t1),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}

  template <class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( const null_type& , T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}


  template <class HT2, class TT2>
  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u ) {
    head=u.head; tail=u.tail; return *this;
  }



  cons& operator=(const cons& u) {
    head = u.head; tail = u.tail; return *this;
  }

  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u ) {
    static_assert(length<cons>::value == 2, "length<cons>::value == 2");
    head = u.first; tail.head = u.second; return *this;
  }


  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }
};

template <class HT>
struct cons<HT, null_type> {

  typedef HT head_type;
  typedef null_type tail_type;
  typedef cons<HT, null_type> self_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  null_type get_tail() { return null_type(); }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  const null_type get_tail() const { return null_type(); }


  cons() : head() {}

  cons(typename access_traits<stored_head_type>::parameter_type h,
       const null_type& = null_type())
    : head (h) {}

  template<class T1>
  cons(T1& t1, const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head (t1) {}

  cons(const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head () {}

  template <class HT2>
  cons( const cons<HT2, null_type>& u ) : head(u.head) {}

  template <class HT2>
  cons& operator=(const cons<HT2, null_type>& u )
  { head = u.head; return *this; }



  cons& operator=(const cons& u) { head = u.head; return *this; }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
            >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }

};



template<class T>
struct length {
  static const int value = 1 + length<typename T::tail_type>::value;
};

template<>
struct length<tuple<> > {
  static const int value = 0;
};

template<>
struct length<tuple<> const> {
  static const int value = 0;
};

template<>
struct length<null_type> {
  static const int value = 0;
};

template<>
struct length<null_type const> {
  static const int value = 0;
};

namespace detail {


template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
struct map_tuple_to_cons
{
  typedef cons<T0,
               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
                                          T6, T7, T8, T9, null_type>::type
              > type;
};


template <>
struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
{
  typedef null_type type;
};

}



template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>

class tuple :
  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
{
public:
  typedef typename
    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
  typedef typename inherited::head_type head_type;
  typedef typename inherited::tail_type tail_type;



  tuple() {}

  explicit tuple(typename access_traits<T0>::parameter_type t0)
    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1)
    : inherited(t0, t1, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2)
    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3)
    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4)
    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5)
    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6)
    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8,
        typename access_traits<T9>::parameter_type t9)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}


  template<class U1, class U2>
  tuple(const cons<U1, U2>& p) : inherited(p) {}

  template <class U1, class U2>
  tuple& operator=(const cons<U1, U2>& k) {
    inherited::operator=(k);
    return *this;
  }

  template <class U1, class U2>
  tuple& operator=(const std::pair<U1, U2>& k) {
    static_assert(length<tuple>::value == 2, "length<tuple>::value == 2");
    this->head = k.first;
    this->tail.head = k.second;
    return *this;
  }

};


template <>
class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> :
  public null_type
{
public:
  typedef null_type inherited;
};



namespace detail {

struct swallow_assign;
typedef void (detail::swallow_assign::*ignore_t)();
struct swallow_assign {
  swallow_assign(ignore_t(*)(ignore_t)) {}
  template<typename T>
  swallow_assign const& operator=(const T&) const {
    return *this;
  }
};


}


inline detail::ignore_t ignore(detail::ignore_t) { return 0; }
# 640 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 3
template<class T>
struct make_tuple_traits {
  typedef T type;







};
# 664 "/usr/local/include/boost/tuple/detail/tuple_basic.hpp" 3
template<class T>
struct make_tuple_traits<T&> {
  typedef typename
     detail::generate_error<T&>::
       do_not_use_with_reference_type error;
};





template<class T, int n> struct make_tuple_traits <T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n> struct make_tuple_traits<volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T>
struct make_tuple_traits<reference_wrapper<T> >{
  typedef T& type;
};

template<class T>
struct make_tuple_traits<const reference_wrapper<T> >{
  typedef T& type;
};

template<>
struct make_tuple_traits<detail::ignore_t(detail::ignore_t)> {
  typedef detail::swallow_assign type;
};



namespace detail {



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type
>
struct make_tuple_mapper {
  typedef
    tuple<typename make_tuple_traits<T0>::type,
          typename make_tuple_traits<T1>::type,
          typename make_tuple_traits<T2>::type,
          typename make_tuple_traits<T3>::type,
          typename make_tuple_traits<T4>::type,
          typename make_tuple_traits<T5>::type,
          typename make_tuple_traits<T6>::type,
          typename make_tuple_traits<T7>::type,
          typename make_tuple_traits<T8>::type,
          typename make_tuple_traits<T9>::type> type;
};

}


inline tuple<> make_tuple() {
  return tuple<>();
}

template<class T0>
inline typename detail::make_tuple_mapper<T0>::type
make_tuple(const T0& t0) {
  typedef typename detail::make_tuple_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
inline typename detail::make_tuple_mapper<T0, T1>::type
make_tuple(const T0& t0, const T1& t1) {
  typedef typename detail::make_tuple_mapper<T0, T1>::type t;
  return t(t0, t1);
}

template<class T0, class T1, class T2>
inline typename detail::make_tuple_mapper<T0, T1, T2>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}

template<class T0, class T1, class T2, class T3>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}

template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8, const T9& t9) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}

namespace detail {

template<class T>
struct tie_traits {
  typedef T& type;
};

template<>
struct tie_traits<ignore_t(ignore_t)> {
  typedef swallow_assign type;
};

template<>
struct tie_traits<void> {
  typedef null_type type;
};

template <
  class T0 = void, class T1 = void, class T2 = void,
  class T3 = void, class T4 = void, class T5 = void,
  class T6 = void, class T7 = void, class T8 = void,
  class T9 = void
>
struct tie_mapper {
  typedef
    tuple<typename tie_traits<T0>::type,
          typename tie_traits<T1>::type,
          typename tie_traits<T2>::type,
          typename tie_traits<T3>::type,
          typename tie_traits<T4>::type,
          typename tie_traits<T5>::type,
          typename tie_traits<T6>::type,
          typename tie_traits<T7>::type,
          typename tie_traits<T8>::type,
          typename tie_traits<T9>::type> type;
};

}


template<class T0>
inline typename detail::tie_mapper<T0>::type
tie(T0& t0) {
  typedef typename detail::tie_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
inline typename detail::tie_mapper<T0, T1>::type
tie(T0& t0, T1& t1) {
  typedef typename detail::tie_mapper<T0, T1>::type t;
  return t(t0, t1);
}

template<class T0, class T1, class T2>
inline typename detail::tie_mapper<T0, T1, T2>::type
tie(T0& t0, T1& t1, T2& t2) {
  typedef typename detail::tie_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}

template<class T0, class T1, class T2, class T3>
inline typename detail::tie_mapper<T0, T1, T2, T3>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}

template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::tie_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7,
                  T8& t8) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::tie_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7,
                  T8& t8, T9& t9) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}

template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs);
inline void swap(null_type&, null_type&) {}
template<class HH>
inline void swap(cons<HH, null_type>& lhs, cons<HH, null_type>& rhs) {
  ::boost::swap(lhs.head, rhs.head);
}
template<class HH, class TT>
inline void swap(cons<HH, TT>& lhs, cons<HH, TT>& rhs) {
  ::boost::swap(lhs.head, rhs.head);
  ::boost::tuples::swap(lhs.tail, rhs.tail);
}
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
inline void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs) {
  typedef tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> tuple_type;
  typedef typename tuple_type::inherited base;
  ::boost::tuples::swap(static_cast<base&>(lhs), static_cast<base&>(rhs));
}

}
}



#pragma GCC diagnostic pop
# 29 "/usr/local/include/boost/tuple/tuple.hpp" 2 3


namespace boost {

using tuples::tuple;
using tuples::make_tuple;
using tuples::tie;

using tuples::get;
# 64 "/usr/local/include/boost/tuple/tuple.hpp" 3
}
# 17 "/usr/local/include/boost/python/detail/def_helper.hpp" 2 3



namespace boost { namespace python {

struct default_call_policies;

namespace detail
{




  template <class Tuple, class Predicate>
  struct tuple_extract;



  template <bool matched>
  struct tuple_extract_impl
  {
      template <class Tuple, class Predicate>
      struct apply
      {
          typedef typename Tuple::head_type result_type;

          static typename Tuple::head_type extract(Tuple const& x)
          {
              return x.get_head();
          }
      };
  };



  template <>
  struct tuple_extract_impl<false>
  {
      template <class Tuple, class Predicate>
      struct apply
      {

          typedef tuple_extract<typename Tuple::tail_type, Predicate> next;
          typedef typename next::result_type result_type;

          static result_type extract(Tuple const& x)
          {
              return next::extract(x.get_tail());
          }
      };
  };



  template <class Tuple, class Predicate>
  struct tuple_extract_base_select
  {
      typedef typename Tuple::head_type head_type;
      typedef typename mpl::apply1<Predicate,
              typename add_lvalue_reference<head_type>::type>::type match_t;
      static const bool match = match_t::value;
      typedef typename tuple_extract_impl<match>::template apply<Tuple,Predicate> type;
  };

  template <class Tuple, class Predicate>
  struct tuple_extract
      : tuple_extract_base_select<
         Tuple
         , typename mpl::lambda<Predicate>::type
      >::type
  {
  };







  template <class Tuple>
  struct doc_extract
      : tuple_extract<
        Tuple
        , mpl::not_<
           mpl::or_<
               indirect_traits::is_reference_to_class<mpl::_1>
             , indirect_traits::is_reference_to_member_function_pointer<mpl::_1 >
           >
        >
     >
  {
  };

  template <class Tuple>
  struct keyword_extract
      : tuple_extract<Tuple, is_reference_to_keywords<mpl::_1 > >
  {
  };

  template <class Tuple>
  struct policy_extract
      : tuple_extract<
          Tuple
          , mpl::and_<
             mpl::not_<is_same<not_specified const&,mpl::_1> >
              , indirect_traits::is_reference_to_class<mpl::_1 >
              , mpl::not_<is_reference_to_keywords<mpl::_1 > >
          >
        >
  {
  };

  template <class Tuple>
  struct default_implementation_extract
      : tuple_extract<
          Tuple
          , indirect_traits::is_reference_to_member_function_pointer<mpl::_1 >
          >
  {
  };
# 145 "/usr/local/include/boost/python/detail/def_helper.hpp" 3
  template <class T1, class T2, class T3, class T4>
  struct def_helper
  {



      typedef boost::tuples::tuple<
          T1 const&
          , T2 const&
          , T3 const&
          , T4 const&
          , default_call_policies
          , detail::keywords<0>
          , char const*
          , void(not_specified::*)()

          > all_t;



      def_helper(T1 const& a1) : m_all(a1,m_nil,m_nil,m_nil) {}
      def_helper(T1 const& a1, T2 const& a2) : m_all(a1,a2,m_nil,m_nil) {}
      def_helper(T1 const& a1, T2 const& a2, T3 const& a3) : m_all(a1,a2,a3,m_nil) {}
      def_helper(T1 const& a1, T2 const& a2, T3 const& a3, T4 const& a4) : m_all(a1,a2,a3,a4) {}

   private:
      typedef typename default_implementation_extract<all_t>::result_type default_implementation_t;

   public:



      static const bool has_default_implementation = ( !is_same<default_implementation_t, void(not_specified::*)()>::value)

                                                                                   ;

   public:

      char const* doc() const
      {
          return doc_extract<all_t>::extract(m_all);
      }

      typename keyword_extract<all_t>::result_type keywords() const
      {
          return keyword_extract<all_t>::extract(m_all);
      }

      typename policy_extract<all_t>::result_type policies() const
      {
          return policy_extract<all_t>::extract(m_all);
      }

      default_implementation_t default_implementation() const
      {
          return default_implementation_extract<all_t>::extract(m_all);
      }

   private:
      all_t m_all;
      not_specified m_nil;
  };
}

}}
# 30 "/usr/local/include/boost/python/class.hpp" 2 3


# 1 "/usr/local/include/boost/python/detail/unwrap_type_id.hpp" 1 3
# 11 "/usr/local/include/boost/python/detail/unwrap_type_id.hpp" 3
namespace boost { namespace python {

template <class T> class wrapper;

namespace detail {

template <class T>
inline type_info unwrap_type_id(T*, ...)
{
    return type_id<T>();
}

template <class U, class T>
inline type_info unwrap_type_id(U*, wrapper<T>*)
{
    return type_id<T>();
}

}}}
# 33 "/usr/local/include/boost/python/class.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/unwrap_wrapper.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/is_wrapper.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/is_wrapper.hpp" 3
namespace boost { namespace python {

template <class T> class wrapper;

namespace detail
{
  typedef char (&is_not_wrapper)[2];
  is_not_wrapper is_wrapper_helper(...);
  template <class T>
  char is_wrapper_helper(wrapper<T> const volatile*);


  template <class T>
  struct is_wrapper
    : mpl::bool_<(sizeof(detail::is_wrapper_helper((T*)0)) == 1)>
  {};

}}}
# 9 "/usr/local/include/boost/python/detail/unwrap_wrapper.hpp" 2 3



namespace boost { namespace python { namespace detail {

template <class T>
struct unwrap_wrapper_helper
{
    typedef typename T::_wrapper_wrapped_type_ type;
};

template <class T>
struct unwrap_wrapper_
  : mpl::eval_if<is_wrapper<T>,unwrap_wrapper_helper<T>,mpl::identity<T> >
{};

template <class T>
typename unwrap_wrapper_<T>::type*
unwrap_wrapper(T*)
{
    return 0;
}

}}}
# 34 "/usr/local/include/boost/python/class.hpp" 2 3
# 55 "/usr/local/include/boost/python/class.hpp" 3
namespace boost { namespace python {

template <class DerivedVisitor> class def_visitor;

enum no_init_t { no_init };

namespace detail
{



  struct write_type_id
  {
      write_type_id(type_info**p) : p(p) {}


      template <class T>
      void operator()(T*) const
      {
          *(*p)++ = type_id<T>();
      }

      type_info** p;
  };

  template <class T>
  struct is_data_member_pointer
      : mpl::and_<
            detail::is_member_pointer<T>
          , mpl::not_<detail::is_member_function_pointer<T> >
        >
  {};
# 102 "/usr/local/include/boost/python/class.hpp" 3
  namespace error
  {
# 113 "/usr/local/include/boost/python/class.hpp" 3
    template <class C> struct assertion_failed { };
    template <class C> struct assertion_ok { typedef C failed; };

    template <class C>
    struct assertion
        : mpl::if_<C, assertion_ok<C>, assertion_failed<C> >::type
    {};






    template <class Default>
    void not_a_derived_class_member(Default) {}

    template <class T, class Fn>
    struct virtual_function_default
    {
        template <class Default>
        static void
        must_be_derived_class_member(Default const&)
        {



            typedef typename assertion<detail::is_polymorphic<T> >::failed test1 __attribute__((__unused__));

            typedef typename assertion<detail::is_member_function_pointer<Fn> >::failed test2 __attribute__((__unused__));
            not_a_derived_class_member<Default>(Fn());
        }
    };
  }
}



template <
    class W
    , class X1
    , class X2
    , class X3
    >
class class_ : public objects::class_base
{
 public:
    typedef objects::class_base base;
    typedef class_<W,X1,X2,X3> self;
    typedef typename objects::class_metadata<W,X1,X2,X3> metadata;
    typedef W wrapped_type;

 private:



    struct id_vector
    {
        typedef typename metadata::bases bases;

        id_vector()
        {

            ids[0] = detail::unwrap_type_id((W*)0, (W*)0);


            type_info* p = ids + 1;
            mpl::for_each(detail::write_type_id(&p), (bases*)0, (add_pointer<mpl::_>*)0);
        }

        static const std::size_t size = mpl::size<bases>::value + 1
                                                            ;
        type_info ids[size];
    };
    friend struct id_vector;

 public:


    class_(char const* name, char const* doc = 0);


    class_(char const* name, no_init_t);


    class_(char const* name, char const* doc, no_init_t);


    template <class DerivedT>
    inline class_(char const* name, init_base<DerivedT> const& i)
        : base(name, id_vector::size, id_vector().ids)
    {
        this->initialize(i);
    }


    template <class DerivedT>
    inline class_(char const* name, char const* doc, init_base<DerivedT> const& i)
        : base(name, id_vector::size, id_vector().ids, doc)
    {
        this->initialize(i);
    }

 public:


    template <class Derived>
    self& def(def_visitor<Derived> const& visitor)
    {
        visitor.visit(*this);
        return *this;
    }




    template <class F>
    self& def(char const* name, F f)
    {
        this->def_impl(
            detail::unwrap_wrapper((W*)0)
          , name, f, detail::def_helper<char const*>(0), &f);
        return *this;
    }

    template <class A1, class A2>
    self& def(char const* name, A1 a1, A2 const& a2)
    {
        this->def_maybe_overloads(name, a1, a2, &a2);
        return *this;
    }

    template <class Fn, class A1, class A2>
    self& def(char const* name, Fn fn, A1 const& a1, A2 const& a2)
    {




        this->def_impl(
            detail::unwrap_wrapper((W*)0)
          , name, fn
          , detail::def_helper<A1,A2>(a1,a2)
          , &fn);

        return *this;
    }

    template <class Fn, class A1, class A2, class A3>
    self& def(char const* name, Fn fn, A1 const& a1, A2 const& a2, A3 const& a3)
    {
        this->def_impl(
            detail::unwrap_wrapper((W*)0)
          , name, fn
          , detail::def_helper<A1,A2,A3>(a1,a2,a3)
          , &fn);

        return *this;
    }




    template <class D>
    self& def_readonly(char const* name, D const& d, char const* doc=0)
    {
        return this->def_readonly_impl(name, d, doc );
    }

    template <class D>
    self& def_readwrite(char const* name, D const& d, char const* doc=0)
    {
        return this->def_readwrite_impl(name, d, doc );
    }

    template <class D>
    self& def_readonly(char const* name, D& d, char const* doc=0)
    {
        return this->def_readonly_impl(name, d, doc );
    }

    template <class D>
    self& def_readwrite(char const* name, D& d, char const* doc=0)
    {
        return this->def_readwrite_impl(name, d, doc );
    }


    template <class Get>
    self& add_property(char const* name, Get fget, char const* docstr = 0)
    {
        base::add_property(name, this->make_getter(fget), docstr);
        return *this;
    }

    template <class Get, class Set>
    self& add_property(char const* name, Get fget, Set fset, char const* docstr = 0)
    {
        base::add_property(
            name, this->make_getter(fget), this->make_setter(fset), docstr);
        return *this;
    }

    template <class Get>
    self& add_static_property(char const* name, Get fget)
    {
        base::add_static_property(name, object(fget));
        return *this;
    }

    template <class Get, class Set>
    self& add_static_property(char const* name, Get fget, Set fset)
    {
        base::add_static_property(name, object(fget), object(fset));
        return *this;
    }

    template <class U>
    self& setattr(char const* name, U const& x)
    {
        this->base::setattr(name, object(x));
        return *this;
    }


    template <typename PickleSuiteType>
    self& def_pickle(PickleSuiteType const& x)
    {
      error_messages::must_be_derived_from_pickle_suite(x);
      detail::pickle_suite_finalize<PickleSuiteType>::register_(
        *this,
        &PickleSuiteType::getinitargs,
        &PickleSuiteType::getstate,
        &PickleSuiteType::setstate,
        PickleSuiteType::getstate_manages_dict());
      return *this;
    }

    self& enable_pickling()
    {
        this->base::enable_pickling_(false);
        return *this;
    }

    self& staticmethod(char const* name)
    {
        this->make_method_static(name);
        return *this;
    }
 private:
# 370 "/usr/local/include/boost/python/class.hpp" 3
    template <class F>
    object make_getter(F f)
    {
        typedef typename api::is_object_operators<F>::type is_obj_or_proxy;

        return this->make_fn_impl(
            detail::unwrap_wrapper((W*)0)
          , f, is_obj_or_proxy(), (char*)0, detail::is_data_member_pointer<F>()
        );
    }

    template <class F>
    object make_setter(F f)
    {
        typedef typename api::is_object_operators<F>::type is_obj_or_proxy;

        return this->make_fn_impl(
            detail::unwrap_wrapper((W*)0)
          , f, is_obj_or_proxy(), (int*)0, detail::is_data_member_pointer<F>()
        );
    }

    template <class T, class F>
    object make_fn_impl(T*, F const& f, mpl::false_, void*, mpl::false_)
    {
        return python::make_function(f, default_call_policies(), detail::get_signature(f, (T*)0));
    }

    template <class T, class D, class B>
    object make_fn_impl(T*, D B::*pm_, mpl::false_, char*, mpl::true_)
    {
        D T::*pm = pm_;
        return python::make_getter(pm);
    }

    template <class T, class D, class B>
    object make_fn_impl(T*, D B::*pm_, mpl::false_, int*, mpl::true_)
    {
        D T::*pm = pm_;
        return python::make_setter(pm);
    }

    template <class T, class F>
    object make_fn_impl(T*, F const& x, mpl::true_, void*, mpl::false_)
    {
        return x;
    }


    template <class D, class B>
    self& def_readonly_impl(
        char const* name, D B::*pm_, char const* doc )
    {
        return this->add_property(name, pm_, doc);
    }

    template <class D, class B>
    self& def_readwrite_impl(
        char const* name, D B::*pm_, char const* doc )
    {
        return this->add_property(name, pm_, pm_, doc);
    }

    template <class D>
    self& def_readonly_impl(
        char const* name, D& d, char const* )
    {
        return this->add_static_property(name, python::make_getter(d));
    }

    template <class D>
    self& def_readwrite_impl(
        char const* name, D& d, char const* )
    {
        return this->add_static_property(name, python::make_getter(d), python::make_setter(d));
    }

    template <class DefVisitor>
    inline void initialize(DefVisitor const& i)
    {
        metadata::register_();

        typedef typename metadata::holder holder;
        this->set_instance_size( objects::additional_instance_size<holder>::value );

        this->def(i);
    }

    inline void initialize(no_init_t)
    {
        metadata::register_();
        this->def_no_init();
    }






    template <class T, class Helper, class LeafVisitor, class Visitor>
    inline void def_impl(
        T*
      , char const* name
      , LeafVisitor
      , Helper const& helper
      , def_visitor<Visitor> const* v
    )
    {
        v->visit(*this, name, helper);
    }

    template <class T, class Fn, class Helper>
    inline void def_impl(
        T*
      , char const* name
      , Fn fn
      , Helper const& helper
      , ...
    )
    {
        objects::add_to_namespace(
            *this
          , name
          , make_function(
                fn
              , helper.policies()
              , helper.keywords()
              , detail::get_signature(fn, (T*)0)
            )
          , helper.doc()
        );

        this->def_default(name, fn, helper, mpl::bool_<Helper::has_default_implementation>());
    }
# 512 "/usr/local/include/boost/python/class.hpp" 3
    template <class Fn, class Helper>
    inline void def_default(
        char const* name
        , Fn
        , Helper const& helper
        , mpl::bool_<true>)
    {
        detail::error::virtual_function_default<W,Fn>::must_be_derived_class_member(
            helper.default_implementation());

        objects::add_to_namespace(
            *this, name,
            make_function(
                helper.default_implementation(), helper.policies(), helper.keywords())
            );
    }

    template <class Fn, class Helper>
    inline void def_default(char const*, Fn, Helper const&, mpl::bool_<false>)
    { }
# 541 "/usr/local/include/boost/python/class.hpp" 3
    template <class OverloadsT, class SigT>
    void def_maybe_overloads(
        char const* name
        , SigT sig
        , OverloadsT const& overloads
        , detail::overloads_base const*)

    {


        detail::define_with_defaults(
            name, overloads, *this, detail::get_signature(sig));
    }

    template <class Fn, class A1>
    void def_maybe_overloads(
        char const* name
        , Fn fn
        , A1 const& a1
        , ...)
    {
        this->def_impl(
            detail::unwrap_wrapper((W*)0)
          , name
          , fn
          , detail::def_helper<A1>(a1)
          , &fn
        );

    }

};






template <class W, class X1, class X2, class X3>
inline class_<W,X1,X2,X3>::class_(char const* name, char const* doc)
    : base(name, id_vector::size, id_vector().ids, doc)
{
    this->initialize(init<>());

}

template <class W, class X1, class X2, class X3>
inline class_<W,X1,X2,X3>::class_(char const* name, no_init_t)
    : base(name, id_vector::size, id_vector().ids)
{
    this->initialize(no_init);
}

template <class W, class X1, class X2, class X3>
inline class_<W,X1,X2,X3>::class_(char const* name, char const* doc, no_init_t)
    : base(name, id_vector::size, id_vector().ids, doc)
{
    this->initialize(no_init);
}

}}
# 19 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/copy_const_reference.hpp" 1 3
# 13 "/usr/local/include/boost/python/copy_const_reference.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <class R>
  struct copy_const_reference_expects_a_const_reference_return_type

  {}

  ;
}

template <class T> struct to_python_value;

struct copy_const_reference
{
    template <class T>
    struct apply
    {
        typedef typename mpl::if_c<
            indirect_traits::is_reference_to_const<T>::value
          , to_python_value<T>
          , detail::copy_const_reference_expects_a_const_reference_return_type<T>
        >::type type;
    };
};


}}
# 20 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/copy_non_const_reference.hpp" 1 3
# 13 "/usr/local/include/boost/python/copy_non_const_reference.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <class R>
  struct copy_non_const_reference_expects_a_non_const_reference_return_type

  {}

  ;
}

template <class T> struct to_python_value;

struct copy_non_const_reference
{
    template <class T>
    struct apply
    {
        typedef typename mpl::if_c<
            indirect_traits::is_reference_to_non_const<T>::value
            , to_python_value<T>
            , detail::copy_non_const_reference_expects_a_non_const_reference_return_type<T>
        >::type type;
    };
};


}}
# 21 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/def.hpp" 1 3
# 14 "/usr/local/include/boost/python/def.hpp" 3
# 1 "/usr/local/include/boost/python/scope.hpp" 1 3
# 12 "/usr/local/include/boost/python/scope.hpp" 3
namespace boost { namespace python {

namespace detail
{


  extern PyObject* current_scope;
}

class scope
  : public object
{
 public:
    inline scope(scope const&);
    inline scope(object const&);
    inline scope();
    inline ~scope();

 private:
    PyObject* m_previous_scope;

 private:
    void operator=(scope const&);
};

inline scope::scope(object const& new_scope)
    : object(new_scope)
    , m_previous_scope(detail::current_scope)
{
    detail::current_scope = python::incref(new_scope.ptr());
}

inline scope::scope()
    : object(detail::borrowed_reference(
                 detail::current_scope ? detail::current_scope : (&_Py_NoneStruct)
                 ))
    , m_previous_scope(python::xincref(detail::current_scope))
{
}

inline scope::~scope()
{
    python::xdecref(detail::current_scope);
    detail::current_scope = m_previous_scope;
}

namespace converter
{
  template <>
  struct object_manager_traits<scope>
      : object_manager_traits<object>
  {
  };
}


inline scope::scope(scope const& new_scope)
    : object(new_scope)
    , m_previous_scope(detail::current_scope)
{
    detail::current_scope = python::incref(new_scope.ptr());
}

}}
# 15 "/usr/local/include/boost/python/def.hpp" 2 3
# 1 "/usr/local/include/boost/python/signature.hpp" 1 3
# 16 "/usr/local/include/boost/python/def.hpp" 2 3
# 1 "/usr/local/include/boost/python/detail/scope.hpp" 1 3
# 10 "/usr/local/include/boost/python/detail/scope.hpp" 3
namespace boost { namespace python { namespace detail {

void scope_setattr_doc(char const* name, object const& obj, char const* doc);

}}}
# 17 "/usr/local/include/boost/python/def.hpp" 2 3

namespace boost { namespace python {

namespace detail
{
  namespace error
  {

    template <bool> struct multiple_functions_passed_to_def;
    template <> struct multiple_functions_passed_to_def<false> { typedef char type; };
  }





  template <class F, class Helper>
  void def_from_helper(
      char const* name, F const& fn, Helper const& helper)
  {

      typedef typename error::multiple_functions_passed_to_def<
          Helper::has_default_implementation
          >::type assertion __attribute__((__unused__));

      detail::scope_setattr_doc(
          name, boost::python::make_function(
              fn
              , helper.policies()
              , helper.keywords())
          , helper.doc()
          );
  }







  template <class Fn, class A1>
  void
  def_maybe_overloads(
      char const* name
      , Fn fn
      , A1 const& a1
      , ...)
  {
      detail::def_from_helper(name, fn, def_helper<A1>(a1));
  }

  template <class StubsT, class SigT>
  void def_maybe_overloads(
      char const* name
      , SigT sig
      , StubsT const& stubs
      , detail::overloads_base const*)
  {
      scope current;

      detail::define_with_defaults(
          name, stubs, current, detail::get_signature(sig));
  }

  template <class T>
  object make_function1(T fn, ...) { return make_function(fn); }

  inline
  object make_function1(object const& x, object const*) { return x; }
}

template <class Fn>
void def(char const* name, Fn fn)
{
    detail::scope_setattr_doc(name, detail::make_function1(fn, &fn), 0);
}

template <class Arg1T, class Arg2T>
void def(char const* name, Arg1T arg1, Arg2T const& arg2)
{
    detail::def_maybe_overloads(name, arg1, arg2, &arg2);
}

template <class F, class A1, class A2>
void def(char const* name, F f, A1 const& a1, A2 const& a2)
{
    detail::def_from_helper(name, f, detail::def_helper<A1,A2>(a1,a2));
}

template <class F, class A1, class A2, class A3>
void def(char const* name, F f, A1 const& a1, A2 const& a2, A3 const& a3)
{
    detail::def_from_helper(name, f, detail::def_helper<A1,A2,A3>(a1,a2,a3));
}

}}
# 23 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/dict.hpp" 1 3
# 11 "/usr/local/include/boost/python/dict.hpp" 3
# 1 "/usr/local/include/boost/python/list.hpp" 1 3
# 11 "/usr/local/include/boost/python/list.hpp" 3
# 1 "/usr/local/include/boost/python/converter/pytype_object_mgr_traits.hpp" 1 3
# 14 "/usr/local/include/boost/python/converter/pytype_object_mgr_traits.hpp" 3
namespace boost { namespace python { namespace converter {



template <class T> struct object_manager_traits;




template <PyTypeObject* pytype, class T>
struct pytype_object_manager_traits
    : pyobject_type<T, pytype>
{
    static const bool is_specialized = true;
    static inline python::detail::new_reference adopt(PyObject*);
};




template <PyTypeObject* pytype, class T>
inline python::detail::new_reference pytype_object_manager_traits<pytype,T>::adopt(PyObject* x)
{
    return python::detail::new_reference(python::pytype_check(pytype, x));
}

}}}
# 12 "/usr/local/include/boost/python/list.hpp" 2 3


namespace boost { namespace python {

namespace detail
{
  struct list_base : object
  {
      void append(object_cref);

      ssize_t count(object_cref value) const;

      void extend(object_cref sequence);

      long index(object_cref value) const;

      void insert(ssize_t index, object_cref);
      void insert(object const& index, object_cref);

      object pop();
      object pop(ssize_t index);
      object pop(object const& index);

      void remove(object_cref value);

      void reverse();

      void sort();




      void sort(object_cref cmpfunc);


   protected:
      list_base();
      explicit list_base(object_cref sequence);

      inline explicit list_base(::boost::python::detail::borrowed_reference p) : object(p) {} inline explicit list_base(::boost::python::detail::new_reference p) : object(p) {} inline explicit list_base(::boost::python::detail::new_non_null_reference p) : object(p) {}
   private:
      static detail::new_non_null_reference call(object const&);
  };
}

class list : public detail::list_base
{
    typedef detail::list_base base;
 public:
    list() {}

    template <class T>
    explicit list(T const& sequence)
        : base(object(sequence))
    {
    }

    template <class T>
    void append(T const& x)
    {
        base::append(object(x));
    }

    template <class T>
    ssize_t count(T const& value) const
    {
        return base::count(object(value));
    }

    template <class T>
    void extend(T const& x)
    {
        base::extend(object(x));
    }

    template <class T>
    long index(T const& x) const
    {
        return base::index(object(x));
    }

    template <class T>
    void insert(ssize_t index, T const& x)
    {
        base::insert(index, object(x));
    }

    template <class T>
    void insert(object const& index, T const& x)
    {
        base::insert(index, object(x));
    }

    object pop() { return base::pop(); }
    object pop(ssize_t index) { return base::pop(index); }

    template <class T>
    object pop(T const& index)
    {
        return base::pop(object(index));
    }

    template <class T>
    void remove(T const& value)
    {
        base::remove(object(value));
    }


    void sort() { base::sort(); }

    template <class T>
    void sort(T const& value)
    {
        base::sort(object(value));
    }


 public:
    inline explicit list(::boost::python::detail::borrowed_reference p) : base(p) {} inline explicit list(::boost::python::detail::new_reference p) : base(p) {} inline explicit list(::boost::python::detail::new_non_null_reference p) : base(p) {}
};




namespace converter
{
  template <>
  struct object_manager_traits<list>
      : pytype_object_manager_traits<&PyList_Type,list>
  {
  };
}

}}
# 12 "/usr/local/include/boost/python/dict.hpp" 2 3
# 1 "/usr/local/include/boost/python/tuple.hpp" 1 3
# 15 "/usr/local/include/boost/python/tuple.hpp" 3
namespace boost { namespace python {

namespace detail
{
  struct tuple_base : object
  {
   protected:
      tuple_base();
      tuple_base(object_cref sequence);

      inline explicit tuple_base(::boost::python::detail::borrowed_reference p) : object(p) {} inline explicit tuple_base(::boost::python::detail::new_reference p) : object(p) {} inline explicit tuple_base(::boost::python::detail::new_non_null_reference p) : object(p) {}

   private:
      static detail::new_reference call(object const&);
  };
}

class tuple : public detail::tuple_base
{
    typedef detail::tuple_base base;
 public:
    tuple() {}

    template <class T>
    explicit tuple(T const& sequence)
        : base(object(sequence))
    {
    }

 public:
    inline explicit tuple(::boost::python::detail::borrowed_reference p) : base(p) {} inline explicit tuple(::boost::python::detail::new_reference p) : base(p) {} inline explicit tuple(::boost::python::detail::new_non_null_reference p) : base(p) {}
};





namespace converter
{
  template <>
  struct object_manager_traits<tuple>
      : pytype_object_manager_traits<&PyTuple_Type,tuple>
  {
  };
}


inline tuple make_tuple() { return tuple(); }


# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 52 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0>
    tuple
    make_tuple( A0 const& a0)
    {
        tuple result((detail::new_reference)::PyTuple_New(1));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr()));
        return result;
    }
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1)
    {
        tuple result((detail::new_reference)::PyTuple_New(2));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr()));
        return result;
    }
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2)
    {
        tuple result((detail::new_reference)::PyTuple_New(3));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr()));
        return result;
    }
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3)
    {
        tuple result((detail::new_reference)::PyTuple_New(4));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr()));
        return result;
    }
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4)
    {
        tuple result((detail::new_reference)::PyTuple_New(5));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr()));
        return result;
    }
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5)
    {
        tuple result((detail::new_reference)::PyTuple_New(6));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr()));
        return result;
    }
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6)
    {
        tuple result((detail::new_reference)::PyTuple_New(7));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr()));
        return result;
    }
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7)
    {
        tuple result((detail::new_reference)::PyTuple_New(8));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr()));
        return result;
    }
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8)
    {
        tuple result((detail::new_reference)::PyTuple_New(9));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr()));
        return result;
    }
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9)
    {
        tuple result((detail::new_reference)::PyTuple_New(10));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[9] = python::incref(python::object(a9).ptr()));
        return result;
    }
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10)
    {
        tuple result((detail::new_reference)::PyTuple_New(11));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[9] = python::incref(python::object(a9).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[10] = python::incref(python::object(a10).ptr()));
        return result;
    }
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11)
    {
        tuple result((detail::new_reference)::PyTuple_New(12));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[9] = python::incref(python::object(a9).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[10] = python::incref(python::object(a10).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[11] = python::incref(python::object(a11).ptr()));
        return result;
    }
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12)
    {
        tuple result((detail::new_reference)::PyTuple_New(13));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[9] = python::incref(python::object(a9).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[10] = python::incref(python::object(a10).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[11] = python::incref(python::object(a11).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[12] = python::incref(python::object(a12).ptr()));
        return result;
    }
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13)
    {
        tuple result((detail::new_reference)::PyTuple_New(14));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[9] = python::incref(python::object(a9).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[10] = python::incref(python::object(a10).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[11] = python::incref(python::object(a11).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[12] = python::incref(python::object(a12).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[13] = python::incref(python::object(a13).ptr()));
        return result;
    }
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/make_tuple.hpp" 1 3
# 20 "/usr/local/include/boost/python/detail/make_tuple.hpp" 3
    template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
    tuple
    make_tuple( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 , A10 const& a10 , A11 const& a11 , A12 const& a12 , A13 const& a13 , A14 const& a14)
    {
        tuple result((detail::new_reference)::PyTuple_New(15));
        (((PyTupleObject *)(result.ptr()))->ob_item[0] = python::incref(python::object(a0).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[1] = python::incref(python::object(a1).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[2] = python::incref(python::object(a2).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[3] = python::incref(python::object(a3).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[4] = python::incref(python::object(a4).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[5] = python::incref(python::object(a5).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[6] = python::incref(python::object(a6).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[7] = python::incref(python::object(a7).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[8] = python::incref(python::object(a8).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[9] = python::incref(python::object(a9).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[10] = python::incref(python::object(a10).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[11] = python::incref(python::object(a11).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[12] = python::incref(python::object(a12).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[13] = python::incref(python::object(a13).ptr())); (((PyTupleObject *)(result.ptr()))->ob_item[14] = python::incref(python::object(a14).ptr()));
        return result;
    }
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 66 "/usr/local/include/boost/python/tuple.hpp" 2 3

}}
# 13 "/usr/local/include/boost/python/dict.hpp" 2 3


namespace boost { namespace python {

class dict;

namespace detail
{
  struct dict_base : object
  {

      void clear();


      dict copy();


      object get(object_cref k) const;

      object get(object_cref k, object_cref d) const;


      bool has_key(object_cref k) const;


      list items() const;


      object iteritems() const;


      object iterkeys() const;


      object itervalues() const;


      list keys() const;



      tuple popitem();


      object setdefault(object_cref k);

      object setdefault(object_cref k, object_cref d);


      void update(object_cref E);


      list values() const;

   protected:




      dict_base();
      explicit dict_base(object_cref data);

      inline explicit dict_base(::boost::python::detail::borrowed_reference p) : object(p) {} inline explicit dict_base(::boost::python::detail::new_reference p) : object(p) {} inline explicit dict_base(::boost::python::detail::new_non_null_reference p) : object(p) {}
   private:
      static detail::new_reference call(object const&);
  };
}

class dict : public detail::dict_base
{
    typedef detail::dict_base base;
 public:




    dict() {}

    template <class T>
    explicit dict(T const& data)
        : base(object(data))
    {
    }

    template<class T>
    object get(T const& k) const
    {
        return base::get(object(k));
    }

    template<class T1, class T2>
    object get(T1 const& k, T2 const& d) const
    {
        return base::get(object(k),object(d));
    }

    template<class T>
    bool has_key(T const& k) const
    {
        return base::has_key(object(k));
    }

    template<class T>
    object setdefault(T const& k)
    {
        return base::setdefault(object(k));
    }

    template<class T1, class T2>
    object setdefault(T1 const& k, T2 const& d)
    {
        return base::setdefault(object(k),object(d));
    }

    template<class T>
    void update(T const& E)
    {
        base::update(object(E));
    }

 public:
    inline explicit dict(::boost::python::detail::borrowed_reference p) : base(p) {} inline explicit dict(::boost::python::detail::new_reference p) : base(p) {} inline explicit dict(::boost::python::detail::new_non_null_reference p) : base(p) {}
};




namespace converter
{
  template <>
  struct object_manager_traits<dict>
      : pytype_object_manager_traits<&PyDict_Type,dict>
  {
  };
}

}}
# 25 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/docstring_options.hpp" 1 3







# 1 "/usr/local/include/boost/python/object/function.hpp" 1 3
# 11 "/usr/local/include/boost/python/object/function.hpp" 3
# 1 "/usr/local/include/boost/function/function2.hpp" 1 3
# 11 "/usr/local/include/boost/function/function2.hpp" 3
# 1 "/usr/local/include/boost/function/detail/maybe_include.hpp" 1 3
# 12 "/usr/local/include/boost/function/function2.hpp" 2 3
# 12 "/usr/local/include/boost/python/object/function.hpp" 2 3



namespace boost { namespace python { namespace objects {


struct function : PyObject
{
    function(
        py_function const&
        , python::detail::keyword const* names_and_defaults
        , unsigned num_keywords);

    ~function();

    PyObject* call(PyObject*, PyObject*) const;




    static void add_to_namespace(
        object const& name_space, char const* name, object const& attribute);

    static void add_to_namespace(
        object const& name_space, char const* name, object const& attribute, char const* doc);

    object const& doc() const;
    void doc(object const& x);

    object const& name() const;

    object const& get_namespace() const { return m_namespace; }

 private:
    object signature(bool show_return_type=false) const;
    object signatures(bool show_return_type=false) const;
    void argument_error(PyObject* args, PyObject* keywords) const;
    void add_overload(handle<function> const&);

 private:
    py_function m_fn;
    handle<function> m_overloads;
    object m_name;
    object m_namespace;
    object m_doc;
    object m_arg_names;
    unsigned m_nkeyword_values;
    friend class function_doc_signature_generator;
};




inline object const& function::doc() const
{
    return this->m_doc;
}

inline void function::doc(object const& x)
{
    this->m_doc = x;
}

inline object const& function::name() const
{
    return this->m_name;
}

}}}
# 9 "/usr/local/include/boost/python/docstring_options.hpp" 2 3

namespace boost { namespace python {



class docstring_options : boost::noncopyable
{
  public:
      docstring_options(bool show_all=true)
      {
          previous_show_user_defined_ = show_user_defined_;
          previous_show_py_signatures_ = show_py_signatures_;
          previous_show_cpp_signatures_ = show_cpp_signatures_;
          show_user_defined_ = show_all;
          show_cpp_signatures_ = show_all;
          show_py_signatures_ = show_all;
      }

      docstring_options(bool show_user_defined, bool show_signatures)
      {
          previous_show_user_defined_ = show_user_defined_;
          previous_show_cpp_signatures_ = show_cpp_signatures_;
          previous_show_py_signatures_ = show_py_signatures_;
          show_user_defined_ = show_user_defined;
          show_cpp_signatures_ = show_signatures;
          show_py_signatures_ = show_signatures;
      }

      docstring_options(bool show_user_defined, bool show_py_signatures, bool show_cpp_signatures)
      {
          previous_show_user_defined_ = show_user_defined_;
          previous_show_cpp_signatures_ = show_cpp_signatures_;
          previous_show_py_signatures_ = show_py_signatures_;
          show_user_defined_ = show_user_defined;
          show_cpp_signatures_ = show_cpp_signatures;
          show_py_signatures_ = show_py_signatures;
      }

      ~docstring_options()
      {
          show_user_defined_ = previous_show_user_defined_;
          show_cpp_signatures_ = previous_show_cpp_signatures_;
          show_py_signatures_ = previous_show_py_signatures_;
      }

      void
      disable_user_defined() { show_user_defined_ = false; }

      void
      enable_user_defined() { show_user_defined_ = true; }

      void
      disable_py_signatures()
      {
        show_py_signatures_ = false;
      }

      void
      enable_py_signatures()
      {
        show_py_signatures_ = true;
      }

      void
      disable_cpp_signatures()
      {
        show_cpp_signatures_ = false;
      }

      void
      enable_cpp_signatures()
      {
        show_cpp_signatures_ = true;
      }

      void
      disable_signatures()
      {
        show_cpp_signatures_ = false;
        show_py_signatures_ = false;
      }

      void
      enable_signatures()
      {
        show_cpp_signatures_ = true;
        show_py_signatures_ = true;
      }

      void
      disable_all()
      {
        show_user_defined_ = false;
        show_cpp_signatures_ = false;
        show_py_signatures_ = false;
      }

      void
      enable_all()
      {
        show_user_defined_ = true;
        show_cpp_signatures_ = true;
        show_py_signatures_ = true;
      }

      friend struct objects::function;

  private:
      static volatile bool show_user_defined_;
      static volatile bool show_cpp_signatures_;
      static volatile bool show_py_signatures_;
      bool previous_show_user_defined_;
      bool previous_show_cpp_signatures_;
      bool previous_show_py_signatures_;
};

}}
# 26 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/enum.hpp" 1 3
# 10 "/usr/local/include/boost/python/enum.hpp" 3
# 1 "/usr/local/include/boost/python/object/enum_base.hpp" 1 3
# 14 "/usr/local/include/boost/python/object/enum_base.hpp" 3
namespace boost { namespace python { namespace objects {

struct enum_base : python::api::object
{
 protected:
    enum_base(
        char const* name
        , converter::to_python_function_t
        , converter::convertible_function
        , converter::constructor_function
        , type_info
        , const char *doc = 0
        );

    void add_value(char const* name, long value);
    void export_values();

    static PyObject* to_python(PyTypeObject* type, long x);
};

}}}
# 11 "/usr/local/include/boost/python/enum.hpp" 2 3



namespace boost { namespace python {

template <class T>
struct enum_ : public objects::enum_base
{
    typedef objects::enum_base base;


    enum_(char const* name, char const* doc = 0);


    inline enum_<T>& value(char const* name, T);



    inline enum_<T>& export_values();
 private:
    static PyObject* to_python(void const* x);
    static void* convertible_from_python(PyObject* obj);
    static void construct(PyObject* obj, converter::rvalue_from_python_stage1_data* data);
};

template <class T>
inline enum_<T>::enum_(char const* name, char const* doc )
    : base(
        name
        , &enum_<T>::to_python
        , &enum_<T>::convertible_from_python
        , &enum_<T>::construct
        , type_id<T>()
        , doc
        )
{
}



template <class T>
PyObject* enum_<T>::to_python(void const* x)
{
    return base::to_python(
        converter::registered<T>::converters.m_class_object
        , static_cast<long>(*(T const*)x));
}
# 66 "/usr/local/include/boost/python/enum.hpp" 3
template <class T>
void* enum_<T>::convertible_from_python(PyObject* obj)
{
    return PyObject_IsInstance(
        obj
        , upcast<PyObject>(
            converter::registered<T>::converters.m_class_object))

        ? obj : 0;
}



template <class T>
void enum_<T>::construct(PyObject* obj, converter::rvalue_from_python_stage1_data* data)
{



    T x = static_cast<T>((((PyIntObject *)(obj))->ob_ival));

    void* const storage = ((converter::rvalue_from_python_storage<T>*)data)->storage.bytes;
    new (storage) T(x);
    data->convertible = storage;
}

template <class T>
inline enum_<T>& enum_<T>::value(char const* name, T x)
{
    this->add_value(name, static_cast<long>(x));
    return *this;
}

template <class T>
inline enum_<T>& enum_<T>::export_values()
{
    this->base::export_values();
    return *this;
}

}}
# 27 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/exception_translator.hpp" 1 3
# 10 "/usr/local/include/boost/python/exception_translator.hpp" 3
# 1 "/usr/local/include/boost/bind.hpp" 1 3
# 22 "/usr/local/include/boost/bind.hpp" 3
# 1 "/usr/local/include/boost/bind/bind.hpp" 1 3
# 28 "/usr/local/include/boost/bind/bind.hpp" 3
# 1 "/usr/local/include/boost/is_placeholder.hpp" 1 3
# 21 "/usr/local/include/boost/is_placeholder.hpp" 3
namespace boost
{

template< class T > struct is_placeholder
{
    enum _vt { value = 0 };
};

}
# 29 "/usr/local/include/boost/bind/bind.hpp" 2 3
# 1 "/usr/local/include/boost/bind/arg.hpp" 1 3
# 25 "/usr/local/include/boost/bind/arg.hpp" 3
namespace boost
{

template<bool Eq> struct _arg_eq
{
};

template<> struct _arg_eq<true>
{
    typedef void type;
};

template< int I > struct arg
{
    constexpr arg()
    {
    }

    template< class T > constexpr arg( T const & , typename _arg_eq< I == is_placeholder<T>::value >::type * = 0 )
    {
    }
};

template< int I > constexpr bool operator==( arg<I> const &, arg<I> const & )
{
    return true;
}



template< int I > struct is_placeholder< arg<I> >
{
    enum _vt { value = I };
};

template< int I > struct is_placeholder< arg<I> (*) () >
{
    enum _vt { value = I };
};



}
# 30 "/usr/local/include/boost/bind/bind.hpp" 2 3

# 1 "/usr/local/include/boost/visit_each.hpp" 1 3
# 13 "/usr/local/include/boost/visit_each.hpp" 3
namespace boost {
  template<typename Visitor, typename T>
  inline void visit_each(Visitor& visitor, const T& t, long)
  {
    visitor(t);
  }

  template<typename Visitor, typename T>
  inline void visit_each(Visitor& visitor, const T& t)
  {
    visit_each(visitor, t, 0);
  }
}
# 32 "/usr/local/include/boost/bind/bind.hpp" 2 3

# 1 "/usr/local/include/boost/core/is_same.hpp" 1 3
# 20 "/usr/local/include/boost/core/is_same.hpp" 3
namespace boost
{

namespace core
{

template< class T1, class T2 > struct is_same
{
    static const bool value = false;
};

template< class T > struct is_same< T, T >
{
    static const bool value = true;
};

}

}
# 34 "/usr/local/include/boost/bind/bind.hpp" 2 3
# 47 "/usr/local/include/boost/bind/bind.hpp" 3
# 1 "/usr/local/include/boost/bind/storage.hpp" 1 3
# 32 "/usr/local/include/boost/bind/storage.hpp" 3
namespace boost
{

namespace _bi
{



template<class A1> struct storage1
{
    explicit storage1( A1 a1 ): a1_( a1 ) {}

    template<class V> void accept(V & v) const
    {
        visit_each(v, a1_, 0);
    }

    A1 a1_;
};



template<int I> struct storage1< boost::arg<I> >
{
    explicit storage1( boost::arg<I> ) {}

    template<class V> void accept(V &) const { }

    static boost::arg<I> a1_() { return boost::arg<I>(); }
};

template<int I> struct storage1< boost::arg<I> (*) () >
{
    explicit storage1( boost::arg<I> (*) () ) {}

    template<class V> void accept(V &) const { }

    static boost::arg<I> a1_() { return boost::arg<I>(); }
};





template<class A1, class A2> struct storage2: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, A2 a2 ): storage1<A1>( a1 ), a2_( a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a2_, 0);
    }

    A2 a2_;
};



template<class A1, int I> struct storage2< A1, boost::arg<I> >: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, boost::arg<I> ): storage1<A1>( a1 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a2_() { return boost::arg<I>(); }
};

template<class A1, int I> struct storage2< A1, boost::arg<I> (*) () >: public storage1<A1>
{
    typedef storage1<A1> inherited;

    storage2( A1 a1, boost::arg<I> (*) () ): storage1<A1>( a1 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a2_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3> struct storage3: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, A3 a3 ): storage2<A1, A2>( a1, a2 ), a3_( a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a3_, 0);
    }

    A3 a3_;
};



template<class A1, class A2, int I> struct storage3< A1, A2, boost::arg<I> >: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, boost::arg<I> ): storage2<A1, A2>( a1, a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a3_() { return boost::arg<I>(); }
};

template<class A1, class A2, int I> struct storage3< A1, A2, boost::arg<I> (*) () >: public storage2< A1, A2 >
{
    typedef storage2<A1, A2> inherited;

    storage3( A1 a1, A2 a2, boost::arg<I> (*) () ): storage2<A1, A2>( a1, a2 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a3_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4> struct storage4: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, A4 a4 ): storage3<A1, A2, A3>( a1, a2, a3 ), a4_( a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a4_, 0);
    }

    A4 a4_;
};



template<class A1, class A2, class A3, int I> struct storage4< A1, A2, A3, boost::arg<I> >: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, boost::arg<I> ): storage3<A1, A2, A3>( a1, a2, a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a4_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, int I> struct storage4< A1, A2, A3, boost::arg<I> (*) () >: public storage3< A1, A2, A3 >
{
    typedef storage3<A1, A2, A3> inherited;

    storage4( A1 a1, A2 a2, A3 a3, boost::arg<I> (*) () ): storage3<A1, A2, A3>( a1, a2, a3 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a4_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5> struct storage5: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ), a5_( a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a5_, 0);
    }

    A5 a5_;
};



template<class A1, class A2, class A3, class A4, int I> struct storage5< A1, A2, A3, A4, boost::arg<I> >: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I> ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a5_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, int I> struct storage5< A1, A2, A3, A4, boost::arg<I> (*) () >: public storage4< A1, A2, A3, A4 >
{
    typedef storage4<A1, A2, A3, A4> inherited;

    storage5( A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I> (*) () ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a5_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6> struct storage6: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ), a6_( a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a6_, 0);
    }

    A6 a6_;
};



template<class A1, class A2, class A3, class A4, class A5, int I> struct storage6< A1, A2, A3, A4, A5, boost::arg<I> >: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I> ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a6_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, int I> struct storage6< A1, A2, A3, A4, A5, boost::arg<I> (*) () >: public storage5< A1, A2, A3, A4, A5 >
{
    typedef storage5<A1, A2, A3, A4, A5> inherited;

    storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I> (*) () ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a6_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct storage7: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ), a7_( a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a7_, 0);
    }

    A7 a7_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, int I> struct storage7< A1, A2, A3, A4, A5, A6, boost::arg<I> >: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I> ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a7_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, int I> struct storage7< A1, A2, A3, A4, A5, A6, boost::arg<I> (*) () >: public storage6< A1, A2, A3, A4, A5, A6 >
{
    typedef storage6<A1, A2, A3, A4, A5, A6> inherited;

    storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I> (*) () ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a7_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> struct storage8: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8 ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ), a8_( a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a8_, 0);
    }

    A8 a8_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I> struct storage8< A1, A2, A3, A4, A5, A6, A7, boost::arg<I> >: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I> ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a8_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I> struct storage8< A1, A2, A3, A4, A5, A6, A7, boost::arg<I> (*) () >: public storage7< A1, A2, A3, A4, A5, A6, A7 >
{
    typedef storage7<A1, A2, A3, A4, A5, A6, A7> inherited;

    storage8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I> (*) () ): storage7<A1, A2, A3, A4, A5, A6, A7>( a1, a2, a3, a4, a5, a6, a7 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a8_() { return boost::arg<I>(); }
};





template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> struct storage9: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9 ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ), a9_( a9 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
        visit_each(v, a9_, 0);
    }

    A9 a9_;
};



template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I> struct storage9< A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> >: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I> ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a9_() { return boost::arg<I>(); }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I> struct storage9< A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> (*) () >: public storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
    typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8> inherited;

    storage9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I> (*) () ): storage8<A1, A2, A3, A4, A5, A6, A7, A8>( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    template<class V> void accept(V & v) const
    {
        inherited::accept(v);
    }

    static boost::arg<I> a9_() { return boost::arg<I>(); }
};



}

}
# 48 "/usr/local/include/boost/bind/bind.hpp" 2 3






namespace boost
{

template<class T> class weak_ptr;

namespace _bi
{



template<class R, class F> struct result_traits
{
    typedef R type;
};



struct unspecified {};

template<class F> struct result_traits<unspecified, F>
{
    typedef typename F::result_type type;
};

template<class F> struct result_traits< unspecified, reference_wrapper<F> >
{
    typedef typename F::result_type type;
};





template<class T> bool ref_compare( T const & a, T const & b, long )
{
    return a == b;
}

template<int I> bool ref_compare( arg<I> const &, arg<I> const &, int )
{
    return true;
}

template<int I> bool ref_compare( arg<I> (*) (), arg<I> (*) (), int )
{
    return true;
}

template<class T> bool ref_compare( reference_wrapper<T> const & a, reference_wrapper<T> const & b, int )
{
    return a.get_pointer() == b.get_pointer();
}



template<class R, class F, class L> class bind_t;

template<class R, class F, class L> bool ref_compare( bind_t<R, F, L> const & a, bind_t<R, F, L> const & b, int )
{
    return a.compare( b );
}



template<class T> class value
{
public:

    value(T const & t): t_(t) {}

    T & get() { return t_; }
    T const & get() const { return t_; }

    bool operator==(value const & rhs) const
    {
        return t_ == rhs.t_;
    }

private:

    T t_;
};



template<class T> bool ref_compare( value< weak_ptr<T> > const & a, value< weak_ptr<T> > const & b, int )
{
    return !(a.get() < b.get()) && !(b.get() < a.get());
}



template<class T> class type {};



template<class F> struct unwrapper
{
    static inline F & unwrap( F & f, long )
    {
        return f;
    }

    template<class F2> static inline F2 & unwrap( reference_wrapper<F2> rf, int )
    {
        return rf.get();
    }

    template<class R, class T> static inline _mfi::dm<R, T> unwrap( R T::* pm, int )
    {
        return _mfi::dm<R, T>( pm );
    }
};



class list0
{
public:

    list0() {}

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A &, long)
    {
        return unwrapper<F>::unwrap(f, 0)();
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A &, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)();
    }

    template<class F, class A> void operator()(type<void>, F & f, A &, int)
    {
        unwrapper<F>::unwrap(f, 0)();
    }

    template<class F, class A> void operator()(type<void>, F const & f, A &, int) const
    {
        unwrapper<F const>::unwrap(f, 0)();
    }

    template<class V> void accept(V &) const
    {
    }

    bool operator==(list0 const &) const
    {
        return true;
    }
};
# 223 "/usr/local/include/boost/bind/bind.hpp" 3
template< class A1 > class list1: private storage1< A1 >
{
private:

    typedef storage1< A1 > base_type;

public:

    explicit list1( A1 a1 ): base_type( a1 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list1 const & rhs) const
    {
        return ref_compare(base_type::a1_, rhs.a1_, 0);
    }
};

struct logical_and;
struct logical_or;

template< class A1, class A2 > class list2: private storage2< A1, A2 >
{
private:

    typedef storage2< A1, A2 > base_type;

public:

    list2( A1 a1, A2 a2 ): base_type( a1, a2 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
    }

    template<class A> bool operator()( type<bool>, logical_and & , A & a, int )
    {
        return a[ base_type::a1_ ] && a[ base_type::a2_ ];
    }

    template<class A> bool operator()( type<bool>, logical_and const & , A & a, int ) const
    {
        return a[ base_type::a1_ ] && a[ base_type::a2_ ];
    }

    template<class A> bool operator()( type<bool>, logical_or & , A & a, int )
    {
        return a[ base_type::a1_ ] || a[ base_type::a2_ ];
    }

    template<class A> bool operator()( type<bool>, logical_or const & , A & a, int ) const
    {
        return a[ base_type::a1_ ] || a[ base_type::a2_ ];
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list2 const & rhs) const
    {
        return ref_compare(base_type::a1_, rhs.a1_, 0) && ref_compare(base_type::a2_, rhs.a2_, 0);
    }
};

template< class A1, class A2, class A3 > class list3: private storage3< A1, A2, A3 >
{
private:

    typedef storage3< A1, A2, A3 > base_type;

public:

    list3( A1 a1, A2 a2, A3 a3 ): base_type( a1, a2, a3 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list3 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 );
    }
};

template< class A1, class A2, class A3, class A4 > class list4: private storage4< A1, A2, A3, A4 >
{
private:

    typedef storage4< A1, A2, A3, A4 > base_type;

public:

    list4( A1 a1, A2 a2, A3 a3, A4 a4 ): base_type( a1, a2, a3, a4 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list4 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 );
    }
};

template< class A1, class A2, class A3, class A4, class A5 > class list5: private storage5< A1, A2, A3, A4, A5 >
{
private:

    typedef storage5< A1, A2, A3, A4, A5 > base_type;

public:

    list5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): base_type( a1, a2, a3, a4, a5 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list5 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6> class list6: private storage6< A1, A2, A3, A4, A5, A6 >
{
private:

    typedef storage6< A1, A2, A3, A4, A5, A6 > base_type;

public:

    list6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): base_type( a1, a2, a3, a4, a5, a6 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list6 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> class list7: private storage7< A1, A2, A3, A4, A5, A6, A7 >
{
private:

    typedef storage7< A1, A2, A3, A4, A5, A6, A7 > base_type;

public:

    list7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): base_type( a1, a2, a3, a4, a5, a6, a7 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list7 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class list8: private storage8< A1, A2, A3, A4, A5, A6, A7, A8 >
{
private:

    typedef storage8< A1, A2, A3, A4, A5, A6, A7, A8 > base_type;

public:

    list8( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8 ): base_type( a1, a2, a3, a4, a5, a6, a7, a8 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8>) const { return base_type::a8_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8> (*) ()) const { return base_type::a8_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list8 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 ) &&
            ref_compare( base_type::a8_, rhs.a8_, 0 );
    }
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> class list9: private storage9< A1, A2, A3, A4, A5, A6, A7, A8, A9 >
{
private:

    typedef storage9< A1, A2, A3, A4, A5, A6, A7, A8, A9 > base_type;

public:

    list9( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9 ): base_type( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) {}

    A1 operator[] (boost::arg<1>) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2>) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3>) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4>) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5>) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6>) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7>) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8>) const { return base_type::a8_; }
    A9 operator[] (boost::arg<9>) const { return base_type::a9_; }

    A1 operator[] (boost::arg<1> (*) ()) const { return base_type::a1_; }
    A2 operator[] (boost::arg<2> (*) ()) const { return base_type::a2_; }
    A3 operator[] (boost::arg<3> (*) ()) const { return base_type::a3_; }
    A4 operator[] (boost::arg<4> (*) ()) const { return base_type::a4_; }
    A5 operator[] (boost::arg<5> (*) ()) const { return base_type::a5_; }
    A6 operator[] (boost::arg<6> (*) ()) const { return base_type::a6_; }
    A7 operator[] (boost::arg<7> (*) ()) const { return base_type::a7_; }
    A8 operator[] (boost::arg<8> (*) ()) const { return base_type::a8_; }
    A9 operator[] (boost::arg<9> (*) ()) const { return base_type::a9_; }

    template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

    template<class T> T const & operator[] (_bi::value<T> const & v) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const { return b.eval(*this); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const { return b.eval(*this); }

    template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)
    {
        return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class R, class F, class A> R operator()(type<R>, F const & f, A & a, long) const
    {
        return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class F, class A> void operator()(type<void>, F & f, A & a, int)
    {
        unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class F, class A> void operator()(type<void>, F const & f, A & a, int) const
    {
        unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
    }

    template<class V> void accept(V & v) const
    {
        base_type::accept(v);
    }

    bool operator==(list9 const & rhs) const
    {
        return

            ref_compare( base_type::a1_, rhs.a1_, 0 ) &&
            ref_compare( base_type::a2_, rhs.a2_, 0 ) &&
            ref_compare( base_type::a3_, rhs.a3_, 0 ) &&
            ref_compare( base_type::a4_, rhs.a4_, 0 ) &&
            ref_compare( base_type::a5_, rhs.a5_, 0 ) &&
            ref_compare( base_type::a6_, rhs.a6_, 0 ) &&
            ref_compare( base_type::a7_, rhs.a7_, 0 ) &&
            ref_compare( base_type::a8_, rhs.a8_, 0 ) &&
            ref_compare( base_type::a9_, rhs.a9_, 0 );
    }
};
# 870 "/usr/local/include/boost/bind/bind.hpp" 3
template< class A1 > class rrlist1
{
private:

    A1 & a1_;

public:

    explicit rrlist1( A1 & a1 ): a1_( a1 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist1<A1&> a( a1_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist1<A1&> a( a1_ );
        return b.eval( a );
    }
};

template< class A1, class A2 > class rrlist2
{
private:

    A1 & a1_;
    A2 & a2_;

public:

    rrlist2( A1 & a1, A2 & a2 ): a1_( a1 ), a2_( a2 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist2<A1&, A2&> a( a1_, a2_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist2<A1&, A2&> a( a1_, a2_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3 > class rrlist3
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;

public:

    rrlist3( A1 & a1, A2 & a2, A3 & a3 ): a1_( a1 ), a2_( a2 ), a3_( a3 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist3<A1&, A2&, A3&> a( a1_, a2_, a3_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist3<A1&, A2&, A3&> a( a1_, a2_, a3_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3, class A4 > class rrlist4
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;
    A4 & a4_;

public:

    rrlist4( A1 & a1, A2 & a2, A3 & a3, A4 & a4 ): a1_( a1 ), a2_( a2 ), a3_( a3 ), a4_( a4 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4>) const { return std::forward<A4>( a4_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4> (*) ()) const { return std::forward<A4>( a4_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist4<A1&, A2&, A3&, A4&> a( a1_, a2_, a3_, a4_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist4<A1&, A2&, A3&, A4&> a( a1_, a2_, a3_, a4_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3, class A4, class A5 > class rrlist5
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;
    A4 & a4_;
    A5 & a5_;

public:

    rrlist5( A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5 ): a1_( a1 ), a2_( a2 ), a3_( a3 ), a4_( a4 ), a5_( a5 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4>) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5>) const { return std::forward<A5>( a5_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4> (*) ()) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5> (*) ()) const { return std::forward<A5>( a5_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist5<A1&, A2&, A3&, A4&, A5&> a( a1_, a2_, a3_, a4_, a5_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist5<A1&, A2&, A3&, A4&, A5&> a( a1_, a2_, a3_, a4_, a5_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6 > class rrlist6
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;
    A4 & a4_;
    A5 & a5_;
    A6 & a6_;

public:

    rrlist6( A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6 ): a1_( a1 ), a2_( a2 ), a3_( a3 ), a4_( a4 ), a5_( a5 ), a6_( a6 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4>) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5>) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6>) const { return std::forward<A6>( a6_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4> (*) ()) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5> (*) ()) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6> (*) ()) const { return std::forward<A6>( a6_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist6<A1&, A2&, A3&, A4&, A5&, A6&> a( a1_, a2_, a3_, a4_, a5_, a6_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist6<A1&, A2&, A3&, A4&, A5&, A6&> a( a1_, a2_, a3_, a4_, a5_, a6_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class rrlist7
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;
    A4 & a4_;
    A5 & a5_;
    A6 & a6_;
    A7 & a7_;

public:

    rrlist7( A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7 ): a1_( a1 ), a2_( a2 ), a3_( a3 ), a4_( a4 ), a5_( a5 ), a6_( a6 ), a7_( a7 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4>) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5>) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6>) const { return std::forward<A6>( a6_ ); }
    A7 && operator[] (boost::arg<7>) const { return std::forward<A7>( a7_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4> (*) ()) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5> (*) ()) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6> (*) ()) const { return std::forward<A6>( a6_ ); }
    A7 && operator[] (boost::arg<7> (*) ()) const { return std::forward<A7>( a7_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist7<A1&, A2&, A3&, A4&, A5&, A6&, A7&> a( a1_, a2_, a3_, a4_, a5_, a6_, a7_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist7<A1&, A2&, A3&, A4&, A5&, A6&, A7&> a( a1_, a2_, a3_, a4_, a5_, a6_, a7_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class rrlist8
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;
    A4 & a4_;
    A5 & a5_;
    A6 & a6_;
    A7 & a7_;
    A8 & a8_;

public:

    rrlist8( A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8 ): a1_( a1 ), a2_( a2 ), a3_( a3 ), a4_( a4 ), a5_( a5 ), a6_( a6 ), a7_( a7 ), a8_( a8 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4>) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5>) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6>) const { return std::forward<A6>( a6_ ); }
    A7 && operator[] (boost::arg<7>) const { return std::forward<A7>( a7_ ); }
    A8 && operator[] (boost::arg<8>) const { return std::forward<A8>( a8_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4> (*) ()) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5> (*) ()) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6> (*) ()) const { return std::forward<A6>( a6_ ); }
    A7 && operator[] (boost::arg<7> (*) ()) const { return std::forward<A7>( a7_ ); }
    A8 && operator[] (boost::arg<8> (*) ()) const { return std::forward<A8>( a8_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist8<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&> a( a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist8<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&> a( a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_ );
        return b.eval( a );
    }
};

template< class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9 > class rrlist9
{
private:

    A1 & a1_;
    A2 & a2_;
    A3 & a3_;
    A4 & a4_;
    A5 & a5_;
    A6 & a6_;
    A7 & a7_;
    A8 & a8_;
    A9 & a9_;

public:

    rrlist9( A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9 ): a1_( a1 ), a2_( a2 ), a3_( a3 ), a4_( a4 ), a5_( a5 ), a6_( a6 ), a7_( a7 ), a8_( a8 ), a9_( a9 ) {}

    A1 && operator[] (boost::arg<1>) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2>) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3>) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4>) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5>) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6>) const { return std::forward<A6>( a6_ ); }
    A7 && operator[] (boost::arg<7>) const { return std::forward<A7>( a7_ ); }
    A8 && operator[] (boost::arg<8>) const { return std::forward<A8>( a8_ ); }
    A9 && operator[] (boost::arg<9>) const { return std::forward<A9>( a9_ ); }

    A1 && operator[] (boost::arg<1> (*) ()) const { return std::forward<A1>( a1_ ); }
    A2 && operator[] (boost::arg<2> (*) ()) const { return std::forward<A2>( a2_ ); }
    A3 && operator[] (boost::arg<3> (*) ()) const { return std::forward<A3>( a3_ ); }
    A4 && operator[] (boost::arg<4> (*) ()) const { return std::forward<A4>( a4_ ); }
    A5 && operator[] (boost::arg<5> (*) ()) const { return std::forward<A5>( a5_ ); }
    A6 && operator[] (boost::arg<6> (*) ()) const { return std::forward<A6>( a6_ ); }
    A7 && operator[] (boost::arg<7> (*) ()) const { return std::forward<A7>( a7_ ); }
    A8 && operator[] (boost::arg<8> (*) ()) const { return std::forward<A8>( a8_ ); }
    A9 && operator[] (boost::arg<9> (*) ()) const { return std::forward<A9>( a9_ ); }

    template<class T> T & operator[] ( _bi::value<T> & v ) const { return v.get(); }

    template<class T> T const & operator[] ( _bi::value<T> const & v ) const { return v.get(); }

    template<class T> T & operator[] (reference_wrapper<T> const & v) const { return v.get(); }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> & b) const
    {
        rrlist9<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&, A9&> a( a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_ );
        return b.eval( a );
    }

    template<class R, class F, class L> typename result_traits<R, F>::type operator[] (bind_t<R, F, L> const & b) const
    {
        rrlist9<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&, A9&> a( a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_ );
        return b.eval( a );
    }
};

template<class R, class F, class L> class bind_t
{
private:

    F f_;
    L l_;

public:

    typedef typename result_traits<R, F>::type result_type;
    typedef bind_t this_type;

    bind_t( F f, L const & l ): f_( f ), l_( l ) {}



    result_type operator()()
    {
        list0 a;
        return l_( type<result_type>(), f_, a, 0 );
    }

    result_type operator()() const
    {
        list0 a;
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1> result_type operator()( A1 && a1 )
    {
        rrlist1< A1 > a( a1 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1> result_type operator()( A1 && a1 ) const
    {
        rrlist1< A1 > a( a1 );
        return l_(type<result_type>(), f_, a, 0);
    }

    template<class A1, class A2> result_type operator()( A1 && a1, A2 && a2 )
    {
        rrlist2< A1, A2 > a( a1, a2 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2> result_type operator()( A1 && a1, A2 && a2 ) const
    {
        rrlist2< A1, A2 > a( a1, a2 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3> result_type operator()( A1 && a1, A2 && a2, A3 && a3 )
    {
        rrlist3< A1, A2, A3 > a( a1, a2, a3 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3> result_type operator()( A1 && a1, A2 && a2, A3 && a3 ) const
    {
        rrlist3< A1, A2, A3 > a( a1, a2, a3 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4 )
    {
        rrlist4< A1, A2, A3, A4 > a( a1, a2, a3, a4 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4 ) const
    {
        rrlist4< A1, A2, A3, A4 > a( a1, a2, a3, a4 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5 )
    {
        rrlist5< A1, A2, A3, A4, A5 > a( a1, a2, a3, a4, a5 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5 ) const
    {
        rrlist5< A1, A2, A3, A4, A5 > a( a1, a2, a3, a4, a5 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6 )
    {
        rrlist6< A1, A2, A3, A4, A5, A6 > a( a1, a2, a3, a4, a5, a6 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6 ) const
    {
        rrlist6< A1, A2, A3, A4, A5, A6 > a( a1, a2, a3, a4, a5, a6 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6, A7 && a7 )
    {
        rrlist7< A1, A2, A3, A4, A5, A6, A7 > a( a1, a2, a3, a4, a5, a6, a7 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6, A7 && a7 ) const
    {
        rrlist7< A1, A2, A3, A4, A5, A6, A7 > a( a1, a2, a3, a4, a5, a6, a7 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6, A7 && a7, A8 && a8 )
    {
        rrlist8< A1, A2, A3, A4, A5, A6, A7, A8 > a( a1, a2, a3, a4, a5, a6, a7, a8 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6, A7 && a7, A8 && a8 ) const
    {
        rrlist8< A1, A2, A3, A4, A5, A6, A7, A8 > a( a1, a2, a3, a4, a5, a6, a7, a8 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6, A7 && a7, A8 && a8, A9 && a9 )
    {
        rrlist9< A1, A2, A3, A4, A5, A6, A7, A8, A9 > a( a1, a2, a3, a4, a5, a6, a7, a8, a9 );
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()( A1 && a1, A2 && a2, A3 && a3, A4 && a4, A5 && a5, A6 && a6, A7 && a7, A8 && a8, A9 && a9 ) const
    {
        rrlist9< A1, A2, A3, A4, A5, A6, A7, A8, A9 > a( a1, a2, a3, a4, a5, a6, a7, a8, a9 );
        return l_( type<result_type>(), f_, a, 0 );
    }



    template<class A> result_type eval( A & a )
    {
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class A> result_type eval( A & a ) const
    {
        return l_( type<result_type>(), f_, a, 0 );
    }

    template<class V> void accept( V & v ) const
    {

        using boost::visit_each;


        visit_each( v, f_, 0 );
        l_.accept( v );
    }

    bool compare( this_type const & rhs ) const
    {
        return ref_compare( f_, rhs.f_, 0 ) && l_ == rhs.l_;
    }
};
# 1517 "/usr/local/include/boost/bind/bind.hpp" 3
template<class R, class F, class L> bool function_equal( bind_t<R, F, L> const & a, bind_t<R, F, L> const & b )
{
    return a.compare(b);
}
# 1571 "/usr/local/include/boost/bind/bind.hpp" 3
template< class T, int I > struct add_value_2
{
    typedef boost::arg<I> type;
};

template< class T > struct add_value_2< T, 0 >
{
    typedef _bi::value< T > type;
};

template<class T> struct add_value
{
    typedef typename add_value_2< T, boost::is_placeholder< T >::value >::type type;
};



template<class T> struct add_value< value<T> >
{
    typedef _bi::value<T> type;
};

template<class T> struct add_value< reference_wrapper<T> >
{
    typedef reference_wrapper<T> type;
};

template<int I> struct add_value< arg<I> >
{
    typedef boost::arg<I> type;
};

template<int I> struct add_value< arg<I> (*) () >
{
    typedef boost::arg<I> (*type) ();
};

template<class R, class F, class L> struct add_value< bind_t<R, F, L> >
{
    typedef bind_t<R, F, L> type;
};
# 1654 "/usr/local/include/boost/bind/bind.hpp" 3
template<class A1> struct list_av_1
{
    typedef typename add_value<A1>::type B1;
    typedef list1<B1> type;
};

template<class A1, class A2> struct list_av_2
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef list2<B1, B2> type;
};

template<class A1, class A2, class A3> struct list_av_3
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef list3<B1, B2, B3> type;
};

template<class A1, class A2, class A3, class A4> struct list_av_4
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef list4<B1, B2, B3, B4> type;
};

template<class A1, class A2, class A3, class A4, class A5> struct list_av_5
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef list5<B1, B2, B3, B4, B5> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6> struct list_av_6
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef list6<B1, B2, B3, B4, B5, B6> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> struct list_av_7
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef list7<B1, B2, B3, B4, B5, B6, B7> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> struct list_av_8
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef typename add_value<A8>::type B8;
    typedef list8<B1, B2, B3, B4, B5, B6, B7, B8> type;
};

template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> struct list_av_9
{
    typedef typename add_value<A1>::type B1;
    typedef typename add_value<A2>::type B2;
    typedef typename add_value<A3>::type B3;
    typedef typename add_value<A4>::type B4;
    typedef typename add_value<A5>::type B5;
    typedef typename add_value<A6>::type B6;
    typedef typename add_value<A7>::type B7;
    typedef typename add_value<A8>::type B8;
    typedef typename add_value<A9>::type B9;
    typedef list9<B1, B2, B3, B4, B5, B6, B7, B8, B9> type;
};



struct logical_not
{
    template<class V> bool operator()(V const & v) const { return !v; }
};

template<class R, class F, class L>
    bind_t< bool, logical_not, list1< bind_t<R, F, L> > >
    operator! (bind_t<R, F, L> const & f)
{
    typedef list1< bind_t<R, F, L> > list_type;
    return bind_t<bool, logical_not, list_type> ( logical_not(), list_type(f) );
}
# 1777 "/usr/local/include/boost/bind/bind.hpp" 3
struct equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v == w; } }; template<class R, class F, class L, class A2> bind_t< bool, equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator == (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, equal, list_type> ( equal(), list_type(f, a2) ); }
struct not_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v != w; } }; template<class R, class F, class L, class A2> bind_t< bool, not_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator != (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, not_equal, list_type> ( not_equal(), list_type(f, a2) ); }

struct less { template<class V, class W> bool operator()(V const & v, W const & w) const { return v < w; } }; template<class R, class F, class L, class A2> bind_t< bool, less, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator < (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, less, list_type> ( less(), list_type(f, a2) ); }
struct less_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v <= w; } }; template<class R, class F, class L, class A2> bind_t< bool, less_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator <= (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, less_equal, list_type> ( less_equal(), list_type(f, a2) ); }

struct greater { template<class V, class W> bool operator()(V const & v, W const & w) const { return v > w; } }; template<class R, class F, class L, class A2> bind_t< bool, greater, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator > (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, greater, list_type> ( greater(), list_type(f, a2) ); }
struct greater_equal { template<class V, class W> bool operator()(V const & v, W const & w) const { return v >= w; } }; template<class R, class F, class L, class A2> bind_t< bool, greater_equal, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator >= (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, greater_equal, list_type> ( greater_equal(), list_type(f, a2) ); }

struct logical_and { template<class V, class W> bool operator()(V const & v, W const & w) const { return v && w; } }; template<class R, class F, class L, class A2> bind_t< bool, logical_and, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator && (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, logical_and, list_type> ( logical_and(), list_type(f, a2) ); }
struct logical_or { template<class V, class W> bool operator()(V const & v, W const & w) const { return v || w; } }; template<class R, class F, class L, class A2> bind_t< bool, logical_or, list2< bind_t<R, F, L>, typename add_value<A2>::type > > operator || (bind_t<R, F, L> const & f, A2 a2) { typedef typename add_value<A2>::type B2; typedef list2< bind_t<R, F, L>, B2> list_type; return bind_t<bool, logical_or, list_type> ( logical_or(), list_type(f, a2) ); }
# 1817 "/usr/local/include/boost/bind/bind.hpp" 3
template<class V, class T> void visit_each( V & v, value<T> const & t, int )
{
    using boost::visit_each;
    visit_each( v, t.get(), 0 );
}

template<class V, class R, class F, class L> void visit_each( V & v, bind_t<R, F, L> const & t, int )
{
    t.accept( v );
}



}
# 1851 "/usr/local/include/boost/bind/bind.hpp" 3
template< class T > struct is_bind_expression
{
    enum _vt { value = 0 };
};



template< class R, class F, class L > struct is_bind_expression< _bi::bind_t< R, F, L > >
{
    enum _vt { value = 1 };
};
# 1873 "/usr/local/include/boost/bind/bind.hpp" 3
template<class R, class F>
    _bi::bind_t<R, F, _bi::list0>
    bind(F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class F, class A1>
    _bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>
    bind(F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class F, class A1, class A2>
    _bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>
    bind(F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R, class F, class A1, class A2, class A3>
    _bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R, class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}



template<class R, class F>
    _bi::bind_t<R, F, _bi::list0>
    bind(boost::type<R>, F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class F, class A1>
    _bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>
    bind(boost::type<R>, F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class F, class A1, class A2>
    _bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R, class F, class A1, class A2, class A3>
    _bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R, class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}





template<class F>
    _bi::bind_t<_bi::unspecified, F, _bi::list0>
    bind(F f)
{
    typedef _bi::list0 list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type());
}

template<class F, class A1>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_1<A1>::type>
    bind(F f, A1 a1)
{
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type(a1));
}

template<class F, class A1, class A2>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_2<A1, A2>::type>
    bind(F f, A1 a1, A2 a2)
{
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type> (f, list_type(a1, a2));
}

template<class F, class A1, class A2, class A3>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(F f, A1 a1, A2 a2, A3 a3)
{
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3));
}

template<class F, class A1, class A2, class A3, class A4>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class F, class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<_bi::unspecified, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 2127 "/usr/local/include/boost/bind/bind.hpp" 3
# 1 "/usr/local/include/boost/bind/bind_cc.hpp" 1 3
# 15 "/usr/local/include/boost/bind/bind_cc.hpp" 3
template<class R>
    _bi::bind_t<R, R ( *) () , _bi::list0>
    bind( R ( *f) () )
{
    typedef R ( *F) () ;
    typedef _bi::list0 list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type());
}

template<class R, class B1, class A1>
    _bi::bind_t<R, R ( *) (B1) , typename _bi::list_av_1<A1>::type>
    bind( R ( *f) (B1) , A1 a1)
{
    typedef R ( *F) (B1) ;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1));
}

template<class R, class B1, class B2, class A1, class A2>
    _bi::bind_t<R, R ( *) (B1, B2) , typename _bi::list_av_2<A1, A2>::type>
    bind( R ( *f) (B1, B2) , A1 a1, A2 a2)
{
    typedef R ( *F) (B1, B2) ;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type> (f, list_type(a1, a2));
}

template<class R,
    class B1, class B2, class B3,
    class A1, class A2, class A3>
    _bi::bind_t<R, R ( *) (B1, B2, B3) , typename _bi::list_av_3<A1, A2, A3>::type>
    bind( R ( *f) (B1, B2, B3) , A1 a1, A2 a2, A3 a3)
{
    typedef R ( *F) (B1, B2, B3) ;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
}

template<class R,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4) , typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind( R ( *f) (B1, B2, B3, B4) , A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef R ( *F) (B1, B2, B3, B4) ;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5) , typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef R ( *F) (B1, B2, B3, B4, B5) ;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6) , typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6) ;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7) , typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7) ;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7, B8) , typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7, B8) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7, B8) ;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class B9,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, R ( *) (B1, B2, B3, B4, B5, B6, B7, B8, B9) , typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind( R ( *f) (B1, B2, B3, B4, B5, B6, B7, B8, B9) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef R ( *F) (B1, B2, B3, B4, B5, B6, B7, B8, B9) ;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 2128 "/usr/local/include/boost/bind/bind.hpp" 2 3
# 2187 "/usr/local/include/boost/bind/bind.hpp" 3
# 1 "/usr/local/include/boost/bind/bind_mf_cc.hpp" 1 3
# 17 "/usr/local/include/boost/bind/bind_mf_cc.hpp" 3
template<class R, class T,
    class A1>
    _bi::bind_t<R, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(R ( T::*f) () , A1 a1)
{
    typedef _mfi::mf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
}

template<class R, class T,
    class A1>
    _bi::bind_t<R, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(R ( T::*f) () const , A1 a1)
{
    typedef _mfi::cmf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
}

template<class Rt2, class R, class T,
    class A1>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>
    >::type bind(R ( T::*f) () , A1 a1)
{
    typedef _mfi::mf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
}

template<class Rt2, class R, class T,
    class A1>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>
    >::type bind(R ( T::*f) () const , A1 a1)
{
    typedef _mfi::cmf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
}



template<class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<R, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(R ( T::*f) (B1) , A1 a1, A2 a2)
{
    typedef _mfi::mf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
}

template<class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<R, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(R ( T::*f) (B1) const , A1 a1, A2 a2)
{
    typedef _mfi::cmf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
}

template<class Rt2, class R, class T,
    class B1,
    class A1, class A2>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    >::type bind(R ( T::*f) (B1) , A1 a1, A2 a2)
{
    typedef _mfi::mf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
}

template<class Rt2, class R, class T,
    class B1,
    class A1, class A2>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    >::type bind(R ( T::*f) (B1) const , A1 a1, A2 a2)
{
    typedef _mfi::cmf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
}



template<class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<R, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(R ( T::*f) (B1, B2) , A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::mf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<R, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(R ( T::*f) (B1, B2) const , A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::cmf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class Rt2, class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    >::type bind(R ( T::*f) (B1, B2) , A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::mf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class Rt2, class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    >::type bind(R ( T::*f) (B1, B2) const , A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::cmf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
}



template<class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(R ( T::*f) (B1, B2, B3) , A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::mf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<R, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(R ( T::*f) (B1, B2, B3) const , A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::cmf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    >::type bind(R ( T::*f) (B1, B2, B3) , A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::mf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    >::type bind(R ( T::*f) (B1, B2, B3) const , A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::cmf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}



template<class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(R ( T::*f) (B1, B2, B3, B4) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::mf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<R, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(R ( T::*f) (B1, B2, B3, B4) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::cmf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::mf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::cmf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<R, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<R, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5, B6) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5, B6) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<R, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}



template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<R, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    typename boost::enable_if_c<!boost::core::is_same<Rt2, R>::value,
    _bi::bind_t<Rt2, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    >::type bind(R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) const , A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 2188 "/usr/local/include/boost/bind/bind.hpp" 2 3
# 1 "/usr/local/include/boost/bind/bind_mf2_cc.hpp" 1 3
# 18 "/usr/local/include/boost/bind/bind_mf2_cc.hpp" 3
template<class Rt2, class R, class T,
    class A1>
    _bi::bind_t<Rt2, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(boost::type<Rt2>, R ( T::*f) (), A1 a1)
{
    typedef _mfi::mf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
}

template<class Rt2, class R, class T,
    class A1>
    _bi::bind_t<Rt2, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>
    bind(boost::type<Rt2>, R ( T::*f) () const, A1 a1)
{
    typedef _mfi::cmf0<R, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
}



template<class Rt2, class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<Rt2, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1), A1 a1, A2 a2)
{
    typedef _mfi::mf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
}

template<class Rt2, class R, class T,
    class B1,
    class A1, class A2>
    _bi::bind_t<Rt2, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1) const, A1 a1, A2 a2)
{
    typedef _mfi::cmf1<R, T, B1> F;
    typedef typename _bi::list_av_2<A1, A2>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
}



template<class Rt2, class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<Rt2, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2), A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::mf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
}

template<class Rt2, class R, class T,
    class B1, class B2,
    class A1, class A2, class A3>
    _bi::bind_t<Rt2, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2) const, A1 a1, A2 a2, A3 a3)
{
    typedef _mfi::cmf2<R, T, B1, B2> F;
    typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<Rt2, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3), A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::mf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3,
    class A1, class A2, class A3, class A4>
    _bi::bind_t<Rt2, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3) const, A1 a1, A2 a2, A3 a3, A4 a4)
{
    typedef _mfi::cmf3<R, T, B1, B2, B3> F;
    typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<Rt2, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::mf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4,
    class A1, class A2, class A3, class A4, class A5>
    _bi::bind_t<Rt2, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
    typedef _mfi::cmf4<R, T, B1, B2, B3, B4> F;
    typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<Rt2, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5,
    class A1, class A2, class A3, class A4, class A5, class A6>
    _bi::bind_t<Rt2, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
    typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5> F;
    typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<Rt2, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7>
    _bi::bind_t<Rt2, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
    typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6> F;
    typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<Rt2, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
    _bi::bind_t<Rt2, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
    typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7> F;
    typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
}



template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<Rt2, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<class Rt2, class R, class T,
    class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8,
    class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
    _bi::bind_t<Rt2, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>
    bind(boost::type<Rt2>, R ( T::*f) (B1, B2, B3, B4, B5, B6, B7, B8) const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
    typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8> F;
    typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
    return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
# 2189 "/usr/local/include/boost/bind/bind.hpp" 2 3
# 2261 "/usr/local/include/boost/bind/bind.hpp" 3
namespace _bi
{

template< class Pm, int I > struct add_cref;

template< class M, class T > struct add_cref< M T::*, 0 >
{
    typedef M type;
};

template< class M, class T > struct add_cref< M T::*, 1 >
{




    typedef M const & type;



};

template< class R, class T > struct add_cref< R (T::*) (), 1 >
{
    typedef void type;
};



template< class R, class T > struct add_cref< R (T::*) () const, 1 >
{
    typedef void type;
};
# 2306 "/usr/local/include/boost/bind/bind.hpp" 3
template<class R> struct isref
{
    enum value_type { value = 0 };
};

template<class R> struct isref< R& >
{
    enum value_type { value = 1 };
};

template<class R> struct isref< R* >
{
    enum value_type { value = 1 };
};

template<class Pm, class A1> struct dm_result
{
    typedef typename add_cref< Pm, 1 >::type type;
};

template<class Pm, class R, class F, class L> struct dm_result< Pm, bind_t<R, F, L> >
{
    typedef typename bind_t<R, F, L>::result_type result_type;
    typedef typename add_cref< Pm, isref< result_type >::value >::type type;
};

}

template< class A1, class M, class T >

_bi::bind_t<
    typename _bi::dm_result< M T::*, A1 >::type,
    _mfi::dm<M, T>,
    typename _bi::list_av_1<A1>::type
>

bind( M T::*f, A1 a1 )
{
    typedef typename _bi::dm_result< M T::*, A1 >::type result_type;
    typedef _mfi::dm<M, T> F;
    typedef typename _bi::list_av_1<A1>::type list_type;
    return _bi::bind_t< result_type, F, list_type >( F( f ), list_type( a1 ) );
}



}



# 1 "/usr/local/include/boost/bind/placeholders.hpp" 1 3
# 26 "/usr/local/include/boost/bind/placeholders.hpp" 3
namespace boost
{

namespace placeholders
{
# 46 "/usr/local/include/boost/bind/placeholders.hpp" 3
static constexpr boost::arg<1> _1;
static constexpr boost::arg<2> _2;
static constexpr boost::arg<3> _3;
static constexpr boost::arg<4> _4;
static constexpr boost::arg<5> _5;
static constexpr boost::arg<6> _6;
static constexpr boost::arg<7> _7;
static constexpr boost::arg<8> _8;
static constexpr boost::arg<9> _9;



}

}
# 2357 "/usr/local/include/boost/bind/bind.hpp" 2 3
# 23 "/usr/local/include/boost/bind.hpp" 2 3
# 33 "/usr/local/include/boost/bind.hpp" 3
using namespace boost::placeholders;
# 11 "/usr/local/include/boost/python/exception_translator.hpp" 2 3


# 1 "/usr/local/include/boost/python/detail/translate_exception.hpp" 1 3







# 1 "/usr/local/include/boost/python/detail/exception_handler.hpp" 1 3
# 9 "/usr/local/include/boost/python/detail/exception_handler.hpp" 3
# 1 "/usr/local/include/boost/function/function0.hpp" 1 3
# 11 "/usr/local/include/boost/function/function0.hpp" 3
# 1 "/usr/local/include/boost/function/detail/maybe_include.hpp" 1 3
# 12 "/usr/local/include/boost/function/function0.hpp" 2 3
# 10 "/usr/local/include/boost/python/detail/exception_handler.hpp" 2 3
# 1 "/usr/local/include/boost/function/function2.hpp" 1 3
# 11 "/usr/local/include/boost/function/function2.hpp" 3
# 1 "/usr/local/include/boost/function/detail/maybe_include.hpp" 1 3
# 12 "/usr/local/include/boost/function/function2.hpp" 2 3
# 11 "/usr/local/include/boost/python/detail/exception_handler.hpp" 2 3

namespace boost { namespace python { namespace detail {

struct exception_handler;

typedef function2<bool, exception_handler const&, function0<void> const&> handler_function;

struct exception_handler
{
 private:

 public:
    explicit exception_handler(handler_function const& impl);

    inline bool handle(function0<void> const& f) const;

    bool operator()(function0<void> const& f) const;

    static exception_handler* chain;

 private:
    static exception_handler* tail;

    handler_function m_impl;
    exception_handler* m_next;
};


inline bool exception_handler::handle(function0<void> const& f) const
{
    return this->m_impl(*this, f);
}

 void register_exception_handler(handler_function const& f);

}}}
# 9 "/usr/local/include/boost/python/detail/translate_exception.hpp" 2 3




# 1 "/usr/local/include/boost/function/function0.hpp" 1 3
# 11 "/usr/local/include/boost/function/function0.hpp" 3
# 1 "/usr/local/include/boost/function/detail/maybe_include.hpp" 1 3
# 12 "/usr/local/include/boost/function/function0.hpp" 2 3
# 14 "/usr/local/include/boost/python/detail/translate_exception.hpp" 2 3

namespace boost { namespace python { namespace detail {





template <class ExceptionType, class Translate>
struct translate_exception
{
# 34 "/usr/local/include/boost/python/detail/translate_exception.hpp" 3
    typedef typename add_lvalue_reference<
        typename add_const<ExceptionType>::type
    >::type exception_cref;


    inline bool operator()(
        exception_handler const& handler
      , function0<void> const& f
      , typename call_traits<Translate>::param_type translate) const
    {
        try
        {
            return handler(f);
        }
# 56 "/usr/local/include/boost/python/detail/translate_exception.hpp" 3
        catch(exception_cref e)

        {
            translate(e);
            return true;
        }
    }
};

}}}
# 14 "/usr/local/include/boost/python/exception_translator.hpp" 2 3


namespace boost { namespace python {

template <class ExceptionType, class Translate>
void register_exception_translator(Translate translate, boost::type<ExceptionType>* = 0)
{
    detail::register_exception_handler(
        boost::bind<bool>(detail::translate_exception<ExceptionType,Translate>(), _1, _2, translate)
        );
}

}}
# 29 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/exec.hpp" 1 3
# 9 "/usr/local/include/boost/python/exec.hpp" 3
# 1 "/usr/local/include/boost/python/str.hpp" 1 3
# 22 "/usr/local/include/boost/python/str.hpp" 3
namespace boost { namespace python {

class str;

namespace detail
{
  struct str_base : object
  {
      str capitalize() const;

      str center(object_cref width) const;

      long count(object_cref sub) const;

      long count(object_cref sub, object_cref start) const;

      long count(object_cref sub, object_cref start, object_cref end) const;


      object decode() const;
      object decode(object_cref encoding) const;

      object decode(object_cref encoding, object_cref errors) const;


      object encode() const;
      object encode(object_cref encoding) const;
      object encode(object_cref encoding, object_cref errors) const;

      bool endswith(object_cref suffix) const;

      bool endswith(object_cref suffix, object_cref start) const;
      bool endswith(object_cref suffix, object_cref start, object_cref end) const;

      str expandtabs() const;
      str expandtabs(object_cref tabsize) const;

      long find(object_cref sub) const;
      long find(object_cref sub, object_cref start) const;

      long find(object_cref sub, object_cref start, object_cref end) const;

      long index(object_cref sub) const;

      long index(object_cref sub, object_cref start) const;
      long index(object_cref sub, object_cref start, object_cref end) const;

      bool isalnum() const;
      bool isalpha() const;
      bool isdigit() const;
      bool islower() const;
      bool isspace() const;
      bool istitle() const;
      bool isupper() const;

      str join(object_cref sequence) const;

      str ljust(object_cref width) const;
      str lower() const;
      str lstrip() const;

      str replace(object_cref old, object_cref new_) const;
      str replace(object_cref old, object_cref new_, object_cref maxsplit) const;
      long rfind(object_cref sub) const;

      long rfind(object_cref sub, object_cref start) const;

      long rfind(object_cref sub, object_cref start, object_cref end) const;
      long rindex(object_cref sub) const;
      long rindex(object_cref sub, object_cref start) const;


      long rindex(object_cref sub, object_cref start, object_cref end) const;

      str rjust(object_cref width) const;

      str rstrip() const;

      list split() const;
      list split(object_cref sep) const;

      list split(object_cref sep, object_cref maxsplit) const;


      list splitlines() const;
      list splitlines(object_cref keepends) const;

      bool startswith(object_cref prefix) const;


      bool startswith(object_cref prefix, object_cref start) const;
      bool startswith(object_cref prefix, object_cref start, object_cref end) const;

      str strip() const;
      str swapcase() const;
      str title() const;

      str translate(object_cref table) const;

      str translate(object_cref table, object_cref deletechars) const;


      str upper() const;

   protected:
      str_base();

      str_base(const char* s);

      str_base(char const* start, char const* finish);

      str_base(char const* start, std::size_t length);

      explicit str_base(object_cref other);

      inline explicit str_base(::boost::python::detail::borrowed_reference p) : object(p) {} inline explicit str_base(::boost::python::detail::new_reference p) : object(p) {} inline explicit str_base(::boost::python::detail::new_non_null_reference p) : object(p) {}
   private:
      static new_reference call(object const&);
  };
}


class str : public detail::str_base
{
    typedef detail::str_base base;
 public:
    str() {}

    str(const char* s) : base(s) {}

    str(char const* start, char const* finish)
      : base(start, finish)
    {}

    str(char const* start, std::size_t length)
      : base(start, length)
    {}

    template <class T>
    explicit str(T const& other)
        : base(object(other))
    {
    }

    template <class T>
    str center(T const& width) const
    {
        return base::center(object(width));
    }

    template<class T>
    long count(T const& sub) const
    {
        return base::count(object(sub));
    }

    template<class T1, class T2>
    long count(T1 const& sub,T2 const& start) const
    {
        return base::count(object(sub), object(start));
    }

    template<class T1, class T2, class T3>
    long count(T1 const& sub,T2 const& start, T3 const& end) const
    {
        return base::count(object(sub), object(start), object(end));
    }


    object decode() const { return base::decode(); }

    template<class T>
    object decode(T const& encoding) const
    {
        return base::decode(object(encoding));
    }

    template<class T1, class T2>
    object decode(T1 const& encoding, T2 const& errors) const
    {
        return base::decode(object(encoding),object(errors));
    }


    object encode() const { return base::encode(); }

    template <class T>
    object encode(T const& encoding) const
    {
        return base::encode(object(encoding));
    }

    template <class T1, class T2>
    object encode(T1 const& encoding, T2 const& errors) const
    {
        return base::encode(object(encoding),object(errors));
    }

    template <class T>
    bool endswith(T const& suffix) const
    {
        return base::endswith(object(suffix));
    }

    template <class T1, class T2>
    bool endswith(T1 const& suffix, T2 const& start) const
    {
        return base::endswith(object(suffix), object(start));
    }

    template <class T1, class T2, class T3>
    bool endswith(T1 const& suffix, T2 const& start, T3 const& end) const
    {
        return base::endswith(object(suffix), object(start), object(end));
    }

    str expandtabs() const { return base::expandtabs(); }

    template <class T>
    str expandtabs(T const& tabsize) const
    {
        return base::expandtabs(object(tabsize));
    }

    template <class T>
    long find(T const& sub) const
    {
        return base::find(object(sub));
    }

    template <class T1, class T2>
    long find(T1 const& sub, T2 const& start) const
    {
        return base::find(object(sub), object(start));
    }

    template <class T1, class T2, class T3>
    long find(T1 const& sub, T2 const& start, T3 const& end) const
    {
        return base::find(object(sub), object(start), object(end));
    }

    template <class T>
    long index(T const& sub) const
    {
        return base::index(object(sub));
    }

    template <class T1, class T2>
    long index(T1 const& sub, T2 const& start) const
    {
        return base::index(object(sub), object(start));
    }

    template <class T1, class T2, class T3>
    long index(T1 const& sub, T2 const& start, T3 const& end) const
    {
        return base::index(object(sub), object(start), object(end));
    }

    template <class T>
    str join(T const& sequence) const
    {
        return base::join(object(sequence));
    }

    template <class T>
    str ljust(T const& width) const
    {
        return base::ljust(object(width));
    }

    template <class T1, class T2>
    str replace(T1 const& old, T2 const& new_) const
    {
        return base::replace(object(old),object(new_));
    }

    template <class T1, class T2, class T3>
    str replace(T1 const& old, T2 const& new_, T3 const& maxsplit) const
    {
        return base::replace(object(old),object(new_), object(maxsplit));
    }

    template <class T>
    long rfind(T const& sub) const
    {
        return base::rfind(object(sub));
    }

    template <class T1, class T2>
    long rfind(T1 const& sub, T2 const& start) const
    {
        return base::rfind(object(sub), object(start));
    }

    template <class T1, class T2, class T3>
    long rfind(T1 const& sub, T2 const& start, T3 const& end) const
    {
        return base::rfind(object(sub), object(start), object(end));
    }

    template <class T>
    long rindex(T const& sub) const
    {
        return base::rindex(object(sub));
    }

    template <class T1, class T2>
    long rindex(T1 const& sub, T2 const& start) const
    {
        return base::rindex(object(sub), object(start));
    }

    template <class T1, class T2, class T3>
    long rindex(T1 const& sub, T2 const& start, T3 const& end) const
    {
        return base::rindex(object(sub), object(start), object(end));
    }

    template <class T>
    str rjust(T const& width) const
    {
        return base::rjust(object(width));
    }

    list split() const { return base::split(); }

    template <class T>
    list split(T const& sep) const
    {
        return base::split(object(sep));
    }

    template <class T1, class T2>
    list split(T1 const& sep, T2 const& maxsplit) const
    {
        return base::split(object(sep), object(maxsplit));
    }

    list splitlines() const { return base::splitlines(); }

    template <class T>
    list splitlines(T const& keepends) const
    {
        return base::splitlines(object(keepends));
    }

    template <class T>
    bool startswith(T const& prefix) const
    {
        return base::startswith(object(prefix));
    }

    template <class T1, class T2>
    bool startswith(T1 const& prefix, T2 const& start) const
    {
        return base::startswith(object(prefix), object(start));
    }

    template <class T1, class T2, class T3>
    bool startswith(T1 const& prefix, T2 const& start, T3 const& end) const
    {
        return base::startswith(object(prefix), object(start), object(end));
    }

    template <class T>
    str translate(T const& table) const
    {
        return base::translate(object(table));
    }

    template <class T1, class T2>
    str translate(T1 const& table, T2 const& deletechars) const
    {
        return base::translate(object(table), object(deletechars));
    }

 public:
    inline explicit str(::boost::python::detail::borrowed_reference p) : base(p) {} inline explicit str(::boost::python::detail::new_reference p) : base(p) {} inline explicit str(::boost::python::detail::new_non_null_reference p) : base(p) {}
};




namespace converter
{
  template <>
  struct object_manager_traits<str>



      : pytype_object_manager_traits<&PyString_Type,str>

  {
  };
}

}}
# 10 "/usr/local/include/boost/python/exec.hpp" 2 3

namespace boost
{
namespace python
{




object

eval(str string, object global = object(), object local = object());

object

eval(char const *string, object global = object(), object local = object());




object

exec_statement(str string, object global = object(), object local = object());

object

exec_statement(char const *string, object global = object(), object local = object());




object

exec(str string, object global = object(), object local = object());

object

exec(char const *string, object global = object(), object local = object());




object

exec_file(str filename, object global = object(), object local = object());

object

exec_file(char const *filename, object global = object(), object local = object());

}
}
# 30 "/usr/local/include/boost/python.hpp" 2 3



# 1 "/usr/local/include/boost/python/implicit.hpp" 1 3
# 10 "/usr/local/include/boost/python/implicit.hpp" 3
# 1 "/usr/local/include/boost/python/converter/implicit.hpp" 1 3
# 14 "/usr/local/include/boost/python/converter/implicit.hpp" 3
namespace boost { namespace python { namespace converter {

template <class Source, class Target>
struct implicit
{
    static void* convertible(PyObject* obj)
    {




        return implicit_rvalue_convertible_from_python(obj, registered<Source>::converters)
            ? obj : 0;
    }

    static void construct(PyObject* obj, rvalue_from_python_stage1_data* data)
    {
        void* storage = ((rvalue_from_python_storage<Target>*)data)->storage.bytes;

        arg_from_python<Source> get_source(obj);
        bool convertible = get_source.convertible();
        (static_cast <bool> (convertible) ? void (0) : __assert_fail ("convertible", "/usr/local/include/boost/python/converter/implicit.hpp", 35, __extension__ __PRETTY_FUNCTION__));

        new (storage) Target(get_source());


        data->convertible = storage;
    }
};

}}}
# 11 "/usr/local/include/boost/python/implicit.hpp" 2 3






namespace boost { namespace python {

template <class Source, class Target>
void implicitly_convertible(boost::type<Source>* = 0, boost::type<Target>* = 0)
{
    typedef converter::implicit<Source,Target> functions;

    converter::registry::push_back(
          &functions::convertible
        , &functions::construct
        , type_id<Target>()

        , &converter::expected_from_python_type_direct<Source>::get_pytype

        );
}

}}
# 34 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/import.hpp" 1 3
# 11 "/usr/local/include/boost/python/import.hpp" 3
namespace boost
{
namespace python
{


object import(str name);

}
}
# 36 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/iterator.hpp" 1 3
# 10 "/usr/local/include/boost/python/iterator.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 22 "/usr/local/include/boost/python/detail/target.hpp" 3
namespace boost { namespace python { namespace detail {



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R >
void(* target(R (*)()) )()
{
    return 0;
}
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0>
A0(* target(R (*)( A0)) )()
{
    return 0;
}
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1>
A0(* target(R (*)( A0 , A1)) )()
{
    return 0;
}
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2>
A0(* target(R (*)( A0 , A1 , A2)) )()
{
    return 0;
}
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3>
A0(* target(R (*)( A0 , A1 , A2 , A3)) )()
{
    return 0;
}
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4)) )()
{
    return 0;
}
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5)) )()
{
    return 0;
}
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6)) )()
{
    return 0;
}
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7)) )()
{
    return 0;
}
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8)) )()
{
    return 0;
}
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9)) )()
{
    return 0;
}
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10)) )()
{
    return 0;
}
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11)) )()
{
    return 0;
}
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12)) )()
{
    return 0;
}
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13)) )()
{
    return 0;
}
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 46 "/usr/local/include/boost/python/detail/target.hpp" 3




template <class R , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
A0(* target(R (*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14)) )()
{
    return 0;
}
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 27 "/usr/local/include/boost/python/detail/target.hpp" 2 3



# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 64 "/usr/local/include/boost/python/detail/target.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T >
T& (* target(R (T::*)() ) )()
{
    return 0;
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0>
T& (* target(R (T::*)( A0) ) )()
{
    return 0;
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1>
T& (* target(R (T::*)( A0 , A1) ) )()
{
    return 0;
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2>
T& (* target(R (T::*)( A0 , A1 , A2) ) )()
{
    return 0;
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3>
T& (* target(R (T::*)( A0 , A1 , A2 , A3) ) )()
{
    return 0;
}
# 66 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4) ) )()
{
    return 0;
}
# 71 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5) ) )()
{
    return 0;
}
# 76 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6) ) )()
{
    return 0;
}
# 81 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7) ) )()
{
    return 0;
}
# 86 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8) ) )()
{
    return 0;
}
# 91 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9) ) )()
{
    return 0;
}
# 96 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10) ) )()
{
    return 0;
}
# 101 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11) ) )()
{
    return 0;
}
# 106 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12) ) )()
{
    return 0;
}
# 111 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13) ) )()
{
    return 0;
}
# 116 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14) ) )()
{
    return 0;
}
# 121 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 65 "/usr/local/include/boost/python/detail/target.hpp" 2 3
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 64 "/usr/local/include/boost/python/detail/target.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T >
T& (* target(R (T::*)() const) )()
{
    return 0;
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0>
T& (* target(R (T::*)( A0) const) )()
{
    return 0;
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1>
T& (* target(R (T::*)( A0 , A1) const) )()
{
    return 0;
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2>
T& (* target(R (T::*)( A0 , A1 , A2) const) )()
{
    return 0;
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3>
T& (* target(R (T::*)( A0 , A1 , A2 , A3) const) )()
{
    return 0;
}
# 66 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4) const) )()
{
    return 0;
}
# 71 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5) const) )()
{
    return 0;
}
# 76 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6) const) )()
{
    return 0;
}
# 81 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7) const) )()
{
    return 0;
}
# 86 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8) const) )()
{
    return 0;
}
# 91 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9) const) )()
{
    return 0;
}
# 96 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10) const) )()
{
    return 0;
}
# 101 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11) const) )()
{
    return 0;
}
# 106 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12) const) )()
{
    return 0;
}
# 111 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13) const) )()
{
    return 0;
}
# 116 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14) const) )()
{
    return 0;
}
# 121 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 65 "/usr/local/include/boost/python/detail/target.hpp" 2 3
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 64 "/usr/local/include/boost/python/detail/target.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T >
T& (* target(R (T::*)() volatile) )()
{
    return 0;
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0>
T& (* target(R (T::*)( A0) volatile) )()
{
    return 0;
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1>
T& (* target(R (T::*)( A0 , A1) volatile) )()
{
    return 0;
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2>
T& (* target(R (T::*)( A0 , A1 , A2) volatile) )()
{
    return 0;
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3>
T& (* target(R (T::*)( A0 , A1 , A2 , A3) volatile) )()
{
    return 0;
}
# 66 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4) volatile) )()
{
    return 0;
}
# 71 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5) volatile) )()
{
    return 0;
}
# 76 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6) volatile) )()
{
    return 0;
}
# 81 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7) volatile) )()
{
    return 0;
}
# 86 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8) volatile) )()
{
    return 0;
}
# 91 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9) volatile) )()
{
    return 0;
}
# 96 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10) volatile) )()
{
    return 0;
}
# 101 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11) volatile) )()
{
    return 0;
}
# 106 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12) volatile) )()
{
    return 0;
}
# 111 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13) volatile) )()
{
    return 0;
}
# 116 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14) volatile) )()
{
    return 0;
}
# 121 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 65 "/usr/local/include/boost/python/detail/target.hpp" 2 3
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 64 "/usr/local/include/boost/python/detail/target.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower2.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper2.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 45 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 3
# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T >
T& (* target(R (T::*)() const volatile) )()
{
    return 0;
}
# 46 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0>
T& (* target(R (T::*)( A0) const volatile) )()
{
    return 0;
}
# 51 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1>
T& (* target(R (T::*)( A0 , A1) const volatile) )()
{
    return 0;
}
# 56 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2>
T& (* target(R (T::*)( A0 , A1 , A2) const volatile) )()
{
    return 0;
}
# 61 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3>
T& (* target(R (T::*)( A0 , A1 , A2 , A3) const volatile) )()
{
    return 0;
}
# 66 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4) const volatile) )()
{
    return 0;
}
# 71 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5) const volatile) )()
{
    return 0;
}
# 76 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6) const volatile) )()
{
    return 0;
}
# 81 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7) const volatile) )()
{
    return 0;
}
# 86 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8) const volatile) )()
{
    return 0;
}
# 91 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9) const volatile) )()
{
    return 0;
}
# 96 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10) const volatile) )()
{
    return 0;
}
# 101 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11) const volatile) )()
{
    return 0;
}
# 106 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12) const volatile) )()
{
    return 0;
}
# 111 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13) const volatile) )()
{
    return 0;
}
# 116 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/target.hpp" 1 3
# 69 "/usr/local/include/boost/python/detail/target.hpp" 3






template <class R, class T , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14>
T& (* target(R (T::*)( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14) const volatile) )()
{
    return 0;
}
# 121 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward2.hpp" 2 3
# 65 "/usr/local/include/boost/python/detail/target.hpp" 2 3
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 31 "/usr/local/include/boost/python/detail/target.hpp" 2 3

template <class R, class T>
T& (* target(R (T::*)) )() { return 0; }

}}}
# 11 "/usr/local/include/boost/python/iterator.hpp" 2 3

# 1 "/usr/local/include/boost/python/object/iterator.hpp" 1 3
# 17 "/usr/local/include/boost/python/object/iterator.hpp" 3
# 1 "/usr/local/include/boost/python/object/iterator_core.hpp" 1 3
# 10 "/usr/local/include/boost/python/object/iterator_core.hpp" 3
namespace boost { namespace python { namespace objects {

 object const& identity_function();
 void stop_iteration_error();

}}}
# 18 "/usr/local/include/boost/python/object/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/class_detail.hpp" 1 3
# 11 "/usr/local/include/boost/python/object/class_detail.hpp" 3
namespace boost { namespace python { namespace objects {

 type_handle registered_class_object(type_info id);
 type_handle class_metatype();
 type_handle class_type();

}}}
# 19 "/usr/local/include/boost/python/object/iterator.hpp" 2 3
# 28 "/usr/local/include/boost/python/object/iterator.hpp" 3
# 1 "/usr/local/include/boost/detail/iterator.hpp" 1 3
# 16 "/usr/local/include/boost/detail/iterator.hpp" 3
namespace boost
{

namespace detail
{

using std::iterator_traits;
using std::distance;
# 35 "/usr/local/include/boost/detail/iterator.hpp" 3
}

}
# 29 "/usr/local/include/boost/python/object/iterator.hpp" 2 3

namespace boost { namespace python { namespace objects {






typedef return_value_policy<return_by_value> default_iterator_call_policies;


template <class NextPolicies, class Iterator>
struct iterator_range
{
    iterator_range(object sequence, Iterator start, Iterator finish);

    typedef boost::detail::iterator_traits<Iterator> traits_t;

    struct next
    {
        typedef typename mpl::if_<
            is_reference<
                typename traits_t::reference
            >
          , typename traits_t::reference
          , typename traits_t::value_type
        >::type result_type;

        result_type
        operator()(iterator_range<NextPolicies,Iterator>& self)
        {
            if (self.m_start == self.m_finish)
                stop_iteration_error();
            return *self.m_start++;
        }





    };

    typedef next next_fn;

    object m_sequence;
    Iterator m_start;
    Iterator m_finish;
};

namespace detail
{



  template <class Iterator, class NextPolicies>
  object demand_iterator_class(char const* name, Iterator* = 0, NextPolicies const& policies = NextPolicies())
  {
      typedef iterator_range<NextPolicies,Iterator> range_;


      handle<> class_obj(
          objects::registered_class_object(python::type_id<range_>()));

      if (class_obj.get() != 0)
          return object(class_obj);

      typedef typename range_::next_fn next_fn;
      typedef typename next_fn::result_type result_type;

      return class_<range_>(name, no_init)
          .def("__iter__", identity_function())
          .def(



              "next"

            , make_function(
                next_fn()
              , policies
              , mpl::vector2<result_type,range_&>()
            ));
  }


  template <
      class Target
    , class Iterator
    , class Accessor1
    , class Accessor2
    , class NextPolicies
  >
  struct py_iter_
  {
      py_iter_(Accessor1 const& get_start, Accessor2 const& get_finish)
        : m_get_start(get_start)
        , m_get_finish(get_finish)
      {}





      iterator_range<NextPolicies,Iterator>
      operator()(back_reference<Target&> x) const
      {

          detail::demand_iterator_class("iterator", (Iterator*)0, NextPolicies());

          return iterator_range<NextPolicies,Iterator>(
              x.source()
            , m_get_start(x.get())
            , m_get_finish(x.get())
          );
      }
   private:
      Accessor1 m_get_start;
      Accessor2 m_get_finish;
  };

  template <class Target, class Iterator, class NextPolicies, class Accessor1, class Accessor2>
  inline object make_iterator_function(
      Accessor1 const& get_start
    , Accessor2 const& get_finish
    , NextPolicies const&
    , Iterator const& (*)()
    , boost::type<Target>*
    , int
  )
  {
      return make_function(
          py_iter_<Target,Iterator,Accessor1,Accessor2,NextPolicies>(get_start, get_finish)
        , default_call_policies()
        , mpl::vector2<iterator_range<NextPolicies,Iterator>, back_reference<Target&> >()
      );
  }

  template <class Target, class Iterator, class NextPolicies, class Accessor1, class Accessor2>
  inline object make_iterator_function(
      Accessor1 const& get_start
    , Accessor2 const& get_finish
    , NextPolicies const& next_policies
    , Iterator& (*)()
    , boost::type<Target>*
    , ...)
  {
      return make_iterator_function(
          get_start
        , get_finish
        , next_policies
        , (Iterator const&(*)())0
        , (boost::type<Target>*)0
        , 0
      );
  }

}







template <class Target, class NextPolicies, class Accessor1, class Accessor2>
inline object make_iterator_function(
    Accessor1 const& get_start
  , Accessor2 const& get_finish
  , NextPolicies const& next_policies
  , boost::type<Target>* = 0
)
{
    typedef typename Accessor1::result_type iterator;
    typedef typename boost::python::detail::add_const<iterator>::type iterator_const;
    typedef typename boost::python::detail::add_lvalue_reference<iterator_const>::type iterator_cref;

    return detail::make_iterator_function(
        get_start
      , get_finish
      , next_policies
      , (iterator_cref(*)())0
      , (boost::type<Target>*)0
      , 0
    );
}




template <class NextPolicies, class Iterator>
inline iterator_range<NextPolicies,Iterator>::iterator_range(
    object sequence, Iterator start, Iterator finish)
    : m_sequence(sequence), m_start(start), m_finish(finish)
{
}

}}}
# 13 "/usr/local/include/boost/python/iterator.hpp" 2 3
# 26 "/usr/local/include/boost/python/iterator.hpp" 3
# 1 "/usr/local/include/boost/bind/protect.hpp" 1 3
# 18 "/usr/local/include/boost/bind/protect.hpp" 3
namespace boost
{

namespace _bi
{

template<class F> class protected_bind_t
{
public:

    typedef typename F::result_type result_type;

    explicit protected_bind_t(F f): f_(f)
    {
    }

    result_type operator()()
    {
        return f_();
    }

    result_type operator()() const
    {
        return f_();
    }

    template<class A1> result_type operator()(A1 & a1)
    {
        return f_(a1);
    }

    template<class A1> result_type operator()(A1 & a1) const
    {
        return f_(a1);
    }





    template<class A1> result_type operator()(const A1 & a1)
    {
        return f_(a1);
    }

    template<class A1> result_type operator()(const A1 & a1) const
    {
        return f_(a1);
    }



    template<class A1, class A2> result_type operator()(A1 & a1, A2 & a2)
    {
        return f_(a1, a2);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 & a2) const
    {
        return f_(a1, a2);
    }




    template<class A1, class A2> result_type operator()(A1 const & a1, A2 & a2)
    {
        return f_(a1, a2);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 & a2) const
    {
        return f_(a1, a2);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 const & a2)
    {
        return f_(a1, a2);
    }

    template<class A1, class A2> result_type operator()(A1 & a1, A2 const & a2) const
    {
        return f_(a1, a2);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 const & a2)
    {
        return f_(a1, a2);
    }

    template<class A1, class A2> result_type operator()(A1 const & a1, A2 const & a2) const
    {
        return f_(a1, a2);
    }



    template<class A1, class A2, class A3> result_type operator()(A1 & a1, A2 & a2, A3 & a3)
    {
        return f_(a1, a2, a3);
    }

    template<class A1, class A2, class A3> result_type operator()(A1 & a1, A2 & a2, A3 & a3) const
    {
        return f_(a1, a2, a3);
    }




    template<class A1, class A2, class A3> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3)
    {
        return f_(a1, a2, a3);
    }

    template<class A1, class A2, class A3> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3) const
    {
        return f_(a1, a2, a3);
    }



    template<class A1, class A2, class A3, class A4> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4)
    {
        return f_(a1, a2, a3, a4);
    }

    template<class A1, class A2, class A3, class A4> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4) const
    {
        return f_(a1, a2, a3, a4);
    }




    template<class A1, class A2, class A3, class A4> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4)
    {
        return f_(a1, a2, a3, a4);
    }

    template<class A1, class A2, class A3, class A4> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4) const
    {
        return f_(a1, a2, a3, a4);
    }



    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5)
    {
        return f_(a1, a2, a3, a4, a5);
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5) const
    {
        return f_(a1, a2, a3, a4, a5);
    }




    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5)
    {
        return f_(a1, a2, a3, a4, a5);
    }

    template<class A1, class A2, class A3, class A4, class A5> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5) const
    {
        return f_(a1, a2, a3, a4, a5);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6)
    {
        return f_(a1, a2, a3, a4, a5, a6);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6) const
    {
        return f_(a1, a2, a3, a4, a5, a6);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6)
    {
        return f_(a1, a2, a3, a4, a5, a6);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6) const
    {
        return f_(a1, a2, a3, a4, a5, a6);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7)
    {
        return f_(a1, a2, a3, a4, a5, a6, a7);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7) const
    {
        return f_(a1, a2, a3, a4, a5, a6, a7);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7)
    {
        return f_(a1, a2, a3, a4, a5, a6, a7);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7) const
    {
        return f_(a1, a2, a3, a4, a5, a6, a7);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8)
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8) const
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8)
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8) const
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8);
    }



    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9)
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 & a1, A2 & a2, A3 & a3, A4 & a4, A5 & a5, A6 & a6, A7 & a7, A8 & a8, A9 & a9) const
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }




    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8, A9 const & a9)
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }

    template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> result_type operator()(A1 const & a1, A2 const & a2, A3 const & a3, A4 const & a4, A5 const & a5, A6 const & a6, A7 const & a7, A8 const & a8, A9 const & a9) const
    {
        return f_(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }



private:

    F f_;
};

}

template<class F> _bi::protected_bind_t<F> protect(F f)
{
    return _bi::protected_bind_t<F>(f);
}

}
# 27 "/usr/local/include/boost/python/iterator.hpp" 2 3

namespace boost { namespace python {

namespace detail
{



  template <class Target, class Accessor1, class Accessor2, class NextPolicies>
  inline object make_iterator(
      Accessor1 get_start
    , Accessor2 get_finish
    , NextPolicies next_policies
    , Target&(*)()
  )
  {
      return objects::make_iterator_function<Target>(
          boost::protect(boost::bind(get_start, _1))
        , boost::protect(boost::bind(get_finish, _1))
        , next_policies
      );
  }


  template <bool const_ = false>
  struct iterators_impl
  {
      template <class T>
      struct apply
      {
          typedef typename T::iterator iterator;
          static iterator begin(T& x) { return x.begin(); }
          static iterator end(T& x) { return x.end(); }
      };
  };

  template <>
  struct iterators_impl<true>
  {
      template <class T>
      struct apply
      {
          typedef typename T::const_iterator iterator;
          static iterator begin(T& x) { return x.begin(); }
          static iterator end(T& x) { return x.end(); }
      };
  };
}



template <class T>
struct iterators
    : detail::iterators_impl<
        detail::is_const<T>::value
      >::template apply<T>
{
};




template <class Accessor1, class Accessor2>
object range(Accessor1 start, Accessor2 finish)
{
    return detail::make_iterator(
        start, finish
      , objects::default_iterator_call_policies()
      , detail::target(start)
    );
}



template <class NextPolicies, class Accessor1, class Accessor2>
object range(Accessor1 start, Accessor2 finish, NextPolicies* = 0)
{
    return detail::make_iterator(start, finish, NextPolicies(), detail::target(start));
}



template <class NextPolicies, class Target, class Accessor1, class Accessor2>
object range(Accessor1 start, Accessor2 finish, NextPolicies* = 0, boost::type<Target>* = 0)
{

    return detail::make_iterator(start, finish, NextPolicies(), (Target&(*)())0);
}





template <class Container
          , class NextPolicies = objects::default_iterator_call_policies>
struct iterator : object
{
    iterator()
        : object(
            python::range<NextPolicies>(
                &iterators<Container>::begin, &iterators<Container>::end
                ))
    {
    }
};

}}
# 38 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/long.hpp" 1 3
# 13 "/usr/local/include/boost/python/long.hpp" 3
namespace boost { namespace python {

namespace detail
{
  struct long_base : object
  {
   protected:
      long_base();
      explicit long_base(object_cref rhs);
      explicit long_base(object_cref rhs, object_cref base);

      inline explicit long_base(::boost::python::detail::borrowed_reference p) : object(p) {} inline explicit long_base(::boost::python::detail::new_reference p) : object(p) {} inline explicit long_base(::boost::python::detail::new_non_null_reference p) : object(p) {}

   private:
      static detail::new_non_null_reference call(object const&);
      static detail::new_non_null_reference call(object const&, object const&);
  };
}

class long_ : public detail::long_base
{
    typedef detail::long_base base;
 public:
    long_() {}

    template <class T>
    explicit long_(T const& rhs)
        : detail::long_base(object(rhs))
    {
    }

    template <class T, class U>
    explicit long_(T const& rhs, U const& base)
        : detail::long_base(object(rhs), object(base))
    {
    }

 public:
    inline explicit long_(::boost::python::detail::borrowed_reference p) : base(p) {} inline explicit long_(::boost::python::detail::new_reference p) : base(p) {} inline explicit long_(::boost::python::detail::new_non_null_reference p) : base(p) {}
};




namespace converter
{
  template <>
  struct object_manager_traits<long_>
      : pytype_object_manager_traits<&PyLong_Type,long_>
  {
  };
}

}}
# 40 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/lvalue_from_pytype.hpp" 1 3
# 18 "/usr/local/include/boost/python/lvalue_from_pytype.hpp" 3
namespace boost { namespace python {

namespace detail
{


  template <class T, class U>
  inline type_info extractor_type_id(T&(*)(U))
  {
      return type_id<T>();
  }





  template <class Extractor, class U>
  struct normalized_extractor
  {
      static inline void* execute(PyObject* op)
      {
          typedef typename add_lvalue_reference<U>::type param;
          return &Extractor::execute(
              boost::python::detail::void_ptr_to_reference(
                  op, (param(*)())0 )
              );
      }
  };






  template <class Extractor, class T, class U>
  inline normalized_extractor<Extractor,U>
  normalize(T(*)(U), Extractor* = 0)
  {
      return normalized_extractor<Extractor, U>();
  }
}



template <class InstanceType, class MemberType, MemberType (InstanceType::*member)>
struct extract_member
{
    static MemberType& execute(InstanceType& c)
    {
        (void)(((PyObject*)(&c))->ob_type);
        return c.*member;
    }
};



template <class InstanceType>
struct extract_identity
{
    static InstanceType& execute(InstanceType& c)
    {
        (void)(((PyObject*)(&c))->ob_type);
        return c;
    }
};




template <class Extractor, PyTypeObject const* python_type>
struct lvalue_from_pytype
{
    lvalue_from_pytype()
    {
        converter::registry::insert
            ( &extract
            , detail::extractor_type_id(&Extractor::execute)

            , &get_pytype

            );
    }
 private:
    static void* extract(PyObject* op)
    {
        return ((((PyObject*)(op))->ob_type) == (const_cast<PyTypeObject*>(python_type)) || PyType_IsSubtype((((PyObject*)(op))->ob_type), (const_cast<PyTypeObject*>(python_type))))
            ? const_cast<void*>(
                static_cast<void const volatile*>(
                    detail::normalize<Extractor>(&Extractor::execute).execute(op)))
            : 0
            ;
    }

    static PyTypeObject const*get_pytype() { return python_type; }

};

}}
# 41 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/make_constructor.hpp" 1 3
# 15 "/usr/local/include/boost/python/make_constructor.hpp" 3
# 1 "/usr/local/include/boost/python/object/make_holder.hpp" 1 3
# 16 "/usr/local/include/boost/python/make_constructor.hpp" 2 3
# 1 "/usr/local/include/boost/python/object/pointer_holder.hpp" 1 3
# 17 "/usr/local/include/boost/python/make_constructor.hpp" 2 3


# 1 "/usr/local/include/boost/python/detail/caller.hpp" 1 3
# 20 "/usr/local/include/boost/python/make_constructor.hpp" 2 3




# 1 "/usr/local/include/boost/mpl/push_front.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/push_front.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/push_front_impl.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/aux_/push_front_impl.hpp" 3
namespace boost { namespace mpl {

struct has_push_front_arg {};




template< typename Tag >
struct push_front_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST45 : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } } mpl_assert_arg45; enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_front_arg >::value ))>( mpl_assert_arg45::assert_arg() ) ) }



             ;
    };
};

template< typename Tag >
struct has_push_front_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_front< Seq, has_push_front_arg > >
    {







    };
};

 template<> struct push_front_impl<non_sequence_tag> {};
 template<> struct has_push_front_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/push_front.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_front
    : push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};


template<
      typename Sequence = na
    >
struct has_push_front
    : has_push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct push_front< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_front< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_front< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_front< na , na > result_; typedef push_front< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_front< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_front< na , na > > : int_<-1> { }; }
template<> struct has_push_front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_front< T1 > { }; }; template< typename Tag > struct lambda< has_push_front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_front< na > result_; typedef has_push_front< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_front< T1 > > : int_<1> { }; template<> struct template_arity< has_push_front< na > > : int_<-1> { }; }

}}
# 25 "/usr/local/include/boost/python/make_constructor.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/pop_front.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/pop_front.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/pop_front_impl.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/pop_front_impl.hpp" 3
namespace boost { namespace mpl {



template< typename Tag >
struct pop_front_impl
{
    template< typename Sequence > struct apply







    ;
};

 template<> struct pop_front_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/pop_front.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct pop_front
    : pop_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct pop_front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pop_front< T1 > { }; }; template< typename Tag > struct lambda< pop_front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef pop_front< na > result_; typedef pop_front< na > type; }; namespace aux { template< typename T1 > struct template_arity< pop_front< T1 > > : int_<1> { }; template<> struct template_arity< pop_front< na > > : int_<-1> { }; }

}}
# 26 "/usr/local/include/boost/python/make_constructor.hpp" 2 3


namespace boost { namespace python {

namespace detail
{
  template <class T>
  struct install_holder : converter::context_result_converter
  {
      install_holder(PyObject* args_)
        : m_self(PyTuple_GetItem(args_, 0)) {}

      PyObject* operator()(T x) const
      {
          dispatch(x, is_pointer<T>());
          return none();
      }

   private:
      template <class U>
      void dispatch(U* x, detail::true_) const
      {




 std::unique_ptr<U> owner(x);
 dispatch(std::move(owner), detail::false_());

      }

      template <class Ptr>
      void dispatch(Ptr x, detail::false_) const
      {
          typedef typename pointee<Ptr>::type value_type;
          typedef objects::pointer_holder<Ptr,value_type> holder;
          typedef objects::instance<holder> instance_t;

          void* memory = holder::allocate(this->m_self, __builtin_offsetof (instance_t, storage), sizeof(holder));
          try {



              (new (memory) holder(std::move(x)))->install(this->m_self);

          }
          catch(...) {
              holder::deallocate(this->m_self, memory);
              throw;
          }
      }

      PyObject* m_self;
  };

  struct constructor_result_converter
  {
      template <class T>
      struct apply
      {
          typedef install_holder<T> type;
      };
  };

  template <class BaseArgs, class Offset>
  struct offset_args
  {
      offset_args(BaseArgs base_) : base(base_) {}
      BaseArgs base;
  };

  template <int N, class BaseArgs, class Offset>
  inline PyObject* get(mpl::int_<N>, offset_args<BaseArgs,Offset> const& args_)
  {
      return get(mpl::int_<(N+Offset::value)>(), args_.base);
  }

  template <class BaseArgs, class Offset>
  inline unsigned arity(offset_args<BaseArgs,Offset> const& args_)
  {
      return arity(args_.base) - Offset::value;
  }

  template <class BasePolicy_ = default_call_policies>
  struct constructor_policy : BasePolicy_
  {
      constructor_policy(BasePolicy_ base) : BasePolicy_(base) {}



      struct MAKE_CONSTRUCTOR_SUPPLIES_ITS_OWN_RESULT_CONVERTER_THAT_WOULD_OVERRIDE_YOURS; typedef struct MAKE_CONSTRUCTOR_SUPPLIES_ITS_OWN_RESULT_CONVERTER_THAT_WOULD_OVERRIDE_YOURS123 : boost::mpl::assert_ { static boost::mpl::failed ************ (MAKE_CONSTRUCTOR_SUPPLIES_ITS_OWN_RESULT_CONVERTER_THAT_WOULD_OVERRIDE_YOURS::************ assert_arg()) (typename BasePolicy_::result_converter) { return 0; } } mpl_assert_arg123; enum { mpl_assertion_in_line_123 = sizeof( boost::mpl::assertion_failed<((is_same< typename BasePolicy_::result_converter , default_result_converter >::value))>( mpl_assert_arg123::assert_arg() ) ) }






       ;
      typedef constructor_result_converter result_converter;
      typedef offset_args<typename BasePolicy_::argument_package, mpl::int_<1> > argument_package;
  };

  template <class InnerSignature>
  struct outer_constructor_signature
  {
      typedef typename mpl::pop_front<InnerSignature>::type inner_args;
      typedef typename mpl::push_front<inner_args,object>::type outer_args;
      typedef typename mpl::push_front<outer_args,void>::type type;
  };


  template <>
  struct outer_constructor_signature<int>
  {
      typedef int type;
  };
# 150 "/usr/local/include/boost/python/make_constructor.hpp" 3
  template <class F, class CallPolicies, class Sig>
  object make_constructor_aux(
      F f
    , CallPolicies const& p
    , Sig const&
  )
  {
      typedef typename outer_constructor_signature<Sig>::type outer_signature;

      typedef constructor_policy<CallPolicies> inner_policy;

      return objects::function_object(
          objects::py_function(
              detail::caller<F,inner_policy,Sig>(f, inner_policy(p))
            , outer_signature()
          )
      );
  }





  template <class F, class CallPolicies, class Sig, class NumKeywords>
  object make_constructor_aux(
      F f
      , CallPolicies const& p
      , Sig const&
      , detail::keyword_range const& kw
      , NumKeywords
      )
  {
      enum { arity = mpl::size<Sig>::value - 1 };

      typedef typename detail::error::more_keywords_than_function_arguments<
          NumKeywords::value, arity
          >::too_many_keywords assertion __attribute__((__unused__));

      typedef typename outer_constructor_signature<Sig>::type outer_signature;

      typedef constructor_policy<CallPolicies> inner_policy;

      return objects::function_object(
          objects::py_function(
              detail::caller<F,inner_policy,Sig>(f, inner_policy(p))
            , outer_signature()
          )
          , kw
      );
  }
# 209 "/usr/local/include/boost/python/make_constructor.hpp" 3
  template <class F, class CallPolicies, class Keywords>
  object make_constructor_dispatch(F f, CallPolicies const& policies, Keywords const& kw, mpl::true_)
  {
      return detail::make_constructor_aux(
          f
        , policies
        , detail::get_signature(f)
        , kw.range()
        , mpl::int_<Keywords::size>()
      );
  }

  template <class F, class CallPolicies, class Signature>
  object make_constructor_dispatch(F f, CallPolicies const& policies, Signature const& sig, mpl::false_)
  {
      return detail::make_constructor_aux(
          f
        , policies
        , sig
      );
  }

}





template <class F>
object make_constructor(F f)
{
    return detail::make_constructor_aux(
        f,default_call_policies(), detail::get_signature(f));
}

template <class F, class CallPolicies>
object make_constructor(F f, CallPolicies const& policies)
{
    return detail::make_constructor_aux(
        f, policies, detail::get_signature(f));
}

template <class F, class CallPolicies, class KeywordsOrSignature>
object make_constructor(
    F f
  , CallPolicies const& policies
  , KeywordsOrSignature const& keywords_or_signature)
{
    typedef typename
        detail::is_reference_to_keywords<KeywordsOrSignature&>::type
        is_kw;

    return detail::make_constructor_dispatch(
        f
      , policies
      , keywords_or_signature
      , is_kw()
    );
}

template <class F, class CallPolicies, class Keywords, class Signature>
object make_constructor(
    F f
  , CallPolicies const& policies
  , Keywords const& kw
  , Signature const& sig
 )
{
    return detail::make_constructor_aux(
          f
        , policies
        , sig
        , kw.range()
        , mpl::int_<Keywords::size>()
      );
}


}}
# 42 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/manage_new_object.hpp" 1 3
# 14 "/usr/local/include/boost/python/manage_new_object.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <class R>
  struct manage_new_object_requires_a_pointer_return_type

  {}

  ;
}

struct manage_new_object
{
    template <class T>
    struct apply
    {
        typedef typename mpl::if_c<
            detail::is_pointer<T>::value
            , to_python_indirect<T, detail::make_owning_holder>
            , detail::manage_new_object_requires_a_pointer_return_type<T>
        >::type type;
    };
};

}}
# 44 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/module.hpp" 1 3
# 10 "/usr/local/include/boost/python/module.hpp" 3
# 1 "/usr/local/include/boost/python/module_init.hpp" 1 3
# 14 "/usr/local/include/boost/python/module_init.hpp" 3
namespace boost { namespace python { namespace detail {







 PyObject* init_module(char const* name, void(*)());



}}}
# 11 "/usr/local/include/boost/python/module.hpp" 2 3
# 45 "/usr/local/include/boost/python.hpp" 2 3



# 1 "/usr/local/include/boost/python/opaque_pointer_converter.hpp" 1 3
# 15 "/usr/local/include/boost/python/opaque_pointer_converter.hpp" 3
# 1 "/usr/local/include/boost/python/detail/dealloc.hpp" 1 3







namespace boost { namespace python { namespace detail {
    extern "C"
    {
        inline void dealloc(PyObject* self)
        {
          PyObject_Free(self);
        }
    }
}}}
# 16 "/usr/local/include/boost/python/opaque_pointer_converter.hpp" 2 3
# 38 "/usr/local/include/boost/python/opaque_pointer_converter.hpp" 3
namespace boost { namespace python {

template <class Pointee>
struct opaque
{
    opaque()
    {
        if (type_object.tp_name == 0)
        {
            type_object.tp_name = const_cast<char*>(type_id<Pointee*>().name());
            if (PyType_Ready (&type_object) < 0)
            {
                throw error_already_set();
            }

            this->register_self();
        }
    }

    static opaque instance;
private:

    static void* extract(PyObject* op)
    {
        return ((((PyObject*)(op))->ob_type) == (&type_object) || PyType_IsSubtype((((PyObject*)(op))->ob_type), (&type_object)))
            ? static_cast<python_instance*>(implicit_cast<void*>(op))->x
            : 0
            ;
    }

    static PyObject* wrap(void const* px)
    {
        Pointee* x = *static_cast<Pointee*const*>(px);

        if (x == 0)
            return detail::none();

        if ( python_instance *o = ( (python_instance *) _PyObject_New(&type_object) ) )
        {
            o->x = x;
            return static_cast<PyObject*>(implicit_cast<void*>(o));
        }
        else
        {
            throw error_already_set();
        }
    }

    void register_self()
    {
        converter::registration const *existing =
            converter::registry::query (type_id<Pointee*>());

        if ((existing == 0) || (existing->m_to_python == 0))
        {

            converter::registry::insert(&extract, type_id<Pointee>(), &get_pytype);
            converter::registry::insert(&wrap, type_id<Pointee*>(), &get_pytype);




        }
    }

    struct python_instance
    {
        Py_ssize_t ob_refcnt; struct _typeobject *ob_type;
        Pointee* x;
    };

    static PyTypeObject type_object;

    static PyTypeObject const *get_pytype(){return &type_object; }

};

template <class Pointee>
opaque<Pointee> opaque<Pointee>::instance;

template <class Pointee>
PyTypeObject opaque<Pointee>::type_object =
{
    1, __null, 0,
    0,
    sizeof( typename opaque<Pointee>::python_instance ),
    0,
    ::boost::python::detail::dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,

    0

};
}}
# 49 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/operators.hpp" 1 3
# 17 "/usr/local/include/boost/python/operators.hpp" 3
# 1 "/usr/local/include/boost/python/self.hpp" 1 3
# 10 "/usr/local/include/boost/python/self.hpp" 3
namespace boost { namespace python {







namespace self_ns
{



  struct self_t {};
  extern self_t self;

}

using self_ns::self_t;
using self_ns::self;

}}
# 18 "/usr/local/include/boost/python/operators.hpp" 2 3
# 1 "/usr/local/include/boost/python/other.hpp" 1 3
# 12 "/usr/local/include/boost/python/other.hpp" 3
namespace boost { namespace python {

template<class T> struct other
{
    typedef T type;
};

namespace detail
{
  template<typename T>
  class is_other
  {
   public:
      static const bool value = false;
  };

  template<typename T>
  class is_other<other<T> >
  {
   public:
      static const bool value = true;
  };

  template<typename T>
  class unwrap_other
  {
   public:
      typedef T type;
  };

  template<typename T>
  class unwrap_other<other<T> >
  {
   public:
      typedef T type;
  };
}

}}
# 19 "/usr/local/include/boost/python/operators.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast.hpp" 3
          






# 1 "/usr/local/include/boost/range/iterator_range_core.hpp" 1 3
# 25 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 26 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3
# 1 "/usr/local/include/boost/iterator/iterator_traits.hpp" 1 3
# 12 "/usr/local/include/boost/iterator/iterator_traits.hpp" 3
namespace boost {
namespace iterators {






template <class Iterator>
struct iterator_value
{
    typedef typename std::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename std::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename std::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename std::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename std::iterator_traits<Iterator>::iterator_category type;
};

}

using iterators::iterator_value;
using iterators::iterator_reference;
using iterators::iterator_pointer;
using iterators::iterator_difference;
using iterators::iterator_category;

}
# 27 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3
# 1 "/usr/local/include/boost/iterator/iterator_facade.hpp" 1 3
# 11 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/usr/local/include/boost/iterator/interoperable.hpp" 1 3
# 15 "/usr/local/include/boost/iterator/interoperable.hpp" 3
# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 16 "/usr/local/include/boost/iterator/interoperable.hpp" 2 3

namespace boost {
namespace iterators {
# 34 "/usr/local/include/boost/iterator/interoperable.hpp" 3
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

using iterators::is_interoperable;

}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 53 "/usr/local/include/boost/iterator/interoperable.hpp" 2 3
# 12 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3

# 1 "/usr/local/include/boost/iterator/iterator_categories.hpp" 1 3
# 10 "/usr/local/include/boost/iterator/iterator_categories.hpp" 3
# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 11 "/usr/local/include/boost/iterator/iterator_categories.hpp" 2 3





# 1 "/usr/local/include/boost/mpl/placeholders.hpp" 1 3
# 17 "/usr/local/include/boost/iterator/iterator_categories.hpp" 2 3
# 25 "/usr/local/include/boost/iterator/iterator_categories.hpp" 3
namespace boost {
namespace iterators {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};

}




template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::iterators::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename std::iterator_traits<Iterator>::iterator_category
    >
{};
# 146 "/usr/local/include/boost/iterator/iterator_categories.hpp" 3
template <class Traversal>
struct pure_traversal_tag
  : mpl::eval_if<
        is_convertible<Traversal,random_access_traversal_tag>
      , mpl::identity<random_access_traversal_tag>
      , mpl::eval_if<
            is_convertible<Traversal,bidirectional_traversal_tag>
          , mpl::identity<bidirectional_traversal_tag>
          , mpl::eval_if<
                is_convertible<Traversal,forward_traversal_tag>
              , mpl::identity<forward_traversal_tag>
              , mpl::eval_if<
                    is_convertible<Traversal,single_pass_traversal_tag>
                  , mpl::identity<single_pass_traversal_tag>
                  , mpl::eval_if<
                        is_convertible<Traversal,incrementable_traversal_tag>
                      , mpl::identity<incrementable_traversal_tag>
                      , void
                    >
                >
            >
        >
    >
{
};




template <class Iterator = mpl::_1>
struct pure_iterator_traversal
  : pure_traversal_tag<typename iterator_traversal<Iterator>::type>
{};
# 194 "/usr/local/include/boost/iterator/iterator_categories.hpp" 3
}

using iterators::no_traversal_tag;
using iterators::incrementable_traversal_tag;
using iterators::single_pass_traversal_tag;
using iterators::forward_traversal_tag;
using iterators::bidirectional_traversal_tag;
using iterators::random_access_traversal_tag;
using iterators::iterator_category_to_traversal;
using iterators::iterator_traversal;




namespace detail {
using iterators::pure_traversal_tag;
}

}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 215 "/usr/local/include/boost/iterator/iterator_categories.hpp" 2 3
# 14 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3

# 1 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 1 3






# 1 "/usr/local/include/boost/core/use_default.hpp" 1 3
# 11 "/usr/local/include/boost/core/use_default.hpp" 3
namespace boost {

struct use_default { };

}
# 8 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 25 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 3
# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 26 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 35 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 3
namespace boost {
namespace iterators {

using boost::use_default;

namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
# 84 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 3
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{



    enum { mpl_assertion_in_line_146 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) }



             ;

    enum { mpl_assertion_in_line_148 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_150 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };

    enum { mpl_assertion_in_line_152 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };

};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{
    enum { mpl_assertion_in_line_161 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };

    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 193 "/usr/local/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 16 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3
# 35 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/usr/local/include/boost/mpl/always.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/always.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessor/default_params.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/always.hpp" 2 3



namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
        typename T1 = na , typename T2 = na , typename T3 = na , typename T4 = na , typename T5 = na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}
# 36 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 37 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3




# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 42 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3

namespace boost {
namespace iterators {



  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };


    template< typename CategoryOrTraversal, typename Required >
    struct is_traversal_at_least :
        public boost::is_convertible< typename iterator_category_to_traversal< CategoryOrTraversal >::type, Required >
    {};




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable :
        public boost::iterators::enable_if<
            is_interoperable< Facade1, Facade2 >
          , Return
        >
    {};




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable_and_random_access_traversal :
        public boost::iterators::enable_if<
            mpl::and_<
                is_interoperable< Facade1, Facade2 >
              , is_traversal_at_least< typename iterator_category< Facade1 >::type, random_access_traversal_tag >
              , is_traversal_at_least< typename iterator_category< Facade2 >::type, random_access_traversal_tag >
            >
          , Return
        >
    {};





    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;


        typedef typename mpl::eval_if<
            boost::iterators::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
# 145 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
# 259 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
# 284 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<
                    Reference





                  , typename add_lvalue_reference<Value const>::type
                >



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class Reference, class Pointer>
    struct operator_arrow_dispatch
    {
        struct proxy
        {
            explicit proxy(Reference const & x) : m_ref(x) {}
            Reference* operator->() { return boost::addressof(m_ref); }


            operator Reference*() { return boost::addressof(m_ref); }
            Reference m_ref;
        };
        typedef proxy result_type;
        static result_type apply(Reference const & x)
        {
            return result_type(x);
        }
    };

    template <class T, class Pointer>
    struct operator_arrow_dispatch<T&, Pointer>
    {
        typedef Pointer result_type;
        static result_type apply(T& x)
        {
            return boost::addressof(x);
        }
    };




    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :



          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };

    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
      , bool IsBidirectionalTraversal
      , bool IsRandomAccessTraversal
    >
    class iterator_facade_base;

  }
# 497 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
  class iterator_core_access
  {






      template <class I, class V, class TC, class R, class D> friend class iterator_facade;
      template <class I, class V, class TC, class R, class D, bool IsBidirectionalTraversal, bool IsRandomAccessTraversal>
      friend class detail::iterator_facade_base;




      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);






      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);



      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }


      iterator_core_access() = delete;
  };

  namespace detail {


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >






    {
    private:
        typedef boost::iterators::detail::iterator_facade_types<
            Value, CategoryOrTraversal, Reference, Difference
        > associated_types;

        typedef boost::iterators::detail::operator_arrow_dispatch<
            Reference
          , typename associated_types::pointer
        > operator_arrow_dispatch_;

    public:
        typedef typename associated_types::value_type value_type;
        typedef Reference reference;
        typedef Difference difference_type;

        typedef typename operator_arrow_dispatch_::result_type pointer;

        typedef typename associated_types::iterator_category iterator_category;

    public:
        reference operator*() const
        {
            return iterator_core_access::dereference(this->derived());
        }

        pointer operator->() const
        {
            return operator_arrow_dispatch_::apply(*this->derived());
        }

        Derived& operator++()
        {
            iterator_core_access::increment(this->derived());
            return this->derived();
        }

    protected:



        Derived& derived()
        {
            return *static_cast<Derived*>(this);
        }

        Derived const& derived() const
        {
            return *static_cast<Derived const*>(this);
        }
    };


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > :
        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >
    {
    public:
        Derived& operator--()
        {
            iterator_core_access::decrement(this->derived());
            return this->derived();
        }

        Derived operator--(int)
        {
            Derived tmp(this->derived());
            --*this;
            return tmp;
        }
    };


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, true > :
        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false >
    {
    private:
        typedef iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > base_type;

    public:
        typedef typename base_type::reference reference;
        typedef typename base_type::difference_type difference_type;

    public:
        typename boost::iterators::detail::operator_brackets_result<Derived, Value, reference>::type
        operator[](difference_type n) const
        {
            typedef boost::iterators::detail::use_operator_brackets_proxy<Value, Reference> use_proxy;

            return boost::iterators::detail::make_operator_brackets_result<Derived>(
                this->derived() + n
              , use_proxy()
            );
        }

        Derived& operator+=(difference_type n)
        {
            iterator_core_access::advance(this->derived(), n);
            return this->derived();
        }

        Derived& operator-=(difference_type n)
        {
            iterator_core_access::advance(this->derived(), -n);
            return this->derived();
        }

        Derived operator-(difference_type x) const
        {
            Derived result(this->derived());
            return result -= x;
        }
    };

  }





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade :
      public detail::iterator_facade_base<
          Derived,
          Value,
          CategoryOrTraversal,
          Reference,
          Difference,
          detail::is_traversal_at_least< CategoryOrTraversal, bidirectional_traversal_tag >::value,
          detail::is_traversal_at_least< CategoryOrTraversal, random_access_traversal_tag >::value
      >
  {
  protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;
  };

  template <class I, class V, class TC, class R, class D>
  inline typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
# 900 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 930 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }




  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 955 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
  template <class Derived, class V, class TC, class R, class D> inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




  template <class Derived, class V, class TC, class R, class D> inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }
# 972 "/usr/local/include/boost/iterator/iterator_facade.hpp" 3
}

using iterators::iterator_core_access;
using iterators::iterator_facade;

}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 980 "/usr/local/include/boost/iterator/iterator_facade.hpp" 2 3
# 28 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3
# 38 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
# 1 "/usr/local/include/boost/range/functions.hpp" 1 3
# 18 "/usr/local/include/boost/range/functions.hpp" 3
# 1 "/usr/local/include/boost/range/begin.hpp" 1 3
# 18 "/usr/local/include/boost/range/begin.hpp" 3
# 1 "/usr/local/include/boost/range/config.hpp" 1 3
# 19 "/usr/local/include/boost/range/begin.hpp" 2 3





# 1 "/usr/local/include/boost/range/iterator.hpp" 1 3
# 19 "/usr/local/include/boost/range/iterator.hpp" 3
# 1 "/usr/local/include/boost/range/range_fwd.hpp" 1 3
# 13 "/usr/local/include/boost/range/range_fwd.hpp" 3
namespace boost
{


    template<typename C, typename Enabler>
    struct range_iterator;

    template<typename C, typename Enabler>
    struct range_mutable_iterator;

    template<typename C, typename Enabler>
    struct range_const_iterator;


    template<typename IteratorT>
    class iterator_range;

    template<typename ForwardRange>
    class sub_range;


    template<typename T>
    struct range_category;

    template<typename T>
    struct range_difference;

    template<typename T>
    struct range_pointer;

    template<typename T>
    struct range_reference;

    template<typename T>
    struct range_reverse_iterator;

    template<typename T>
    struct range_size;

    template<typename T>
    struct range_value;

    template<typename T>
    struct has_range_iterator;

    template<typename T>
    struct has_range_const_iterator;

}
# 20 "/usr/local/include/boost/range/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/range/mutable_iterator.hpp" 1 3
# 21 "/usr/local/include/boost/range/mutable_iterator.hpp" 3
# 1 "/usr/local/include/boost/range/detail/extract_optional_type.hpp" 1 3
# 22 "/usr/local/include/boost/range/mutable_iterator.hpp" 2 3





namespace boost
{





    namespace range_detail
    {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; }; template< typename C, bool B = has_iterator<C>::value > struct extract_iterator {}; template< typename C > struct extract_iterator< C, true > { typedef typename C::iterator type; };

template< typename C >
struct range_mutable_iterator
        : range_detail::extract_iterator<
            typename remove_reference<C>::type>
{};





template< typename Iterator >
struct range_mutable_iterator< std::pair<Iterator,Iterator> >
{
    typedef Iterator type;
};





template< typename T, std::size_t sz >
struct range_mutable_iterator< T[sz] >
{
    typedef T* type;
};

    }

template<typename C, typename Enabler=void>
struct range_mutable_iterator
        : range_detail::range_mutable_iterator<
            typename remove_reference<C>::type
        >
{
};

}

# 1 "/usr/local/include/boost/range/detail/msvc_has_iterator_workaround.hpp" 1 3
# 78 "/usr/local/include/boost/range/mutable_iterator.hpp" 2 3
# 21 "/usr/local/include/boost/range/iterator.hpp" 2 3
# 1 "/usr/local/include/boost/range/const_iterator.hpp" 1 3
# 27 "/usr/local/include/boost/range/const_iterator.hpp" 3
namespace boost
{




    namespace range_detail
    {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_const_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::const_iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; }; template< typename C, bool B = has_const_iterator<C>::value > struct extract_const_iterator {}; template< typename C > struct extract_const_iterator< C, true > { typedef typename C::const_iterator type; };

template< typename C >
struct range_const_iterator_helper
        : extract_const_iterator<C>
{};





template< typename Iterator >
struct range_const_iterator_helper<std::pair<Iterator,Iterator> >
{
    typedef Iterator type;
};





template< typename T, std::size_t sz >
struct range_const_iterator_helper< T[sz] >
{
    typedef const T* type;
};

    }

template<typename C, typename Enabler=void>
struct range_const_iterator
        : range_detail::range_const_iterator_helper<
            typename remove_reference<C>::type
        >
{
};

}
# 22 "/usr/local/include/boost/range/iterator.hpp" 2 3




namespace boost
{
# 60 "/usr/local/include/boost/range/iterator.hpp" 3
    template< typename C, typename Enabler=void >
    struct range_iterator
      : mpl::if_c<
            is_const<typename remove_reference<C>::type>::value,
            range_const_iterator<typename remove_const<typename remove_reference<C>::type>::type>,
            range_mutable_iterator<typename remove_reference<C>::type>
        >::type
    {
    };



}
# 25 "/usr/local/include/boost/range/begin.hpp" 2 3



namespace boost
{


namespace range_detail
{






    template< typename C >
    constexpr inline typename range_iterator<C>::type
    range_begin( C& c )
    {





        return c.begin();
    }





    template< typename Iterator >
    constexpr inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }

    template< typename Iterator >
    constexpr inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
# 75 "/usr/local/include/boost/range/begin.hpp" 3
    template< typename T, std::size_t sz >
    constexpr inline const T* range_begin( const T (&a)[sz] ) noexcept
    {
        return a;
    }

    template< typename T, std::size_t sz >
    constexpr inline T* range_begin( T (&a)[sz] ) noexcept
    {
        return a;
    }



}





namespace range_adl_barrier
{

template< class T >

constexpr

inline typename range_iterator<T>::type begin( T& r )
{

    using namespace range_detail;

    return range_begin( r );
}

template< class T >

constexpr

inline typename range_iterator<const T>::type begin( const T& r )
{

    using namespace range_detail;

    return range_begin( r );
}

    }
}



namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        inline typename range_iterator<const T>::type
        const_begin( const T& r )
        {
            return boost::range_adl_barrier::begin( r );
        }
    }

    using namespace range_adl_barrier;
}
# 19 "/usr/local/include/boost/range/functions.hpp" 2 3
# 1 "/usr/local/include/boost/range/end.hpp" 1 3
# 24 "/usr/local/include/boost/range/end.hpp" 3
# 1 "/usr/local/include/boost/range/detail/implementation_help.hpp" 1 3
# 15 "/usr/local/include/boost/range/detail/implementation_help.hpp" 3
# 1 "/usr/local/include/boost/range/detail/common.hpp" 1 3
# 19 "/usr/local/include/boost/range/detail/common.hpp" 3
# 1 "/usr/local/include/boost/range/detail/sfinae.hpp" 1 3
# 20 "/usr/local/include/boost/range/detail/sfinae.hpp" 3
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;





        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );

        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );

        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );

        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );

        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );

        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );

        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );





        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );





        struct char_or_wchar_t_array_tag {};

    }

}
# 20 "/usr/local/include/boost/range/detail/common.hpp" 2 3
# 29 "/usr/local/include/boost/range/detail/common.hpp" 3
namespace boost
{
    namespace range_detail
    {
# 46 "/usr/local/include/boost/range/detail/common.hpp" 3
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;

        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;

            static const bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            static const bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_string_ = (is_const_char_ptr_ || is_const_wchar_t_ptr_);
            static const bool is_array_ = boost::is_array<C>::value;

        };

        template< typename C >
        class range
        {
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef typename boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}
# 16 "/usr/local/include/boost/range/detail/implementation_help.hpp" 2 3
# 24 "/usr/local/include/boost/range/detail/implementation_help.hpp" 3
namespace boost
{
    namespace range_detail
    {
        template <typename T>
        inline void boost_range_silence_warning( const T& ) { }





        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }


        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            return s + wcslen( s );
        }
# 56 "/usr/local/include/boost/range/detail/implementation_help.hpp" 3
        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }

        template< class T, std::size_t sz >
        constexpr inline T* array_end( T (&boost_range_array)[sz] ) noexcept
        {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        constexpr inline const T* array_end( const T (&boost_range_array)[sz] ) noexcept
        {
            return boost_range_array + sz;
        }





        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        inline bool is_same_address(const void* l, const void* r)
        {
            return l == r;
        }

        template<class T1, class T2>
        inline bool is_same_object(const T1& l, const T2& r)
        {
            return range_detail::is_same_address(&l, &r);
        }

    }

}
# 25 "/usr/local/include/boost/range/end.hpp" 2 3





namespace boost
{


namespace range_detail
{





        template< typename C >
        constexpr inline typename range_iterator<C>::type
        range_end( C& c )
        {





            return c.end();
        }





        template< typename Iterator >
        constexpr inline Iterator range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }

        template< typename Iterator >
        constexpr inline Iterator range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }





        template< typename T, std::size_t sz >
        constexpr inline const T* range_end( const T (&a)[sz] ) noexcept
        {
            return range_detail::array_end<T,sz>( a );
        }

        template< typename T, std::size_t sz >
        constexpr inline T* range_end( T (&a)[sz] ) noexcept
        {
            return range_detail::array_end<T,sz>( a );
        }


}


namespace range_adl_barrier
{

template< class T >

constexpr

inline typename range_iterator<T>::type end( T& r )
{

    using namespace range_detail;

    return range_end( r );
}

template< class T >

constexpr

inline typename range_iterator<const T>::type end( const T& r )
{

    using namespace range_detail;

    return range_end( r );
}

    }
}



namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        constexpr inline typename range_iterator<const T>::type
        const_end( const T& r )
        {
            return boost::range_adl_barrier::end( r );
        }
    }
    using namespace range_adl_barrier;
}
# 20 "/usr/local/include/boost/range/functions.hpp" 2 3
# 1 "/usr/local/include/boost/range/size.hpp" 1 3
# 21 "/usr/local/include/boost/range/size.hpp" 3
# 1 "/usr/local/include/boost/range/size_type.hpp" 1 3
# 19 "/usr/local/include/boost/range/size_type.hpp" 3
# 1 "/usr/local/include/boost/range/difference_type.hpp" 1 3
# 21 "/usr/local/include/boost/range/difference_type.hpp" 3
# 1 "/usr/local/include/boost/range/has_range_iterator.hpp" 1 3
# 21 "/usr/local/include/boost/range/has_range_iterator.hpp" 3
# 1 "/usr/local/include/boost/utility/enable_if.hpp" 1 3
# 22 "/usr/local/include/boost/range/has_range_iterator.hpp" 2 3

namespace boost
{
    namespace range_detail
    {
        template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };

        template<class T, class Enabler = void>
        struct has_range_iterator_impl
            : boost::mpl::false_
        {
        };

        template<class T>
        struct has_range_iterator_impl<
            T,
            typename ::boost::enable_if<
                typename mpl::eval_if<is_const<T>,
                    has_type<boost::range_const_iterator<
                                typename remove_const<T>::type> >,
                    has_type<boost::range_mutable_iterator<T> >
                >::type
            >::type
        >
            : boost::mpl::true_
        {
        };

        template<class T, class Enabler = void>
        struct has_range_const_iterator_impl
            : boost::mpl::false_
        {
        };

        template<class T>
        struct has_range_const_iterator_impl<
            T,
            typename ::boost::enable_if<
                has_type<boost::range_const_iterator<T> >
            >::type
        >
            : boost::mpl::true_
        {
        };

    }

    template<class T>
    struct has_range_iterator
        : range_detail::has_range_iterator_impl<
            typename remove_reference<T>::type>
    {};

    template<class T>
    struct has_range_const_iterator
        : range_detail::has_range_const_iterator_impl<
            typename remove_reference<T>::type>
    {};
}
# 22 "/usr/local/include/boost/range/difference_type.hpp" 2 3



namespace boost
{
    namespace range_detail
    {
        template< class T, bool B = has_type<range_iterator<T> >::value >
        struct range_difference
        { };

        template< class T >
        struct range_difference<T, true>
          : iterator_difference<
                typename range_iterator<T>::type
            >
        { };
    }

    template< class T >
    struct range_difference
      : range_detail::range_difference<typename remove_reference<T>::type>
    { };
}
# 20 "/usr/local/include/boost/range/size_type.hpp" 2 3
# 1 "/usr/local/include/boost/range/concepts.hpp" 1 3
# 19 "/usr/local/include/boost/range/concepts.hpp" 3
# 1 "/usr/local/include/boost/concept_check.hpp" 1 3
# 20 "/usr/local/include/boost/concept_check.hpp" 3
# 1 "/usr/local/include/boost/concept/assert.hpp" 1 3
# 35 "/usr/local/include/boost/concept/assert.hpp" 3
# 1 "/usr/local/include/boost/concept/detail/general.hpp" 1 3
# 9 "/usr/local/include/boost/concept/detail/general.hpp" 3
# 1 "/usr/local/include/boost/concept/detail/backward_compatibility.hpp" 1 3






namespace boost
{
  namespace concepts {}




}
# 10 "/usr/local/include/boost/concept/detail/general.hpp" 2 3


# 1 "/usr/local/include/boost/concept/detail/has_constraints.hpp" 1 3
# 11 "/usr/local/include/boost/concept/detail/has_constraints.hpp" 3
namespace boost { namespace concepts {

namespace detail
{



  typedef char yes;
  typedef char (&no)[2];

  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
# 31 "/usr/local/include/boost/concept/detail/has_constraints.hpp" 3
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);

}



template <class Model>
struct not_satisfied
{
    static const bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes)

                                                                                      ;
    typedef boost::integral_constant<bool, value> type;
};

}}
# 13 "/usr/local/include/boost/concept/detail/general.hpp" 2 3





namespace boost { namespace concepts {

template <class ModelFn>
struct requirement_;

namespace detail
{
  template <void(*)()> struct instantiate {};
}

template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};

struct failed {};

template <class Model>
struct requirement<failed ************ Model::************>
{
    static void failed() { ((Model*)0)->~Model(); }
};



template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};

template <class Model>
struct requirement_<void(*)(Model)>
  : boost::conditional<
        concepts::not_satisfied<Model>::value
      , constraint<Model>
      , requirement<failed ************ Model::************>
    >::type
{};
# 75 "/usr/local/include/boost/concept/detail/general.hpp" 3
}}
# 36 "/usr/local/include/boost/concept/assert.hpp" 2 3
# 21 "/usr/local/include/boost/concept_check.hpp" 2 3


# 1 "/usr/local/include/boost/type_traits/conversion_traits.hpp" 1 3
# 24 "/usr/local/include/boost/concept_check.hpp" 2 3







# 1 "/usr/local/include/boost/concept/usage.hpp" 1 3
# 11 "/usr/local/include/boost/concept/usage.hpp" 3
namespace boost { namespace concepts {

template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
# 34 "/usr/local/include/boost/concept/usage.hpp" 3
}}
# 32 "/usr/local/include/boost/concept_check.hpp" 2 3
# 1 "/usr/local/include/boost/concept/detail/concept_def.hpp" 1 3





# 1 "/usr/local/include/boost/preprocessor/seq/for_each_i.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/seq/for_each_i.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/for.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/repetition/for.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 22 "/usr/local/include/boost/preprocessor/repetition/for.hpp" 2 3
# 44 "/usr/local/include/boost/preprocessor/repetition/for.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/detail/for.hpp" 1 3
# 45 "/usr/local/include/boost/preprocessor/repetition/for.hpp" 2 3
# 21 "/usr/local/include/boost/preprocessor/seq/for_each_i.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/seq/seq.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/seq/seq.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/seq/elem.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/seq/seq.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/seq/for_each_i.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/seq/size.hpp" 1 3
# 23 "/usr/local/include/boost/preprocessor/seq/for_each_i.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/seq/detail/is_empty.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/seq/for_each_i.hpp" 2 3
# 7 "/usr/local/include/boost/concept/detail/concept_def.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/seq/enum.hpp" 1 3
# 8 "/usr/local/include/boost/concept/detail/concept_def.hpp" 2 3
# 33 "/usr/local/include/boost/concept_check.hpp" 2 3







namespace boost
{





  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Model)>::failed> boost_concept_check50 __attribute__((__unused__));
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
# 70 "/usr/local/include/boost/concept_check.hpp" 3
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check72 __attribute__((__unused__)); ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };

  template <> struct Integer<char> {};
  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};

  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};





  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check98 __attribute__((__unused__)); ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};

  template <> struct SignedInteger< ::boost::long_long_type> {};




  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check115 __attribute__((__unused__)); ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };

  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};

  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};







  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check137 __attribute__((__unused__)); ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };

  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check145 __attribute__((__unused__)); ~Assignable() {

      a = b;

      const_constraints(b);
    }
   private:
    void const_constraints(const TT& x) {

      a = x;



    }
   private:
    TT a;
    TT b;
  };


  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check167 __attribute__((__unused__)); ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };


  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check186 __attribute__((__unused__)); ~SGIAssignable() {
      TT c(a);

      a = b;

      const_constraints(b);
      ignore_unused_variable_warning(c);
    }
   private:
    void const_constraints(const TT& x) {
      TT c(x);

      a = x;

      ignore_unused_variable_warning(c);
    }
    TT a;
    TT b;
  };

  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check208 __attribute__((__unused__)); ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
# 225 "/usr/local/include/boost/concept_check.hpp" 3
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }

  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check233 __attribute__((__unused__)); ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };

  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check243 __attribute__((__unused__)); ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };


  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check253 __attribute__((__unused__)); ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
# 283 "/usr/local/include/boost/concept_check.hpp" 3
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check283 __attribute__((__unused__)); ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check284 __attribute__((__unused__)); ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check285 __attribute__((__unused__)); ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check286 __attribute__((__unused__)); ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check287 __attribute__((__unused__)); ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check288 __attribute__((__unused__)); ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };

  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check290 __attribute__((__unused__)); ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check291 __attribute__((__unused__)); ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check292 __attribute__((__unused__)); ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check293 __attribute__((__unused__)); ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check294 __attribute__((__unused__)); ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };




  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check301 __attribute__((__unused__)); ~Generator() { test(is_void<Return>()); }

   private:
      void test(boost::false_type)
      {

          const Return& r = f();
          ignore_unused_variable_warning(r);
      }

      void test(boost::true_type)
      {
          f();
      }

      Func f;
  };

  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check321 __attribute__((__unused__)); ~UnaryFunction() { test(is_void<Return>()); }

   private:
      void test(boost::false_type)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }

      void test(boost::true_type)
      {
          f(arg);
      }







      UnaryFunction();


      Func f;
      Arg arg;
  };

  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check351 __attribute__((__unused__)); ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::false_type)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }

      void test(boost::true_type)
      {
          f(first,second);
      }







      BinaryFunction();


      Func f;
      First first;
      Second second;
  };

  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check381 __attribute__((__unused__)); ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:






      UnaryPredicate();


    Func f;
    Arg arg;
  };

  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check400 __attribute__((__unused__)); ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:






      BinaryPredicate();

    Func f;
    First a;
    Second b;
  };


  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check421 __attribute__((__unused__)); ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {

      require_boolean_expr(fun(a, b));
    }






      Const_BinaryPredicate();


    Func f;
    First a;
    Second b;
  };

  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check448 __attribute__((__unused__)); ~AdaptableGenerator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check450 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check462 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check463 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check481 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check482 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check483 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };

  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };




  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename std::iterator_traits<TT>::value_type value_type;
      typedef typename std::iterator_traits<TT>::difference_type difference_type;
      typedef typename std::iterator_traits<TT>::reference reference;
      typedef typename std::iterator_traits<TT>::pointer pointer;
      typedef typename std::iterator_traits<TT>::iterator_category iterator_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check512 __attribute__((__unused__)); ~InputIterator()
      {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check514 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check515 __attribute__((__unused__));

        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };

  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check529 __attribute__((__unused__)); ~OutputIterator() {

      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };

  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check543 __attribute__((__unused__)); ~ForwardIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed> boost_concept_check548 __attribute__((__unused__))


             ;

          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }

   private:
      TT i;
  };

  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check561 __attribute__((__unused__)); ~Mutable_ForwardIterator() {
        *i++ = *j;
      }
   private:
      TT i, j;
  };

  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check571 __attribute__((__unused__)); ~BidirectionalIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed> boost_concept_check576 __attribute__((__unused__))


             ;

          --i;
          i--;
      }
   private:
      TT i;
  };

  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check589 __attribute__((__unused__)); ~Mutable_BidirectionalIterator()
      {
          *i-- = *j;
      }
   private:
      TT i, j;
  };

  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check601 __attribute__((__unused__)); ~RandomAccessIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed> boost_concept_check606 __attribute__((__unused__))


             ;

          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }

   private:
    TT a, b;
    TT i, j;
      typename std::iterator_traits<TT>::difference_type n;
  };

  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check626 __attribute__((__unused__)); ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename std::iterator_traits<TT>::difference_type n;
  };




  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check648 __attribute__((__unused__)); ~Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check650 __attribute__((__unused__));
          const_constraints(c);
      }

   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };

  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check675 __attribute__((__unused__)); ~Mutable_Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check678 __attribute__((__unused__))
                                                                   ;

          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check680 __attribute__((__unused__));

          i = c.begin();
          i = c.end();
          c.swap(c2);
      }

   private:
      iterator i;
      C c, c2;
  };

  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check695 __attribute__((__unused__)); ~ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed> boost_concept_check700 __attribute__((__unused__))


                  ;
      }
  };

  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check708 __attribute__((__unused__)); ~Mutable_ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed> boost_concept_check713 __attribute__((__unused__))


                  ;
      }
  };

  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check724 __attribute__((__unused__)); ~ReversibleContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check728 __attribute__((__unused__))

                                                                 ;

          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check730 __attribute__((__unused__));

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator _i = cc.rbegin();
          _i = cc.rend();
      }
      C c;
  };

  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check749 __attribute__((__unused__)); ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check752 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check753 __attribute__((__unused__));

          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };

  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check768 __attribute__((__unused__)); ~RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed> boost_concept_check773 __attribute__((__unused__))


                 ;

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }

      C c;
      size_type n;
  };

  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check795 __attribute__((__unused__)); ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check797 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check798 __attribute__((__unused__));

          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }

   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };


  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>



    , DefaultConstructible<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check817 __attribute__((__unused__)); ~Sequence()
      {
          S
              c(n, t),
              c2(first, last);

          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);

          c.erase(p);
          c.erase(p, q);

          typename Sequence::reference r = c.front();

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }

      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };

  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check852 __attribute__((__unused__)); ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };

  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check865 __attribute__((__unused__)); ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      }
      S c;
      typename S::value_type t;
  };

  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check892 __attribute__((__unused__)); ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check900 __attribute__((__unused__));

          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check903 __attribute__((__unused__));
      }


      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }

      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };

  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check928 __attribute__((__unused__)); ~UniqueAssociativeContainer()
      {
          C c(first, last);

          pos_flag = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check946 __attribute__((__unused__)); ~MultipleAssociativeContainer()
      {
          C c(first, last);

          pos = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check965 __attribute__((__unused__)); ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          static_assert((boost::is_same<key_type,value_type>::value), "(boost::is_same<key_type,value_type>::value)");
      }
  };

  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check976 __attribute__((__unused__)); ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          static_assert((boost::is_same<value_type,required_value_type>::value), "(boost::is_same<value_type,required_value_type>::value)");
      }
  };

  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check990 __attribute__((__unused__)); ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);

          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);

          c.insert(p, t);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }

      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();

          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }

   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;

      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };



  template < typename C > struct Collection; template < typename C > struct CollectionConcept : Collection< C > { }; template < typename C > struct Collection
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Collection>)>::failed> boost_concept_check1039 __attribute__((__unused__)); ~Collection()
      {
        boost::function_requires<boost::InputIteratorConcept<iterator> >();
        boost::function_requires<boost::InputIteratorConcept<const_iterator> >();
        boost::function_requires<boost::CopyConstructibleConcept<value_type> >();
        const_constraints(c);
        i = c.begin();
        i = c.end();
        c.swap(c);
      }

      void const_constraints(const C& cc) {
        ci = cc.begin();
        ci = cc.end();
        n = cc.size();
        b = cc.empty();
      }

    private:
      typedef typename C::value_type value_type;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;
      typedef typename C::reference reference;
      typedef typename C::const_reference const_reference;

      typedef typename C::difference_type difference_type;
      typedef typename C::size_type size_type;

      C c;
      bool b;
      iterator i;
      const_iterator ci;
      size_type n;
  };
}





# 1 "/usr/local/include/boost/concept/detail/concept_undef.hpp" 1 3
# 1080 "/usr/local/include/boost/concept_check.hpp" 2 3
# 20 "/usr/local/include/boost/range/concepts.hpp" 2 3
# 1 "/usr/local/include/boost/iterator/iterator_concepts.hpp" 1 3
# 29 "/usr/local/include/boost/iterator/iterator_concepts.hpp" 3
# 1 "/usr/local/include/boost/concept/detail/concept_def.hpp" 1 3
# 30 "/usr/local/include/boost/iterator/iterator_concepts.hpp" 2 3

namespace boost_concepts
{







  template < typename Iterator > struct ReadableIterator; template < typename Iterator > struct ReadableIteratorConcept : ReadableIterator< Iterator > { }; template < typename Iterator > struct ReadableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>

  {
      typedef typename std::iterator_traits<Iterator>::value_type value_type;
      typedef typename std::iterator_traits<Iterator>::reference reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReadableIterator>)>::failed> boost_concept_check48 __attribute__((__unused__)); ~ReadableIterator()
      {

          value_type v = *i;
          boost::ignore_unused_variable_warning(v);
      }
  private:
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = typename std::iterator_traits<Iterator>::value_type
  >
  struct WritableIterator
    : boost::CopyConstructible<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WritableIterator>)>::failed> boost_concept_check65 __attribute__((__unused__)); ~WritableIterator()
      {
          *i = v;
      }
  private:
      ValueType v;
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = typename std::iterator_traits<Iterator>::value_type
  >
  struct WritableIteratorConcept : WritableIterator<Iterator,ValueType> {};

  template < typename Iterator > struct SwappableIterator; template < typename Iterator > struct SwappableIteratorConcept : SwappableIterator< Iterator > { }; template < typename Iterator > struct SwappableIterator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SwappableIterator>)>::failed> boost_concept_check82 __attribute__((__unused__)); ~SwappableIterator()
      {
          std::iter_swap(i1, i2);
      }
  private:
      Iterator i1;
      Iterator i2;
  };

  template < typename Iterator > struct LvalueIterator; template < typename Iterator > struct LvalueIteratorConcept : LvalueIterator< Iterator > { }; template < typename Iterator > struct LvalueIterator
  {
      typedef typename std::iterator_traits<Iterator>::value_type value_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LvalueIterator>)>::failed> boost_concept_check95 __attribute__((__unused__)); ~LvalueIterator()
      {
        value_type& r = const_cast<value_type&>(*i);
        boost::ignore_unused_variable_warning(r);
      }
  private:
      Iterator i;
  };





  template < typename Iterator > struct IncrementableIterator; template < typename Iterator > struct IncrementableIteratorConcept : IncrementableIterator< Iterator > { }; template < typename Iterator > struct IncrementableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>
  {
      typedef typename boost::iterator_traversal<Iterator>::type traversal_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< traversal_category , boost::incrementable_traversal_tag >)>::failed> boost_concept_check118 __attribute__((__unused__))



           ;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIterator>)>::failed> boost_concept_check120 __attribute__((__unused__)); ~IncrementableIterator()
      {
          ++i;
          (void)i++;
      }
  private:
      Iterator i;
  };

  template < typename Iterator > struct SinglePassIterator; template < typename Iterator > struct SinglePassIteratorConcept : SinglePassIterator< Iterator > { }; template < typename Iterator > struct SinglePassIterator
    : IncrementableIterator<Iterator>
    , boost::EqualityComparable<Iterator>

  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename SinglePassIterator::traversal_category , boost::single_pass_traversal_tag > )>::failed> boost_concept_check138 __attribute__((__unused__))



              ;
  };

  template < typename Iterator > struct ForwardTraversal; template < typename Iterator > struct ForwardTraversalConcept : ForwardTraversal< Iterator > { }; template < typename Iterator > struct ForwardTraversal
    : SinglePassIterator<Iterator>
    , boost::DefaultConstructible<Iterator>
  {
      typedef typename std::iterator_traits<Iterator>::difference_type difference_type;

      enum { mpl_assertion_in_line_147 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_integral<difference_type>))0, 1 ) ) ) };
      enum { mpl_assert_rel_value148 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_148 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value148>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename ForwardTraversal::traversal_category , boost::forward_traversal_tag > )>::failed> boost_concept_check154 __attribute__((__unused__))



              ;
  };

  template < typename Iterator > struct BidirectionalTraversal; template < typename Iterator > struct BidirectionalTraversalConcept : BidirectionalTraversal< Iterator > { }; template < typename Iterator > struct BidirectionalTraversal
    : ForwardTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename BidirectionalTraversal::traversal_category , boost::bidirectional_traversal_tag > )>::failed> boost_concept_check164 __attribute__((__unused__))



              ;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalTraversal>)>::failed> boost_concept_check166 __attribute__((__unused__)); ~BidirectionalTraversal()
      {
          --i;
          (void)i--;
      }
   private:
      Iterator i;
  };

  template < typename Iterator > struct RandomAccessTraversal; template < typename Iterator > struct RandomAccessTraversalConcept : RandomAccessTraversal< Iterator > { }; template < typename Iterator > struct RandomAccessTraversal
    : BidirectionalTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename RandomAccessTraversal::traversal_category , boost::random_access_traversal_tag > )>::failed> boost_concept_check182 __attribute__((__unused__))



              ;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessTraversal>)>::failed> boost_concept_check184 __attribute__((__unused__)); ~RandomAccessTraversal()
      {
          i += n;
          i = i + n;
          i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
      }

   private:
      typename BidirectionalTraversal<Iterator>::difference_type n;
      Iterator i, j;
  };




  namespace detail
  {
    template <typename Iterator1, typename Iterator2>
    void interop_single_pass_constraints(Iterator1 const& i1, Iterator2 const& i2)
    {
        bool b;
        b = i1 == i2;
        b = i1 != i2;

        b = i2 == i1;
        b = i2 != i1;
        boost::ignore_unused_variable_warning(b);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const& i1, Iterator2 const& i2,
        boost::random_access_traversal_tag, boost::random_access_traversal_tag)
    {
        bool b;
        typename std::iterator_traits<Iterator2>::difference_type n;
        b = i1 < i2;
        b = i1 <= i2;
        b = i1 > i2;
        b = i1 >= i2;
        n = i1 - i2;

        b = i2 < i1;
        b = i2 <= i1;
        b = i2 > i1;
        b = i2 >= i1;
        n = i2 - i1;
        boost::ignore_unused_variable_warning(b);
        boost::ignore_unused_variable_warning(n);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const&, Iterator2 const&,
        boost::single_pass_traversal_tag, boost::single_pass_traversal_tag)
    { }

  }

  template < typename Iterator , typename ConstIterator > struct InteroperableIterator; template < typename Iterator , typename ConstIterator > struct InteroperableIteratorConcept : InteroperableIterator< Iterator, ConstIterator > { }; template < typename Iterator , typename ConstIterator > struct InteroperableIterator
  {
   private:
      typedef typename boost::iterators::pure_iterator_traversal<Iterator>::type traversal_category;
      typedef typename boost::iterators::pure_iterator_traversal<ConstIterator>::type const_traversal_category;

   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<Iterator>)>::failed> boost_concept_check253 __attribute__((__unused__));
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<ConstIterator>)>::failed> boost_concept_check254 __attribute__((__unused__));

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InteroperableIterator>)>::failed> boost_concept_check256 __attribute__((__unused__)); ~InteroperableIterator()
      {
          detail::interop_single_pass_constraints(i, ci);
          detail::interop_rand_access_constraints(i, ci, traversal_category(), const_traversal_category());

          ci = i;
      }

   private:
      Iterator i;
      ConstIterator ci;
  };

}

# 1 "/usr/local/include/boost/concept/detail/concept_undef.hpp" 1 3
# 272 "/usr/local/include/boost/iterator/iterator_concepts.hpp" 2 3
# 21 "/usr/local/include/boost/range/concepts.hpp" 2 3



# 1 "/usr/local/include/boost/range/value_type.hpp" 1 3
# 23 "/usr/local/include/boost/range/value_type.hpp" 3
namespace boost
{
    template< class T >
    struct range_value : iterator_value< typename range_iterator<T>::type >
    { };
}
# 25 "/usr/local/include/boost/range/concepts.hpp" 2 3
# 1 "/usr/local/include/boost/range/detail/misc_concept.hpp" 1 3
# 13 "/usr/local/include/boost/range/detail/misc_concept.hpp" 3
namespace boost
{
    namespace range_detail
    {
        template<typename T1, typename T2>
        class SameTypeConcept
        {
        public:
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SameTypeConcept>)>::failed> boost_concept_check21 __attribute__((__unused__)); ~SameTypeConcept()
            {
                same_type(a,b);
            }
        private:
            template<typename T> void same_type(T,T) {}
            T1 a;
            T2 b;
        };
    }
}
# 26 "/usr/local/include/boost/range/concepts.hpp" 2 3
# 62 "/usr/local/include/boost/range/concepts.hpp" 3
namespace boost {

    namespace range_detail {
# 124 "/usr/local/include/boost/range/concepts.hpp" 3
        template<class Iterator>
        struct IncrementableIteratorConcept : CopyConstructible<Iterator>
        {

            typedef typename iterator_traversal<Iterator>::type traversal_category;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< traversal_category, incrementable_traversal_tag >)>::failed> boost_concept_check134 __attribute__((__unused__))



                   ;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIteratorConcept>)>::failed> boost_concept_check136 __attribute__((__unused__)); ~IncrementableIteratorConcept()
            {
                ++i;
                (void)i++;
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct SinglePassIteratorConcept
            : IncrementableIteratorConcept<Iterator>
            , EqualityComparable<Iterator>
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename SinglePassIteratorConcept::traversal_category, single_pass_traversal_tag >)>::failed> boost_concept_check156 __attribute__((__unused__))



                   ;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassIteratorConcept>)>::failed> boost_concept_check158 __attribute__((__unused__)); ~SinglePassIteratorConcept()
            {
                Iterator i2(++i);
                boost::ignore_unused_variable_warning(i2);





                (void)(i++);

                typename std::iterator_traits<Iterator>::reference r1(*i);
                boost::ignore_unused_variable_warning(r1);

                typename std::iterator_traits<Iterator>::reference r2(*(++i));
                boost::ignore_unused_variable_warning(r2);
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct ForwardIteratorConcept
            : SinglePassIteratorConcept<Iterator>
            , DefaultConstructible<Iterator>
        {

            typedef typename std::iterator_traits<Iterator>::difference_type difference_type;

            enum { mpl_assertion_in_line_188 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_integral<difference_type>))0, 1 ) ) ) };
            enum { mpl_assert_rel_value189 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_189 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value189>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename ForwardIteratorConcept::traversal_category, forward_traversal_tag >)>::failed> boost_concept_check195 __attribute__((__unused__))



                   ;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIteratorConcept>)>::failed> boost_concept_check197 __attribute__((__unused__)); ~ForwardIteratorConcept()
            {




                Iterator i2(i++);
                boost::ignore_unused_variable_warning(i2);
                typename std::iterator_traits<Iterator>::reference r(*(i++));
                boost::ignore_unused_variable_warning(r);
            }
        private:
            Iterator i;

         };

         template<class Iterator>
         struct BidirectionalIteratorConcept
             : ForwardIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename BidirectionalIteratorConcept::traversal_category, bidirectional_traversal_tag >)>::failed> boost_concept_check222 __attribute__((__unused__))



                    ;

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIteratorConcept>)>::failed> boost_concept_check224 __attribute__((__unused__)); ~BidirectionalIteratorConcept()
             {
                 --i;
                 (void)i--;
             }
         private:
             Iterator i;

         };

         template<class Iterator>
         struct RandomAccessIteratorConcept
             : BidirectionalIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename RandomAccessIteratorConcept::traversal_category, random_access_traversal_tag >)>::failed> boost_concept_check243 __attribute__((__unused__))



                    ;

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIteratorConcept>)>::failed> boost_concept_check245 __attribute__((__unused__)); ~RandomAccessIteratorConcept()
             {
                 i += n;
                 i = i + n;
                 i = n + i;
                 i -= n;
                 i = i - n;
                 n = i - j;
             }
         private:
             typename BidirectionalIteratorConcept<Iterator>::difference_type n;
             Iterator i;
             Iterator j;

         };

    }


    template<class T>
    struct SinglePassRangeConcept
    {



        typedef typename remove_reference<T>::type Rng;

        typedef typename range_iterator<
            Rng const
        >::type const_iterator;

        typedef typename range_iterator<Rng>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( range_detail::SinglePassIteratorConcept<iterator>)>::failed> boost_concept_check279 __attribute__((__unused__))
                                                                   ;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( range_detail::SinglePassIteratorConcept<const_iterator>)>::failed> boost_concept_check282 __attribute__((__unused__))
                                                                         ;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassRangeConcept>)>::failed> boost_concept_check284 __attribute__((__unused__)); ~SinglePassRangeConcept()
        {



            iterator i1 = boost::begin(*m_range);
            iterator i2 = boost::end(*m_range);

            boost::ignore_unused_variable_warning(i1);
            boost::ignore_unused_variable_warning(i2);

            const_constraints(*m_range);
        }

    private:
        void const_constraints(const Rng& const_range)
        {
            const_iterator ci1 = boost::begin(const_range);
            const_iterator ci2 = boost::end(const_range);

            boost::ignore_unused_variable_warning(ci1);
            boost::ignore_unused_variable_warning(ci2);
        }





       Rng* m_range;

    };


    template<class T>
    struct ForwardRangeConcept : SinglePassRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::iterator>)>::failed> boost_concept_check321 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::const_iterator>)>::failed> boost_concept_check322 __attribute__((__unused__));

    };

    template<class T>
    struct WriteableRangeConcept
    {

        typedef typename range_iterator<T>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WriteableRangeConcept>)>::failed> boost_concept_check332 __attribute__((__unused__)); ~WriteableRangeConcept()
        {
            *i = v;
        }
    private:
        iterator i;
        typename range_value<T>::type v;

    };


    template<class T>
    struct WriteableForwardRangeConcept
        : ForwardRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct BidirectionalRangeConcept : ForwardRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::BidirectionalIteratorConcept<typename BidirectionalRangeConcept::iterator>)>::failed> boost_concept_check355 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::BidirectionalIteratorConcept<typename BidirectionalRangeConcept::const_iterator>)>::failed> boost_concept_check356 __attribute__((__unused__));

    };


    template<class T>
    struct WriteableBidirectionalRangeConcept
        : BidirectionalRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct RandomAccessRangeConcept : BidirectionalRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::RandomAccessIteratorConcept<typename RandomAccessRangeConcept::iterator>)>::failed> boost_concept_check373 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::RandomAccessIteratorConcept<typename RandomAccessRangeConcept::const_iterator>)>::failed> boost_concept_check374 __attribute__((__unused__));

    };


    template<class T>
    struct WriteableRandomAccessRangeConcept
        : RandomAccessRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };

}
# 21 "/usr/local/include/boost/range/size_type.hpp" 2 3



# 1 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_signed.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/is_signed.hpp" 3
# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 17 "/usr/local/include/boost/type_traits/is_signed.hpp" 2 3

namespace boost {







namespace detail{

template <class T>
struct is_signed_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_signed_helper
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};

template <bool integral_type>
struct is_signed_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_signed_helper<T> type;
   };
};

template <>
struct is_signed_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_signed_impl
{
   typedef ::boost::detail::is_signed_select_helper< ::boost::is_integral<T>::value || ::boost::is_enum<T>::value> selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};

}

template <class T> struct is_signed : public integral_constant<bool, boost::detail::is_signed_impl<T>::value> {};
# 91 "/usr/local/include/boost/type_traits/is_signed.hpp" 3
template <> struct is_signed<signed char> : public true_type{};
template <> struct is_signed<const signed char> : public true_type{};
template <> struct is_signed<volatile signed char> : public true_type{};
template <> struct is_signed<const volatile signed char> : public true_type{};
template <> struct is_signed<short> : public true_type{};
template <> struct is_signed<const short> : public true_type{};
template <> struct is_signed<volatile short> : public true_type{};
template <> struct is_signed<const volatile short> : public true_type{};
template <> struct is_signed<int> : public true_type{};
template <> struct is_signed<const int> : public true_type{};
template <> struct is_signed<volatile int> : public true_type{};
template <> struct is_signed<const volatile int> : public true_type{};
template <> struct is_signed<long> : public true_type{};
template <> struct is_signed<const long> : public true_type{};
template <> struct is_signed<volatile long> : public true_type{};
template <> struct is_signed<const volatile long> : public true_type{};

template <> struct is_signed<unsigned char> : public false_type{};
template <> struct is_signed<const unsigned char> : public false_type{};
template <> struct is_signed<volatile unsigned char> : public false_type{};
template <> struct is_signed<const volatile unsigned char> : public false_type{};
template <> struct is_signed<unsigned short> : public false_type{};
template <> struct is_signed<const unsigned short> : public false_type{};
template <> struct is_signed<volatile unsigned short> : public false_type{};
template <> struct is_signed<const volatile unsigned short> : public false_type{};
template <> struct is_signed<unsigned int> : public false_type{};
template <> struct is_signed<const unsigned int> : public false_type{};
template <> struct is_signed<volatile unsigned int> : public false_type{};
template <> struct is_signed<const volatile unsigned int> : public false_type{};
template <> struct is_signed<unsigned long> : public false_type{};
template <> struct is_signed<const unsigned long> : public false_type{};
template <> struct is_signed<volatile unsigned long> : public false_type{};
template <> struct is_signed<const volatile unsigned long> : public false_type{};

template <> struct is_signed< ::boost::long_long_type> : public true_type{};
template <> struct is_signed<const ::boost::long_long_type> : public true_type{};
template <> struct is_signed<volatile ::boost::long_long_type> : public true_type{};
template <> struct is_signed<const volatile ::boost::long_long_type> : public true_type{};

template <> struct is_signed< ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<const ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<volatile ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<const volatile ::boost::ulong_long_type> : public false_type{};



template <> struct is_signed<char> : public true_type{};
template <> struct is_signed<const char> : public true_type{};
template <> struct is_signed<volatile char> : public true_type{};
template <> struct is_signed<const volatile char> : public true_type{};
# 150 "/usr/local/include/boost/type_traits/is_signed.hpp" 3
template <> struct is_signed<wchar_t> : public true_type{};
template <> struct is_signed<const wchar_t> : public true_type{};
template <> struct is_signed<volatile wchar_t> : public true_type{};
template <> struct is_signed<const volatile wchar_t> : public true_type{};







}
# 15 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_unsigned.hpp" 1 3
# 17 "/usr/local/include/boost/type_traits/is_unsigned.hpp" 3
# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 18 "/usr/local/include/boost/type_traits/is_unsigned.hpp" 2 3

namespace boost {







namespace detail{

template <class T>
struct is_unsigned_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_ununsigned_helper
{
   static const bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};

template <bool integral_type>
struct is_unsigned_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_ununsigned_helper<T> type;
   };
};

template <>
struct is_unsigned_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_unsigned
{
   typedef ::boost::detail::is_unsigned_select_helper< ::boost::is_integral<T>::value || ::boost::is_enum<T>::value > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};

}

template <class T> struct is_unsigned : public integral_constant<bool, boost::detail::is_unsigned<T>::value> {};
# 91 "/usr/local/include/boost/type_traits/is_unsigned.hpp" 3
template <> struct is_unsigned<unsigned char> : public true_type{};
template <> struct is_unsigned<const unsigned char> : public true_type{};
template <> struct is_unsigned<volatile unsigned char> : public true_type{};
template <> struct is_unsigned<const volatile unsigned char> : public true_type{};
template <> struct is_unsigned<unsigned short> : public true_type{};
template <> struct is_unsigned<const unsigned short> : public true_type{};
template <> struct is_unsigned<volatile unsigned short> : public true_type{};
template <> struct is_unsigned<const volatile unsigned short> : public true_type{};
template <> struct is_unsigned<unsigned int> : public true_type{};
template <> struct is_unsigned<const unsigned int> : public true_type{};
template <> struct is_unsigned<volatile unsigned int> : public true_type{};
template <> struct is_unsigned<const volatile unsigned int> : public true_type{};
template <> struct is_unsigned<unsigned long> : public true_type{};
template <> struct is_unsigned<const unsigned long> : public true_type{};
template <> struct is_unsigned<volatile unsigned long> : public true_type{};
template <> struct is_unsigned<const volatile unsigned long> : public true_type{};

template <> struct is_unsigned<signed char> : public false_type{};
template <> struct is_unsigned<const signed char> : public false_type{};
template <> struct is_unsigned<volatile signed char> : public false_type{};
template <> struct is_unsigned<const volatile signed char> : public false_type{};
template <> struct is_unsigned< short> : public false_type{};
template <> struct is_unsigned<const short> : public false_type{};
template <> struct is_unsigned<volatile short> : public false_type{};
template <> struct is_unsigned<const volatile short> : public false_type{};
template <> struct is_unsigned< int> : public false_type{};
template <> struct is_unsigned<const int> : public false_type{};
template <> struct is_unsigned<volatile int> : public false_type{};
template <> struct is_unsigned<const volatile int> : public false_type{};
template <> struct is_unsigned< long> : public false_type{};
template <> struct is_unsigned<const long> : public false_type{};
template <> struct is_unsigned<volatile long> : public false_type{};
template <> struct is_unsigned<const volatile long> : public false_type{};

template <> struct is_unsigned< ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<const ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<volatile ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<const volatile ::boost::ulong_long_type> : public true_type{};

template <> struct is_unsigned< ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<const ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<volatile ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<const volatile ::boost::long_long_type> : public false_type{};
# 142 "/usr/local/include/boost/type_traits/is_unsigned.hpp" 3
template <> struct is_unsigned<char> : public false_type{};
template <> struct is_unsigned<const char> : public false_type{};
template <> struct is_unsigned<volatile char> : public false_type{};
template <> struct is_unsigned<const volatile char> : public false_type{};
# 155 "/usr/local/include/boost/type_traits/is_unsigned.hpp" 3
template <> struct is_unsigned<wchar_t> : public false_type{};
template <> struct is_unsigned<const wchar_t> : public false_type{};
template <> struct is_unsigned<volatile wchar_t> : public false_type{};
template <> struct is_unsigned<const volatile wchar_t> : public false_type{};


}
# 16 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 2 3
# 25 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 3
namespace boost {

template <class T>
struct make_unsigned
{
private:
   static_assert((::boost::is_integral<T>::value || ::boost::is_enum<T>::value), "The template argument to make_unsigned must be an integer or enum type.");
   static_assert((! ::boost::is_same<typename remove_cv<T>::type, bool>::value), "The template argument to make_unsigned must not be the type bool");

   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename conditional<
      (::boost::is_unsigned<T>::value && ::boost::is_integral<T>::value
      && ! ::boost::is_same<t_no_cv, char>::value
      && ! ::boost::is_same<t_no_cv, wchar_t>::value
      && ! ::boost::is_same<t_no_cv, bool>::value),
      T,
      typename conditional<
         (::boost::is_integral<T>::value
         && ! ::boost::is_same<t_no_cv, char>::value
         && ! ::boost::is_same<t_no_cv, wchar_t>::value
         && ! ::boost::is_same<t_no_cv, bool>::value),
         typename conditional<
            is_same<t_no_cv, signed char>::value,
            unsigned char,
            typename conditional<
               is_same<t_no_cv, short>::value,
               unsigned short,
               typename conditional<
                  is_same<t_no_cv, int>::value,
                  unsigned int,
                  typename conditional<
                     is_same<t_no_cv, long>::value,
                     unsigned long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                        boost::ulong_long_type,
                        boost::uint128_type
                     >::type
# 73 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 3
                  >::type
               >::type
            >::type
         >::type,

         typename conditional<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename conditional<
               sizeof(t_no_cv) == sizeof(unsigned short),
               unsigned short,
               typename conditional<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  unsigned int,
                  typename conditional<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     unsigned long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                        boost::ulong_long_type,
                        boost::uint128_type
                     >::type
# 105 "/usr/local/include/boost/type_traits/make_unsigned.hpp" 3
                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename conditional<
      is_const<T>::value,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;
public:

   typedef typename conditional<
      is_volatile<T>::value,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};



   template <class T> using make_unsigned_t = typename make_unsigned<T>::type;



}
# 25 "/usr/local/include/boost/range/size_type.hpp" 2 3




namespace boost
{
    namespace detail
    {





        template<typename T>
        class has_size_type
        {
            typedef char no_type;
            struct yes_type { char dummy[2]; };

            template<typename C>
            static yes_type test(typename C::size_type x);

            template<typename C>
            static no_type test(...);

        public:
            static const bool value = sizeof(test<T>(0)) == sizeof(yes_type);
        };

        template<typename C, typename Enabler=void>
        struct range_size_
        {
            typedef typename make_unsigned<
                typename range_difference<C>::type
            >::type type;
        };

        template<typename C>
        struct range_size_<
            C,
            typename ::boost::enable_if<has_size_type<C>, void>::type
        >
        {
            typedef typename C::size_type type;
        };

        template<typename C, bool B = range_detail::has_type< range_iterator<C> >::value>
        struct range_size
        { };

        template<typename C>
        struct range_size<C, true>
          : range_size_<C>
        { };
    }

    template< class T >
    struct range_size :
        detail::range_size<T>
    { };

}
# 22 "/usr/local/include/boost/range/size.hpp" 2 3
# 1 "/usr/local/include/boost/range/detail/has_member_size.hpp" 1 3
# 18 "/usr/local/include/boost/range/detail/has_member_size.hpp" 3
# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 19 "/usr/local/include/boost/range/detail/has_member_size.hpp" 2 3

namespace boost
{
    namespace range_detail
    {

template<class T>
class has_member_size_impl
{
private:
    template<class U, U>
    class check
    {
    };

    template<class C>
    static boost::uint8_t f(check<std::size_t(C::*)(void) const, &C::size>*);

    template<class C>
    static boost::uint16_t f(...);

public:
    static const bool value =
        (sizeof(f<T>(0)) == sizeof(boost::uint8_t));

    typedef typename mpl::if_c<
        (sizeof(f<T>(0)) == sizeof(boost::uint8_t)),
        mpl::true_,
        mpl::false_
    >::type type;
};

template<class T>
struct has_member_size
{
    typedef typename mpl::and_<
        typename is_class<T>::type,
        typename has_member_size_impl<const T>::type
    >::type type;

    static const bool value =
        is_class<T>::value && has_member_size_impl<const T>::value;
};

    }
}
# 23 "/usr/local/include/boost/range/size.hpp" 2 3
# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 24 "/usr/local/include/boost/range/size.hpp" 2 3
# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 25 "/usr/local/include/boost/range/size.hpp" 2 3
# 1 "/usr/local/include/boost/utility.hpp" 1 3
# 15 "/usr/local/include/boost/utility.hpp" 3
# 1 "/usr/local/include/boost/utility/base_from_member.hpp" 1 3
# 17 "/usr/local/include/boost/utility/base_from_member.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1 3
# 23 "/usr/local/include/boost/preprocessor/repetition/repeat_from_to.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3
# 18 "/usr/local/include/boost/utility/base_from_member.hpp" 2 3
# 58 "/usr/local/include/boost/utility/base_from_member.hpp" 3
namespace boost
{

namespace detail
{
# 72 "/usr/local/include/boost/utility/base_from_member.hpp" 3
template < typename T >
struct remove_cv_ref
{
    typedef typename ::boost::remove_cv<typename
     ::boost::remove_reference<T>::type>::type type;

};







template < typename T, typename U >
struct is_related
    : public ::boost::is_same<
     typename ::boost::detail::remove_cv_ref<T>::type,
     typename ::boost::detail::remove_cv_ref<U>::type >
{};
# 100 "/usr/local/include/boost/utility/base_from_member.hpp" 3
template<typename ...T>
struct enable_if_unrelated
    : public ::boost::enable_if_c<true>
{};

template<typename T, typename U, typename ...U2>
struct enable_if_unrelated<T, U, U2...>
    : public ::boost::disable_if< ::boost::detail::is_related<T, U> >
{};


}
# 123 "/usr/local/include/boost/utility/base_from_member.hpp" 3
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;





    template <typename ...T, typename EnableIf = typename
     ::boost::detail::enable_if_unrelated<base_from_member, T...>::type>
    explicit constexpr base_from_member( T&& ...x )
        noexcept((noexcept((::new ((void*) 0) MemberType( static_cast<T&&>(x)... )))))

        : member( static_cast<T&&>(x)... )
        {}
# 150 "/usr/local/include/boost/utility/base_from_member.hpp" 3
};

template < typename MemberType, int UniqueID >
class base_from_member<MemberType&, UniqueID>
{
protected:
    MemberType& member;

    explicit constexpr base_from_member( MemberType& x )
        noexcept
        : member( x )
        {}

};

}
# 16 "/usr/local/include/boost/utility.hpp" 2 3
# 1 "/usr/local/include/boost/utility/binary.hpp" 1 3
# 26 "/usr/local/include/boost/utility/binary.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/control/deduce_d.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/control/deduce_d.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/control/deduce_d.hpp" 2 3
# 27 "/usr/local/include/boost/utility/binary.hpp" 2 3


# 1 "/usr/local/include/boost/preprocessor/seq/cat.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/seq/cat.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/seq/fold_left.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/seq/fold_left.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/seq/fold_left.hpp" 2 3
# 19 "/usr/local/include/boost/preprocessor/seq/cat.hpp" 2 3
# 30 "/usr/local/include/boost/utility/binary.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/seq/transform.hpp" 1 3
# 31 "/usr/local/include/boost/utility/binary.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/arithmetic/mod.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/arithmetic/mod.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/comparison/less_equal.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/comparison/less_equal.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/logical/not.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/comparison/less_equal.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 2 3
# 18 "/usr/local/include/boost/preprocessor/arithmetic/mod.hpp" 2 3
# 32 "/usr/local/include/boost/utility/binary.hpp" 2 3
# 17 "/usr/local/include/boost/utility.hpp" 2 3
# 1 "/usr/local/include/boost/utility/identity_type.hpp" 1 3
# 18 "/usr/local/include/boost/utility.hpp" 2 3
# 26 "/usr/local/include/boost/range/size.hpp" 2 3

namespace boost
{
    namespace range_detail
    {

        template<class SinglePassRange>
        inline typename ::boost::enable_if<
            has_member_size<SinglePassRange>,
            typename range_size<const SinglePassRange>::type
        >::type
        range_calculate_size(const SinglePassRange& rng)
        {
            return rng.size();
        }

        template<class SinglePassRange>
        inline typename disable_if<
            has_member_size<SinglePassRange>,
            typename range_size<const SinglePassRange>::type
        >::type
        range_calculate_size(const SinglePassRange& rng)
        {
            return std::distance(boost::begin(rng), boost::end(rng));
        }
    }

    template<class SinglePassRange>
    inline typename range_size<const SinglePassRange>::type
    size(const SinglePassRange& rng)
    {





        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::SinglePassRangeConcept<SinglePassRange>)>::failed> boost_concept_check62 __attribute__((__unused__));





        using namespace range_detail;


        return range_calculate_size(rng);
    }

}
# 21 "/usr/local/include/boost/range/functions.hpp" 2 3
# 1 "/usr/local/include/boost/range/distance.hpp" 1 3
# 18 "/usr/local/include/boost/range/distance.hpp" 3
# 1 "/usr/local/include/boost/iterator/distance.hpp" 1 3
# 14 "/usr/local/include/boost/iterator/distance.hpp" 3
namespace boost {
namespace iterators {

    namespace detail {
        template <typename SinglePassIterator>
        inline constexpr typename iterator_difference<SinglePassIterator>::type
        distance_impl(
            SinglePassIterator first
          , SinglePassIterator last
          , single_pass_traversal_tag
        )
        {
            typename iterator_difference<SinglePassIterator>::type n = 0;
            while (first != last) {
                ++first;
                ++n;
            }
            return n;
        }

        template <typename RandomAccessIterator>
        inline constexpr typename iterator_difference<RandomAccessIterator>::type
        distance_impl(
            RandomAccessIterator first
          , RandomAccessIterator last
          , random_access_traversal_tag
        )
        {
            return last - first;
        }
    }

    namespace distance_adl_barrier {
        template <typename SinglePassIterator>
        inline constexpr typename iterator_difference<SinglePassIterator>::type
        distance(SinglePassIterator first, SinglePassIterator last)
        {
            return detail::distance_impl(
                first, last, typename iterator_traversal<SinglePassIterator>::type()
            );
        }
    }

    using namespace distance_adl_barrier;

}

using namespace iterators::distance_adl_barrier;

}
# 19 "/usr/local/include/boost/range/distance.hpp" 2 3




namespace boost
{

    namespace range_distance_adl_barrier
    {
        template< class T >
        inline constexpr typename range_difference<T>::type
        distance( const T& r )
        {
            return boost::iterators::distance( boost::begin( r ), boost::end( r ) );
        }
    }

    using namespace range_distance_adl_barrier;

}
# 22 "/usr/local/include/boost/range/functions.hpp" 2 3
# 1 "/usr/local/include/boost/range/empty.hpp" 1 3
# 22 "/usr/local/include/boost/range/empty.hpp" 3
namespace boost
{

    template< class T >
    inline bool empty( const T& r )
    {
        return boost::begin( r ) == boost::end( r );
    }

}
# 23 "/usr/local/include/boost/range/functions.hpp" 2 3
# 1 "/usr/local/include/boost/range/rbegin.hpp" 1 3
# 19 "/usr/local/include/boost/range/rbegin.hpp" 3
# 1 "/usr/local/include/boost/range/reverse_iterator.hpp" 1 3
# 21 "/usr/local/include/boost/range/reverse_iterator.hpp" 3
# 1 "/usr/local/include/boost/iterator/reverse_iterator.hpp" 1 3
# 10 "/usr/local/include/boost/iterator/reverse_iterator.hpp" 3
# 1 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 1 3
# 30 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 3
# 1 "/usr/local/include/boost/iterator/detail/config_def.hpp" 1 3
# 31 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 2 3



namespace boost {
namespace iterators {




  using boost::use_default;

}




template<class To>
struct is_convertible<use_default,To>
  : mpl::false_ {};

namespace iterators {

  namespace detail
  {
# 63 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 3
    struct enable_type;
  }
# 130 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 3
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , boost::iterators::detail::enable_type
      >
  {};






  namespace detail
  {


    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };



    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived


          , typename boost::iterators::detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type






          , typename boost::iterators::detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type

          , typename boost::iterators::detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type

          , typename boost::iterators::detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };


    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      static_assert((is_convertible<Tr1, Tr2>::value), "(is_convertible<Tr1, Tr2>::value)");
    }
  }
# 241 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 3
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public boost::iterators::detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;

   protected:
      typedef typename boost::iterators::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}

      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }

      typedef Base base_type;

      Base const& base() const
        { return m_iterator; }

   protected:

      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;




      Base const& base_reference() const
        { return m_iterator; }

      Base& base_reference()
        { return m_iterator; }

   private:






      typename super_t::reference dereference() const
        { return *m_iterator; }

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {




          return m_iterator == x.base();
      }

      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;




      void advance(typename super_t::difference_type n)
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }

      void increment() { ++m_iterator; }

      void decrement()
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();




          return y.base() - m_iterator;
      }



   private:
      Base m_iterator;
  };

}

using iterators::iterator_adaptor;
using iterators::enable_if_convertible;

}

# 1 "/usr/local/include/boost/iterator/detail/config_undef.hpp" 1 3
# 357 "/usr/local/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 11 "/usr/local/include/boost/iterator/reverse_iterator.hpp" 2 3

namespace boost {
namespace iterators {




  template <class Iterator>
  class reverse_iterator
      : public iterator_adaptor< reverse_iterator<Iterator>, Iterator >
  {
      typedef iterator_adaptor< reverse_iterator<Iterator>, Iterator > super_t;

      friend class iterator_core_access;

   public:
      reverse_iterator() {}

      explicit reverse_iterator(Iterator x)
          : super_t(x) {}

      template<class OtherIterator>
      reverse_iterator(
          reverse_iterator<OtherIterator> const& r
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0
          )
          : super_t(r.base())
      {}

   private:
      typename super_t::reference dereference() const
      {
          Iterator it = this->base_reference();
          --it;
          return *it;
      }

      void increment() { --this->base_reference(); }
      void decrement() { ++this->base_reference(); }

      void advance(typename super_t::difference_type n)
      {
          this->base_reference() -= n;
      }

      template <class OtherIterator>
      typename super_t::difference_type
      distance_to(reverse_iterator<OtherIterator> const& y) const
      {
          return this->base_reference() - y.base();
      }
  };

  template <class BidirectionalIterator>
  inline reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
  {
      return reverse_iterator<BidirectionalIterator>(x);
  }

}

using iterators::reverse_iterator;
using iterators::make_reverse_iterator;

}
# 22 "/usr/local/include/boost/range/reverse_iterator.hpp" 2 3


namespace boost
{




    template< typename T >
    struct range_reverse_iterator
    {
        typedef reverse_iterator<
            typename range_iterator<
                typename remove_reference<T>::type>::type > type;
    };


}
# 20 "/usr/local/include/boost/range/rbegin.hpp" 2 3

namespace boost
{
# 35 "/usr/local/include/boost/range/rbegin.hpp" 3
template< class C >
inline typename range_reverse_iterator<C>::type
rbegin( C& c )
{
    typedef typename range_reverse_iterator<C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rbegin( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rbegin( const T& r )
{
    return boost::rbegin( r );
}

}
# 24 "/usr/local/include/boost/range/functions.hpp" 2 3
# 1 "/usr/local/include/boost/range/rend.hpp" 1 3
# 21 "/usr/local/include/boost/range/rend.hpp" 3
namespace boost
{
# 35 "/usr/local/include/boost/range/rend.hpp" 3
template< class C >
inline typename range_reverse_iterator<C>::type
rend( C& c )
{
    typedef typename range_reverse_iterator<C>::type
               iter_type;
    return iter_type( boost::begin( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rend( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::begin( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rend( const T& r )
{
    return boost::rend( r );
}

}
# 25 "/usr/local/include/boost/range/functions.hpp" 2 3
# 39 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3



# 1 "/usr/local/include/boost/range/algorithm/equal.hpp" 1 3
# 17 "/usr/local/include/boost/range/algorithm/equal.hpp" 3
namespace boost
{
    namespace range_detail
    {


        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2 >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            for (;;)
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


                if (*first1 != *first2)
                    break;

                ++first1;
                ++first2;
            }



            return false;
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2,
                  class BinaryPredicate >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            for (;;)
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


                if (!pred(*first1, *first2))
                    break;

                ++first1;
                ++first2;
            }



            return false;
        }



        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2 >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2);
        }

        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2, pred);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2 >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2 )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, tag1, tag2);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2,
                           BinaryPredicate pred )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, pred, tag1, tag2);
        }

    }

    namespace range
    {
# 171 "/usr/local/include/boost/range/algorithm/equal.hpp" 3
        template< class SinglePassRange1, class SinglePassRange2 >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2 )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check174 __attribute__((__unused__));
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check175 __attribute__((__unused__));

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2) );
        }


        template< class SinglePassRange1, class SinglePassRange2, class BinaryPredicate >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2,
                           BinaryPredicate pred )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check187 __attribute__((__unused__));
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check188 __attribute__((__unused__));

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2),
                pred);
        }

    }
    using ::boost::range::equal;
}
# 43 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3
# 1 "/usr/local/include/boost/range/detail/safe_bool.hpp" 1 3
# 16 "/usr/local/include/boost/range/detail/safe_bool.hpp" 3
namespace boost
{
    namespace range_detail
    {

template<class DataMemberPtr>
class safe_bool
{
public:
    typedef safe_bool this_type;
# 56 "/usr/local/include/boost/range/detail/safe_bool.hpp" 3
    typedef DataMemberPtr unspecified_bool_type;
    static unspecified_bool_type to_unspecified_bool(const bool x, DataMemberPtr p)
    {
        return x ? p : 0;
    }

private:
    safe_bool();
    safe_bool(const safe_bool&);
    void operator=(const safe_bool&);
    ~safe_bool();
};

    }
}
# 44 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3

# 1 "/usr/local/include/boost/next_prior.hpp" 1 3
# 21 "/usr/local/include/boost/next_prior.hpp" 3
# 1 "/usr/local/include/boost/type_traits/has_plus.hpp" 1 3
# 48 "/usr/local/include/boost/type_traits/has_plus.hpp" 3
# 1 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 1 3
# 25 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
          
# 26 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 37 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 1 "/usr/local/include/boost/type_traits/make_void.hpp" 1 3
# 15 "/usr/local/include/boost/type_traits/make_void.hpp" 3
namespace boost {


template<class...>
struct make_void {
    typedef void type;
};


template<class... Ts>
using void_t = typename make_void<Ts...>::type;
# 50 "/usr/local/include/boost/type_traits/make_void.hpp" 3
}
# 38 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3





namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_plus_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_plus_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_plus_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_plus_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() + std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_plus : public boost::binary_op_detail:: has_plus_ret_imp <T, U, Ret> {};
   template <class T, class U>
   struct has_plus<T, U, void> : public boost::binary_op_detail:: has_plus_void_imp <T, U> {};
   template <class T, class U>
   struct has_plus<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_plus_dc_imp <T, U> {};


}
# 49 "/usr/local/include/boost/type_traits/has_plus.hpp" 2 3
# 22 "/usr/local/include/boost/next_prior.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/has_plus_assign.hpp" 1 3
# 28 "/usr/local/include/boost/type_traits/has_plus_assign.hpp" 3
          
# 29 "/usr/local/include/boost/type_traits/has_plus_assign.hpp" 3
# 52 "/usr/local/include/boost/type_traits/has_plus_assign.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_plus_assign_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_plus_assign_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_plus_assign_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_assign_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_plus_assign_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_assign_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_plus_assign_filter_ret : public boost::binary_op_detail:: has_plus_assign_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_plus_assign_filter_ret<T, U, void> : public boost::binary_op_detail:: has_plus_assign_void_imp <T, U> {};
      template <class T, class U>
      struct has_plus_assign_filter_ret<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_plus_assign_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool f>
      struct has_plus_assign_filter_impossible : public boost::binary_op_detail:: has_plus_assign_filter_ret <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_plus_assign_filter_impossible<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_plus_assign : public boost::binary_op_detail:: has_plus_assign_filter_impossible <T, U, Ret, boost::is_arithmetic<typename boost::remove_reference<T>::type>::value && boost::is_pointer<typename remove_reference<U>::type>::value && !boost::is_same<bool, typename boost::remove_cv<typename remove_reference<T>::type>::type>::value> {};

}
# 23 "/usr/local/include/boost/next_prior.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/has_minus.hpp" 1 3
# 28 "/usr/local/include/boost/type_traits/has_minus.hpp" 3
          
# 29 "/usr/local/include/boost/type_traits/has_minus.hpp" 3
# 48 "/usr/local/include/boost/type_traits/has_minus.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_minus_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_minus_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_minus_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_minus_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_minus_ret_filter : public boost::binary_op_detail::has_minus_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_minus_ret_filter<T, U, void> : public boost::binary_op_detail::has_minus_void_imp <T, U> {};
      template <class T, class U>
      struct has_minus_ret_filter<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail::has_minus_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool b>
      struct has_minus_void_ptr_filter : public boost::binary_op_detail::has_minus_ret_filter <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_minus_void_ptr_filter<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_minus :
      public boost::binary_op_detail::has_minus_void_ptr_filter<
         T, U, Ret,
         boost::is_void<typename remove_pointer<typename remove_reference<T>::type>::type>::value
         || boost::is_void<typename remove_pointer<typename remove_reference<U>::type>::type>::value> {};


}
# 24 "/usr/local/include/boost/next_prior.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/has_minus_assign.hpp" 1 3
# 28 "/usr/local/include/boost/type_traits/has_minus_assign.hpp" 3
          
# 29 "/usr/local/include/boost/type_traits/has_minus_assign.hpp" 3
# 49 "/usr/local/include/boost/type_traits/has_minus_assign.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_minus_assign_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_minus_assign_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_minus_assign_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_assign_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_minus_assign_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_assign_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_minus_assign_ret_filter : public boost::binary_op_detail::has_minus_assign_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_minus_assign_ret_filter<T, U, void> : public boost::binary_op_detail::has_minus_assign_void_imp <T, U> {};
      template <class T, class U>
      struct has_minus_assign_ret_filter<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail::has_minus_assign_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool b>
      struct has_minus_assign_void_ptr_filter : public boost::binary_op_detail::has_minus_assign_ret_filter <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_minus_assign_void_ptr_filter<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_minus_assign :
      public boost::binary_op_detail::has_minus_assign_void_ptr_filter<
      T, U, Ret,
      boost::is_void<typename remove_pointer<typename remove_reference<T>::type>::type>::value
      || boost::is_void<typename remove_pointer<typename remove_reference<U>::type>::type>::value
      || (boost::is_pointer<typename remove_reference<T>::type>::value && boost::is_pointer<typename remove_reference<U>::type>::value)> {};


}
# 25 "/usr/local/include/boost/next_prior.hpp" 2 3
# 1 "/usr/local/include/boost/iterator/advance.hpp" 1 3
# 13 "/usr/local/include/boost/iterator/advance.hpp" 3
namespace boost {
namespace iterators {

    namespace detail {
        template <typename InputIterator, typename Distance>
        inline constexpr void
        advance_impl(
            InputIterator& it
          , Distance n
          , incrementable_traversal_tag
        )
        {
            while (n > 0) {
                ++it;
                --n;
            }
        }

        template <typename BidirectionalIterator, typename Distance>
        inline constexpr void
        advance_impl(
            BidirectionalIterator& it
          , Distance n
          , bidirectional_traversal_tag
        )
        {
            if (n >= 0) {
                while (n > 0) {
                    ++it;
                    --n;
                }
            }
            else {
                while (n < 0) {
                    --it;
                    ++n;
                }
            }
        }

        template <typename RandomAccessIterator, typename Distance>
        inline constexpr void
        advance_impl(
            RandomAccessIterator& it
          , Distance n
          , random_access_traversal_tag
        )
        {
            it += n;
        }
    }

    namespace advance_adl_barrier {
        template <typename InputIterator, typename Distance>
        inline constexpr void
        advance(InputIterator& it, Distance n)
        {
            detail::advance_impl(
                it, n, typename iterator_traversal<InputIterator>::type()
            );
        }
    }

    using namespace advance_adl_barrier;

}

using namespace iterators::advance_adl_barrier;

}
# 26 "/usr/local/include/boost/next_prior.hpp" 2 3


namespace boost {
# 40 "/usr/local/include/boost/next_prior.hpp" 3
namespace next_prior_detail {







template< typename T, typename Void = void >
struct is_iterator_class
{
    static constexpr bool value = false;
};

template< typename T >
struct is_iterator_class<
    T,
    typename enable_if_has_type<

        typename std::iterator_traits< T >::iterator_category



    >::type
>
{
    static constexpr bool value = true;
};

template< typename T >
struct is_iterator :
    public is_iterator_class< T >
{
};

template< typename T >
struct is_iterator< T* >
{
    static constexpr bool value = true;
};


template< typename T, typename Distance, bool HasPlus = has_plus< T, Distance >::value >
struct next_plus_impl;

template< typename T, typename Distance >
struct next_plus_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        return x + n;
    }
};

template< typename T, typename Distance, bool HasPlusAssign = has_plus_assign< T, Distance >::value >
struct next_plus_assign_impl :
    public next_plus_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct next_plus_assign_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        x += n;
        return x;
    }
};

template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
struct next_advance_impl :
    public next_plus_assign_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct next_advance_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        boost::iterators::advance(x, n);
        return x;
    }
};


template< typename T, typename Distance, bool HasMinus = has_minus< T, Distance >::value >
struct prior_minus_impl;

template< typename T, typename Distance >
struct prior_minus_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        return x - n;
    }
};

template< typename T, typename Distance, bool HasMinusAssign = has_minus_assign< T, Distance >::value >
struct prior_minus_assign_impl :
    public prior_minus_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct prior_minus_assign_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        x -= n;
        return x;
    }
};

template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
struct prior_advance_impl :
    public prior_minus_assign_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct prior_advance_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {

        boost::iterators::reverse_iterator< T > rx(x);
        boost::iterators::advance(rx, n);
        return rx.base();
    }
};

}

template <class T>
inline T next(T x) { return ++x; }

template <class T, class Distance>
inline T next(T x, Distance n)
{
    return next_prior_detail::next_advance_impl< T, Distance >::call(x, n);
}

template <class T>
inline T prior(T x) { return --x; }

template <class T, class Distance>
inline T prior(T x, Distance n)
{
    return next_prior_detail::prior_advance_impl< T, Distance >::call(x, n);
}

}
# 46 "/usr/local/include/boost/range/iterator_range_core.hpp" 2 3
# 57 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
namespace boost
{
    namespace iterator_range_detail
    {




        template<class IteratorT>
        struct iterator_range_impl {
            template< class ForwardRange >
            static IteratorT adl_begin( ForwardRange& r )
            {
                return IteratorT( boost::begin( r ) );
            }

            template< class ForwardRange >
            static IteratorT adl_end( ForwardRange& r )
            {
                return IteratorT( boost::end( r ) );
            }
        };

        template< class Left, class Right >
        inline bool less_than( const Left& l, const Right& r )
        {
            return std::lexicographical_compare( boost::begin(l),
                                                 boost::end(l),
                                                 boost::begin(r),
                                                 boost::end(r) );
        }

        template< class Left, class Right >
        inline bool greater_than( const Left& l, const Right& r )
        {
            return iterator_range_detail::less_than(r,l);
        }

        template< class Left, class Right >
        inline bool less_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(r,l);
        }

        template< class Left, class Right >
        inline bool greater_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(l,r);
        }



        template< class Left, class Right >
        inline bool equal(const Left& l, const Right& r)
        {
            return boost::equal(l, r);
        }

struct range_tag
{
};

struct const_range_tag
{
};

struct iterator_range_tag
{
};

typedef char (&incrementable_t)[1];
typedef char (&bidirectional_t)[2];
typedef char (&random_access_t)[3];

incrementable_t test_traversal_tag(boost::incrementable_traversal_tag);
bidirectional_t test_traversal_tag(boost::bidirectional_traversal_tag);
random_access_t test_traversal_tag(boost::random_access_traversal_tag);

template<std::size_t S>
struct pure_iterator_traversal_impl
{
    typedef boost::incrementable_traversal_tag type;
};

template<>
struct pure_iterator_traversal_impl<sizeof(bidirectional_t)>
{
    typedef boost::bidirectional_traversal_tag type;
};

template<>
struct pure_iterator_traversal_impl<sizeof(random_access_t)>
{
    typedef boost::random_access_traversal_tag type;
};

template<typename IteratorT>
struct pure_iterator_traversal
{
    typedef
        typename iterator_traversal<IteratorT>::type
    traversal_t;
    static const std::size_t traversal_i = sizeof(iterator_range_detail::test_traversal_tag((traversal_t())))


     ;
    typedef
        typename pure_iterator_traversal_impl<traversal_i>::type
    type;
};

template<class IteratorT, class TraversalTag>
class iterator_range_base
    : public iterator_range_tag
{
    typedef range_detail::safe_bool<
                IteratorT iterator_range_base<IteratorT, TraversalTag>::*
    > safe_bool_t;

    typedef iterator_range_base<IteratorT, TraversalTag> type;

protected:
    typedef iterator_range_impl<IteratorT> impl;

public:
    typedef typename
        safe_bool_t::unspecified_bool_type unspecified_bool_type;

    typedef typename
        iterator_value<IteratorT>::type value_type;

    typedef typename
        iterator_difference<IteratorT>::type difference_type;

    typedef std::size_t size_type;



    typedef typename
                iterator_reference<IteratorT>::type reference;






    typedef IteratorT const_iterator;

    typedef IteratorT iterator;

protected:
    iterator_range_base()
        : m_Begin()
        , m_End()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator Begin, Iterator End)
        : m_Begin(Begin)
        , m_End(End)
    {
    }

public:
    IteratorT begin() const
    {
        return m_Begin;
    }

    IteratorT end() const
    {
        return m_End;
    }

    bool empty() const
    {
        return m_Begin == m_End;
    }

    operator unspecified_bool_type() const
    {
        return safe_bool_t::to_unspecified_bool(
                    m_Begin != m_End, &iterator_range_base::m_Begin);
    }

    bool operator!() const
    {
        return empty();
    }

    bool equal(const iterator_range_base& r) const
    {
        return m_Begin == r.m_Begin && m_End == r.m_End;
    }

   reference front() const
   {
       (static_cast <bool> (!empty()) ? void (0) : __assert_fail ("!empty()", "/usr/local/include/boost/range/iterator_range_core.hpp", 255, __extension__ __PRETTY_FUNCTION__));
       return *m_Begin;
   }

   void drop_front()
   {
       (static_cast <bool> (!empty()) ? void (0) : __assert_fail ("!empty()", "/usr/local/include/boost/range/iterator_range_core.hpp", 261, __extension__ __PRETTY_FUNCTION__));
       ++m_Begin;
   }

   void drop_front(difference_type n)
   {
       (static_cast <bool> (n >= difference_type()) ? void (0) : __assert_fail ("n >= difference_type()", "/usr/local/include/boost/range/iterator_range_core.hpp", 267, __extension__ __PRETTY_FUNCTION__));
       std::advance(this->m_Begin, n);
   }


   void pop_front() { drop_front(); }

protected:
    template<class Iterator>
    void assign(Iterator first, Iterator last)
    {
        m_Begin = first;
        m_End = last;
    }

    template<class SinglePassRange>
    void assign(const SinglePassRange& r)
    {
        m_Begin = impl::adl_begin(r);
        m_End = impl::adl_end(r);
    }

    template<class SinglePassRange>
    void assign(SinglePassRange& r)
    {
        m_Begin = impl::adl_begin(r);
        m_End = impl::adl_end(r);
    }

    IteratorT m_Begin;
    IteratorT m_End;
};

template<class IteratorT>
class iterator_range_base<IteratorT, bidirectional_traversal_tag>
        : public iterator_range_base<IteratorT, incrementable_traversal_tag>
{
    typedef iterator_range_base<IteratorT, incrementable_traversal_tag> base_type;

protected:
    iterator_range_base()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator first, Iterator last)
        : base_type(first, last)
    {
    }

public:
    typedef typename base_type::difference_type difference_type;
    typedef typename base_type::reference reference;

    reference back() const
    {
        (static_cast <bool> (!this->empty()) ? void (0) : __assert_fail ("!this->empty()", "/usr/local/include/boost/range/iterator_range_core.hpp", 323, __extension__ __PRETTY_FUNCTION__));
        return *boost::prior(this->m_End);
    }

    void drop_back()
    {
        (static_cast <bool> (!this->empty()) ? void (0) : __assert_fail ("!this->empty()", "/usr/local/include/boost/range/iterator_range_core.hpp", 329, __extension__ __PRETTY_FUNCTION__));
        --this->m_End;
    }

    void drop_back(difference_type n)
    {
        (static_cast <bool> (n >= difference_type()) ? void (0) : __assert_fail ("n >= difference_type()", "/usr/local/include/boost/range/iterator_range_core.hpp", 335, __extension__ __PRETTY_FUNCTION__));
        std::advance(this->m_End, -n);
    }


    void pop_back() { drop_back(); }
};

template<class IteratorT>
class iterator_range_base<IteratorT, random_access_traversal_tag>
        : public iterator_range_base<IteratorT, bidirectional_traversal_tag>
{
    typedef iterator_range_base<
                IteratorT, bidirectional_traversal_tag> base_type;

public:
    typedef typename
        boost::mpl::if_<
            boost::mpl::or_<
                boost::is_abstract<
                    typename base_type::value_type
                >,
                boost::is_array<
                    typename base_type::value_type
                >,
                boost::is_function<
                    typename base_type::value_type
                >
            >,
            typename base_type::reference,
            typename base_type::value_type
        >::type abstract_value_type;




    typedef typename base_type::difference_type difference_type;
    typedef typename base_type::size_type size_type;
    typedef typename base_type::reference reference;

protected:
    iterator_range_base()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator first, Iterator last)
        : base_type(first, last)
    {
    }

public:
    reference operator[](difference_type at) const
    {
        (static_cast <bool> (at >= 0) ? void (0) : __assert_fail ("at >= 0", "/usr/local/include/boost/range/iterator_range_core.hpp", 389, __extension__ __PRETTY_FUNCTION__));
        (static_cast <bool> (static_cast<typename base_type::size_type>(at) < size()) ? void (0) : __assert_fail ("static_cast<typename base_type::size_type>(at) < size()", "/usr/local/include/boost/range/iterator_range_core.hpp", 390, __extension__ __PRETTY_FUNCTION__));
        return this->m_Begin[at];
    }






    abstract_value_type operator()(difference_type at) const
    {
        (static_cast <bool> (at >= 0) ? void (0) : __assert_fail ("at >= 0", "/usr/local/include/boost/range/iterator_range_core.hpp", 401, __extension__ __PRETTY_FUNCTION__));
        (static_cast <bool> (static_cast<typename base_type::size_type>(at) < size()) ? void (0) : __assert_fail ("static_cast<typename base_type::size_type>(at) < size()", "/usr/local/include/boost/range/iterator_range_core.hpp", 402, __extension__ __PRETTY_FUNCTION__));
        return this->m_Begin[at];
    }

    typename base_type::size_type size() const
    {
        return this->m_End - this->m_Begin;
    }
};

    }
# 433 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
        template<class IteratorT>
        class iterator_range
            : public iterator_range_detail::iterator_range_base<
                    IteratorT,
                    typename iterator_range_detail::pure_iterator_traversal<IteratorT>::type
                >
        {
            typedef iterator_range_detail::iterator_range_base<
                    IteratorT,
                    typename iterator_range_detail::pure_iterator_traversal<IteratorT>::type
            > base_type;

            template<class Source>
            struct is_compatible_range_
              : is_convertible<
                    typename mpl::eval_if<
                        has_range_iterator<Source>,
                        range_iterator<Source>,
                        mpl::identity<void>
                    >::type,
                    typename base_type::iterator
                >
            {
            };

            template<class Source>
            struct is_compatible_range
                : mpl::and_<
                    mpl::not_<
                        is_convertible<
                            Source,
                            typename base_type::iterator
                        >
                    >,
                    is_compatible_range_<Source>
                >
            {
            };

        protected:
            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;

        public:
            typedef iterator_range<IteratorT> type;

            iterator_range()
            {
            }

            template<class Iterator>
            iterator_range(Iterator first, Iterator last)
                : base_type(first, last)
            {
            }

            template<class SinglePassRange>
            iterator_range(
                const SinglePassRange& r,
                typename ::boost::enable_if<
                    is_compatible_range<const SinglePassRange>
                >::type* = 0
            )
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(
                SinglePassRange& r,
                typename ::boost::enable_if<
                    is_compatible_range<SinglePassRange>
                >::type* = 0
            )
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(const SinglePassRange& r,
                           iterator_range_detail::const_range_tag)
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(SinglePassRange& r,
                           iterator_range_detail::range_tag)
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class Iterator>
            iterator_range& operator=(const iterator_range<Iterator>& other)
            {
                this->assign(other.begin(), other.end());
                return *this;
            }

            template<class Iterator>
            iterator_range& operator=(iterator_range<Iterator>& other)
            {
                this->assign(other.begin(), other.end());
                return *this;
            }

            template<class SinglePassRange>
            iterator_range& operator=(SinglePassRange& r)
            {
                this->assign(r);
                return *this;
            }

            template<class SinglePassRange>
            iterator_range& operator=(const SinglePassRange& r)
            {
                this->assign(r);
                return *this;
            }

            iterator_range& advance_begin(
                typename base_type::difference_type n)
            {
                std::advance(this->m_Begin, n);
                return *this;
            }

            iterator_range& advance_end(
                typename base_type::difference_type n)
            {
                std::advance(this->m_End, n);
                return *this;
            }

        protected:




            typedef iterator_range iterator_range_;
        };







        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator==( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator!=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }



        template< class Iterator1T, class Iterator2T >
        inline bool
        operator==( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator==( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool
        operator!=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator!=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return !boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool
        operator<( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator<=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator>( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator>=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline typename boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }
# 758 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
        template< typename IteratorT >
        inline iterator_range< IteratorT >
        make_iterator_range( IteratorT Begin, IteratorT End )
        {
            return iterator_range<IteratorT>( Begin, End );
        }

        template<typename IteratorT, typename IntegerT>
        inline iterator_range<IteratorT>
        make_iterator_range_n(IteratorT first, IntegerT n)
        {
            return iterator_range<IteratorT>(first, boost::next(first, n));
        }
# 788 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
        template< class ForwardRange >
        inline iterator_range< typename range_iterator<ForwardRange>::type >
        make_iterator_range( ForwardRange& r )
        {
           return iterator_range< typename range_iterator<ForwardRange>::type >
                ( r, iterator_range_detail::range_tag() );
        }

        template< class ForwardRange >
        inline iterator_range< typename range_iterator<const ForwardRange>::type >
        make_iterator_range( const ForwardRange& r )
        {
           return iterator_range< typename range_iterator<const ForwardRange>::type >
                ( r, iterator_range_detail::const_range_tag() );
        }



        namespace iterator_range_detail
        {
            template< class Range >
            inline iterator_range< typename range_iterator<Range>::type >
            make_range_impl( Range& r,
                             typename range_difference<Range>::type advance_begin,
                             typename range_difference<Range>::type advance_end )
            {







                typename range_iterator<Range>::type
                    new_begin = boost::begin( r ),
                    new_end = boost::end( r );
                std::advance( new_begin, advance_begin );
                std::advance( new_end, advance_end );
                return make_iterator_range( new_begin, new_end );
            }
        }
# 843 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
        template< class Range >
        inline iterator_range< typename range_iterator<Range>::type >
        make_iterator_range( Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }

        template< class Range >
        inline iterator_range< typename range_iterator<const Range>::type >
        make_iterator_range( const Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
# 871 "/usr/local/include/boost/range/iterator_range_core.hpp" 3
        template< typename SeqT, typename Range >
        inline SeqT copy_range( const Range& r )
        {
            return SeqT( boost::begin( r ), boost::end( r ) );
        }

}
# 31 "/usr/local/include/boost/lexical_cast.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast/bad_lexical_cast.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
          






namespace boost
{

    class __attribute__((__visibility__("default"))) bad_lexical_cast :




        public std::bad_cast







    {
    public:
        bad_lexical_cast() noexcept

           : source(&typeid(void)), target(&typeid(void))

        {}

        virtual const char *what() const noexcept {
            return "bad lexical cast: "
                   "source type value could not be interpreted as target";
        }

        virtual ~bad_lexical_cast() noexcept
        {}


        bad_lexical_cast(
                const std::type_info &source_type_arg,
                const std::type_info &target_type_arg) noexcept
            : source(&source_type_arg), target(&target_type_arg)
        {}

        const std::type_info &source_type() const noexcept {
            return *source;
        }

        const std::type_info &target_type() const noexcept {
            return *target;
        }

    private:
        const std::type_info *source;
        const std::type_info *target;

    };

    namespace conversion { namespace detail {






        template <class S, class T>
        inline void throw_bad_cast() {
            boost::throw_exception(bad_lexical_cast(typeid(S), typeid(T)));
        }

    }}


}
# 32 "/usr/local/include/boost/lexical_cast.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast/try_lexical_convert.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/try_lexical_convert.hpp" 3
          





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wsign-conversion"





# 1 "/usr/local/include/boost/type_traits/type_identity.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/type_identity.hpp" 3
namespace boost
{

template<class T> struct type_identity
{
    typedef T type;
};



template <class T> using type_identity_t = typename type_identity<T>::type;




}
# 38 "/usr/local/include/boost/lexical_cast/try_lexical_convert.hpp" 2 3




# 1 "/usr/local/include/boost/lexical_cast/detail/is_character.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/is_character.hpp" 3
          





namespace boost {

    namespace detail
    {

        template < typename T >
        struct is_character
        {
            typedef typename boost::integral_constant<
              bool,
              boost::is_same< T, char >::value ||

                        boost::is_same< T, wchar_t >::value ||


                        boost::is_same< T, char16_t >::value ||


                        boost::is_same< T, char32_t >::value ||

                    boost::is_same< T, unsigned char >::value ||
                    boost::is_same< T, signed char >::value
            > type;

            static const bool value = (type::value);
        };
    }
}
# 43 "/usr/local/include/boost/lexical_cast/try_lexical_convert.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
          
# 33 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
# 1 "/usr/local/include/boost/type_traits/is_base_of.hpp" 1 3
# 16 "/usr/local/include/boost/type_traits/is_base_of.hpp" 3
namespace boost {

   namespace detail{
      template <class B, class D>
      struct is_base_of_imp
      {
          typedef typename remove_cv<B>::type ncvB;
          typedef typename remove_cv<D>::type ncvD;
          static const bool value = ( (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value) || (::boost::is_same<ncvB,ncvD>::value && ::boost::is_class<ncvB>::value))

                                                                                    ;
      };
   }

   template <class Base, class Derived> struct is_base_of
      : public integral_constant<bool, (::boost::detail::is_base_of_imp<Base, Derived>::value)> {};

   template <class Base, class Derived> struct is_base_of<Base, Derived&> : false_type{};
   template <class Base, class Derived> struct is_base_of<Base&, Derived&> : false_type{};
   template <class Base, class Derived> struct is_base_of<Base&, Derived> : false_type{};

}
# 34 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/is_float.hpp" 1 3
# 14 "/usr/local/include/boost/type_traits/is_float.hpp" 3
namespace boost {


   template <class T> struct is_float : public is_floating_point<T> {};
}
# 35 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 2 3

# 1 "/usr/local/include/boost/numeric/conversion/cast.hpp" 1 3
# 33 "/usr/local/include/boost/numeric/conversion/cast.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/converter.hpp" 1 3
# 13 "/usr/local/include/boost/numeric/conversion/converter.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/conversion_traits.hpp" 1 3
# 13 "/usr/local/include/boost/numeric/conversion/conversion_traits.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 1 3
# 17 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/meta.hpp" 1 3
# 17 "/usr/local/include/boost/numeric/conversion/detail/meta.hpp" 3
# 1 "/usr/local/include/boost/mpl/equal_to.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/equal_to.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct equal_to

    : equal_to_impl<
          typename equal_to_tag<N1>::type
        , typename equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef equal_to< na , na > result_; typedef equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value == N2::value ) >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/equal_to.hpp" 2 3
# 18 "/usr/local/include/boost/numeric/conversion/detail/meta.hpp" 2 3





namespace boost { namespace numeric { namespace convdetail
{
   template< class T1, class T2>
   struct equal_to
   {


       enum { x = ( T1::value == T2::value ) };

       static const bool value = x;

       typedef mpl::bool_<value> type;
# 48 "/usr/local/include/boost/numeric/conversion/detail/meta.hpp" 3
   };
# 59 "/usr/local/include/boost/numeric/conversion/detail/meta.hpp" 3
  template<class Value,
           class Case0Val,
           class Case1Val,
           class Case2Val,
           class Case0Type,
           class Case1Type,
           class Case2Type,
           class DefaultType
          >
  struct ct_switch4
  {
    typedef mpl::identity<Case0Type> Case0TypeQ ;
    typedef mpl::identity<Case1Type> Case1TypeQ ;

    typedef equal_to<Value,Case0Val> is_case0 ;
    typedef equal_to<Value,Case1Val> is_case1 ;
    typedef equal_to<Value,Case2Val> is_case2 ;

    typedef mpl::if_<is_case2,Case2Type,DefaultType> choose_2_3Q ;
    typedef mpl::eval_if<is_case1,Case1TypeQ,choose_2_3Q> choose_1_2_3Q ;

    typedef typename
      mpl::eval_if<is_case0,Case0TypeQ,choose_1_2_3Q>::type
        type ;
  } ;
# 97 "/usr/local/include/boost/numeric/conversion/detail/meta.hpp" 3
  template<class expr0, class expr1, class TT, class TF, class FT, class FF>
  struct for_both
  {
    typedef mpl::identity<TF> TF_Q ;
    typedef mpl::identity<TT> TT_Q ;

    typedef typename mpl::not_<expr0>::type not_expr0 ;
    typedef typename mpl::not_<expr1>::type not_expr1 ;

    typedef typename mpl::and_<expr0,expr1>::type caseTT ;
    typedef typename mpl::and_<expr0,not_expr1>::type caseTF ;
    typedef typename mpl::and_<not_expr0,expr1>::type caseFT ;

    typedef mpl::if_<caseFT,FT,FF> choose_FT_FF_Q ;
    typedef mpl::eval_if<caseTF,TF_Q,choose_FT_FF_Q> choose_TF_FT_FF_Q ;

    typedef typename mpl::eval_if<caseTT,TT_Q,choose_TF_FT_FF_Q>::type type ;
  } ;

} } }
# 18 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 1 3
# 16 "/usr/local/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/int_float_mixture_enum.hpp" 1 3
# 13 "/usr/local/include/boost/numeric/conversion/int_float_mixture_enum.hpp" 3
namespace boost { namespace numeric
{
  enum int_float_mixture_enum
  {
     integral_to_integral
    ,integral_to_float
    ,float_to_integral
    ,float_to_float
  } ;

} }
# 17 "/usr/local/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 2 3




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<int_float_mixture_enum, integral_to_integral> int2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, integral_to_float> int2float_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_integral> float2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_float> float2float_c ;







  template<class T,class S>
  struct get_int_float_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_integer > S_int ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_integer > T_int ;

    typedef typename
      for_both<S_int, T_int, int2int_c, int2float_c, float2int_c, float2float_c>::type
        type ;
  } ;
# 55 "/usr/local/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 3
  template<class IntFloatMixture, class Int2Int, class Int2Float, class Float2Int, class Float2Float>
  struct for_int_float_mixture
  {
    typedef typename
      ct_switch4<IntFloatMixture
                 ,int2int_c, int2float_c, float2int_c
                 ,Int2Int , Int2Float , Float2Int , Float2Float
                >::type
        type ;
  } ;

} } }
# 19 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/sign_mixture.hpp" 1 3
# 16 "/usr/local/include/boost/numeric/conversion/detail/sign_mixture.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/sign_mixture_enum.hpp" 1 3
# 13 "/usr/local/include/boost/numeric/conversion/sign_mixture_enum.hpp" 3
namespace boost { namespace numeric
{
  enum sign_mixture_enum
  {
     unsigned_to_unsigned
    ,signed_to_signed
    ,signed_to_unsigned
    ,unsigned_to_signed
  } ;

} }
# 17 "/usr/local/include/boost/numeric/conversion/detail/sign_mixture.hpp" 2 3




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_unsigned> unsig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_signed> sig2sig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_unsigned> sig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_signed> unsig2sig_c ;







  template<class T,class S>
  struct get_sign_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_signed > S_signed ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_signed > T_signed ;

    typedef typename
      for_both<S_signed, T_signed, sig2sig_c, sig2unsig_c, unsig2sig_c, unsig2unsig_c>::type
        type ;
  } ;
# 55 "/usr/local/include/boost/numeric/conversion/detail/sign_mixture.hpp" 3
  template<class SignMixture, class Sig2Sig, class Sig2Unsig, class Unsig2Sig, class Unsig2Unsig>
  struct for_sign_mixture
  {
    typedef typename
      ct_switch4<SignMixture
                 , sig2sig_c, sig2unsig_c, unsig2sig_c
                 , Sig2Sig , Sig2Unsig , Unsig2Sig , Unsig2Unsig
                >::type
        type ;
  } ;

} } }
# 20 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 1 3
# 15 "/usr/local/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/udt_builtin_mixture_enum.hpp" 1 3
# 13 "/usr/local/include/boost/numeric/conversion/udt_builtin_mixture_enum.hpp" 3
namespace boost { namespace numeric
{
  enum udt_builtin_mixture_enum
  {
     builtin_to_builtin
    ,builtin_to_udt
    ,udt_to_builtin
    ,udt_to_udt
  } ;

} }
# 16 "/usr/local/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 2 3




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_builtin> builtin2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_udt> builtin2udt_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_builtin> udt2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_udt> udt2udt_c ;
# 37 "/usr/local/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 3
  template<class UdtMixture, class BuiltIn2BuiltIn, class BuiltIn2Udt, class Udt2BuiltIn, class Udt2Udt>
  struct for_udt_builtin_mixture
  {
    typedef typename
      ct_switch4<UdtMixture
                 , builtin2builtin_c, builtin2udt_c, udt2builtin_c
                 , BuiltIn2BuiltIn , BuiltIn2Udt , Udt2BuiltIn , Udt2Udt
                >::type
        type ;
  } ;







  template<class T,class S>
  struct get_udt_builtin_mixture
  {
    typedef is_arithmetic<S> S_builtin ;
    typedef is_arithmetic<T> T_builtin ;

    typedef typename
      for_both<S_builtin, T_builtin, builtin2builtin_c, builtin2udt_c, udt2builtin_c, udt2udt_c>::type
        type ;
  } ;

} } }
# 21 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/is_subranged.hpp" 1 3
# 17 "/usr/local/include/boost/numeric/conversion/detail/is_subranged.hpp" 3
# 1 "/usr/local/include/boost/mpl/multiplies.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/multiplies.hpp" 3
# 1 "/usr/local/include/boost/mpl/times.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/times.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/times.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/times.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct times_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< times_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< times_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct times_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct times_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct times_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct times_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct times
    : times< times< times< times< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct times< N1,N2,N3,N4,na >

    : times< times< times< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct times< N1,N2,N3,na,na >

    : times< times< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct times< N1,N2,na,na,na >
    : times_impl<
          typename times_tag<N1>::type
        , typename times_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct times< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : times< T1 , T2 > { }; }; template< typename Tag > struct lambda< times< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef times< na , na > result_; typedef times< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< times< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< times< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct times_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  * N2::value
                )
            >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/usr/local/include/boost/mpl/aux_/arithmetic_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/times.hpp" 2 3
# 18 "/usr/local/include/boost/mpl/multiplies.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/multiplies.hpp" 3
namespace boost { namespace mpl {







template<
      typename N1 = na , typename N2 = na , typename N3 = na , typename N4 = na , typename N5 = na
    >
struct multiplies
    : times< N1 , N2 , N3 , N4 , N5 >
{
   




};

template<> struct multiplies< na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct apply : multiplies< T1 , T2 , T3 , T4 , T5 > { }; }; template< typename Tag > struct lambda< multiplies< na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef multiplies< na , na , na , na , na > result_; typedef multiplies< na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< multiplies< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< multiplies< na , na , na , na , na > > : int_<-1> { }; }



}}
# 18 "/usr/local/include/boost/numeric/conversion/detail/is_subranged.hpp" 2 3
# 28 "/usr/local/include/boost/numeric/conversion/detail/is_subranged.hpp" 3
namespace boost { namespace numeric { namespace convdetail
{





    template<class T,class S>
    struct subranged_Sig2Unsig
    {


      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_Unsig2Sig
    {
# 62 "/usr/local/include/boost/numeric/conversion/detail/is_subranged.hpp" 3
       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;


       typedef typename T_digits::next u_T_digits ;

       typedef mpl::int_<2> Two ;

       typedef typename mpl::multiplies<S_digits,Two>::type S_digits_times_2 ;

       typedef typename mpl::less<u_T_digits,S_digits_times_2>::type type ;
    } ;


    template<class T,class S>
    struct subranged_SameSign
    {


       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;

       typedef typename mpl::less<T_digits,S_digits>::type type ;
    } ;


    template<class T,class S>
    struct subranged_Int2Float
    {
      typedef mpl::false_ type ;
    } ;


    template<class T,class S>
    struct subranged_Float2Int
    {
      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_Float2Float
    {



      typedef mpl::int_< ::std::numeric_limits<S>::digits > S_mantisa ;
      typedef mpl::int_< ::std::numeric_limits<T>::digits > T_mantisa ;

      typedef mpl::int_< ::std::numeric_limits<S>::max_exponent > S_exponent ;
      typedef mpl::int_< ::std::numeric_limits<T>::max_exponent > T_exponent ;

      typedef typename mpl::less<T_exponent,S_exponent>::type T_smaller_exponent ;

      typedef typename mpl::equal_to<T_exponent,S_exponent>::type equal_exponents ;

      typedef mpl::less<T_mantisa,S_mantisa> T_smaller_mantisa ;

      typedef mpl::eval_if<equal_exponents,T_smaller_mantisa,mpl::false_> not_bigger_exponent_case ;

      typedef typename
        mpl::eval_if<T_smaller_exponent,mpl::true_,not_bigger_exponent_case>::type
          type ;
    } ;


    template<class T,class S>
    struct subranged_Udt2BuiltIn
    {
      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_BuiltIn2Udt
    {
      typedef mpl::false_ type ;
    } ;


    template<class T,class S>
    struct subranged_Udt2Udt
    {
      typedef mpl::false_ type ;
    } ;





    template<class T,class S>
    struct get_subranged_Int2Int
    {
      typedef subranged_SameSign<T,S> Sig2Sig ;
      typedef subranged_Sig2Unsig<T,S> Sig2Unsig ;
      typedef subranged_Unsig2Sig<T,S> Unsig2Sig ;
      typedef Sig2Sig Unsig2Unsig ;

      typedef typename get_sign_mixture<T,S>::type sign_mixture ;

      typedef typename
        for_sign_mixture<sign_mixture, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>::type
           type ;
    } ;

    template<class T,class S>
    struct get_subranged_BuiltIn2BuiltIn
    {
      typedef get_subranged_Int2Int<T,S> Int2IntQ ;

      typedef subranged_Int2Float <T,S> Int2Float ;
      typedef subranged_Float2Int <T,S> Float2Int ;
      typedef subranged_Float2Float<T,S> Float2Float ;

      typedef mpl::identity<Int2Float > Int2FloatQ ;
      typedef mpl::identity<Float2Int > Float2IntQ ;
      typedef mpl::identity<Float2Float> Float2FloatQ ;

      typedef typename get_int_float_mixture<T,S>::type int_float_mixture ;

      typedef for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ> for_ ;

      typedef typename for_::type selected ;

      typedef typename selected::type type ;
    } ;

    template<class T,class S>
    struct get_subranged
    {
      typedef get_subranged_BuiltIn2BuiltIn<T,S> BuiltIn2BuiltInQ ;

      typedef subranged_BuiltIn2Udt<T,S> BuiltIn2Udt ;
      typedef subranged_Udt2BuiltIn<T,S> Udt2BuiltIn ;
      typedef subranged_Udt2Udt<T,S> Udt2Udt ;

      typedef mpl::identity<BuiltIn2Udt> BuiltIn2UdtQ ;
      typedef mpl::identity<Udt2BuiltIn> Udt2BuiltInQ ;
      typedef mpl::identity<Udt2Udt > Udt2UdtQ ;

      typedef typename get_udt_builtin_mixture<T,S>::type udt_builtin_mixture ;

      typedef typename
        for_udt_builtin_mixture<udt_builtin_mixture, BuiltIn2BuiltInQ, BuiltIn2UdtQ, Udt2BuiltInQ, Udt2UdtQ>::type
          selected ;

      typedef typename selected::type selected2 ;

      typedef typename selected2::type type ;
    } ;





  template<class T, class S>
  struct get_is_subranged
  {
    typedef get_subranged<T,S> non_trivial_case ;
    typedef mpl::identity<mpl::false_> trivial_case ;

    typedef is_same<T,S> is_trivial ;

    typedef typename mpl::if_<is_trivial,trivial_case,non_trivial_case>::type selected ;

    typedef typename selected::type type ;
  } ;

} } }
# 22 "/usr/local/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2 3

namespace boost { namespace numeric { namespace convdetail
{





  template<class T,class S>
  struct non_trivial_traits_impl
  {
    typedef typename get_int_float_mixture <T,S>::type int_float_mixture ;
    typedef typename get_sign_mixture <T,S>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture <T,S>::type udt_builtin_mixture ;

    typedef typename get_is_subranged<T,S>::type subranged ;

    typedef mpl::false_ trivial ;

    typedef T target_type ;
    typedef S source_type ;
    typedef T result_type ;

    typedef typename mpl::if_< is_arithmetic<S>, S, S const&>::type argument_type ;

    typedef typename mpl::if_<subranged,S,T>::type supertype ;
    typedef typename mpl::if_<subranged,T,S>::type subtype ;
  } ;






  template<class N>
  struct trivial_traits_impl
  {
    typedef typename get_int_float_mixture <N,N>::type int_float_mixture ;
    typedef typename get_sign_mixture <N,N>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture<N,N>::type udt_builtin_mixture ;

    typedef mpl::false_ subranged ;
    typedef mpl::true_ trivial ;

    typedef N target_type ;
    typedef N source_type ;
    typedef N const& result_type ;
    typedef N const& argument_type ;

    typedef N supertype ;
    typedef N subtype ;

  } ;




  template<class T, class S>
  struct get_conversion_traits
  {
    typedef typename remove_cv<T>::type target_type ;
    typedef typename remove_cv<S>::type source_type ;

    typedef typename is_same<target_type,source_type>::type is_trivial ;

    typedef trivial_traits_impl <target_type> trivial_imp ;
    typedef non_trivial_traits_impl<target_type,source_type> non_trivial_imp ;

    typedef typename mpl::if_<is_trivial,trivial_imp,non_trivial_imp>::type type ;
  } ;

} } }
# 14 "/usr/local/include/boost/numeric/conversion/conversion_traits.hpp" 2 3



namespace boost { namespace numeric
{

template<class T, class S>
struct conversion_traits
    : convdetail::get_conversion_traits<T,S>::type
{
} ;

} }
# 14 "/usr/local/include/boost/numeric/conversion/converter.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/converter_policies.hpp" 1 3
# 15 "/usr/local/include/boost/numeric/conversion/converter_policies.hpp" 3
# 1 "/usr/local/include/boost/config/no_tr1/cmath.hpp" 1 3
# 21 "/usr/local/include/boost/config/no_tr1/cmath.hpp" 3
# 1 "/usr/include/c++/7/cmath" 1 3
# 39 "/usr/include/c++/7/cmath" 3
       
# 40 "/usr/include/c++/7/cmath" 3
# 22 "/usr/local/include/boost/config/no_tr1/cmath.hpp" 2 3
# 16 "/usr/local/include/boost/numeric/conversion/converter_policies.hpp" 2 3
# 25 "/usr/local/include/boost/numeric/conversion/converter_policies.hpp" 3
namespace boost { namespace numeric
{

template<class S>
struct Trunc
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::floor ;
    using std::ceil ;


    return s < static_cast<S>(0) ? ceil(s) : floor(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_zero> round_style ;
} ;



template<class S>
struct Floor
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::floor ;


    return floor(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_neg_infinity> round_style ;
} ;

template<class S>
struct Ceil
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::ceil ;


    return ceil(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_infinity> round_style ;
} ;

template<class S>
struct RoundEven
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {



    using std::floor ;
    using std::ceil ;



    S prev = floor(s);
    S next = ceil(s);

    S rt = (s - prev) - (next - s);

    S const zero(0.0);
    S const two(2.0);

    if ( rt < zero )
      return prev;
    else if ( rt > zero )
      return next;
    else
    {
      bool is_prev_even = two * floor(prev / two) == prev ;
      return ( is_prev_even ? prev : next ) ;
    }
  }

  typedef mpl::integral_c< std::float_round_style, std::round_to_nearest> round_style ;
} ;


enum range_check_result
{
  cInRange = 0 ,
  cNegOverflow = 1 ,
  cPosOverflow = 2
} ;

class bad_numeric_cast : public std::bad_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: overflow"; }
};

class negative_overflow : public bad_numeric_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: negative overflow"; }
};
class positive_overflow : public bad_numeric_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: positive overflow"; }
};

struct def_overflow_handler
{
  void operator() ( range_check_result r )
  {

    if ( r == cNegOverflow )
      throw negative_overflow() ;
    else if ( r == cPosOverflow )
           throw positive_overflow() ;






  }
} ;

struct silent_overflow_handler
{
  void operator() ( range_check_result ) {}
} ;

template<class Traits>
struct raw_converter
{
  typedef typename Traits::result_type result_type ;
  typedef typename Traits::argument_type argument_type ;

  static result_type low_level_convert ( argument_type s ) { return static_cast<result_type>(s) ; }
} ;

struct UseInternalRangeChecker {} ;

} }
# 15 "/usr/local/include/boost/numeric/conversion/converter.hpp" 2 3

# 1 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 1 3
# 17 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/bounds.hpp" 1 3
# 13 "/usr/local/include/boost/numeric/conversion/bounds.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/bounds.hpp" 1 3
# 17 "/usr/local/include/boost/numeric/conversion/detail/bounds.hpp" 3
namespace boost { namespace numeric { namespace boundsdetail
{
  template<class N>
  class Integral
  {
      typedef std::numeric_limits<N> limits ;

    public :

      static N lowest () { return limits::min (); }
      static N highest () { return limits::max (); }
      static N smallest() { return static_cast<N>(1); }
  } ;

  template<class N>
  class Float
  {
      typedef std::numeric_limits<N> limits ;

    public :

      static N lowest () { return static_cast<N>(-limits::max ()) ; }
      static N highest () { return limits::max (); }
      static N smallest() { return limits::min (); }
  } ;

  template<class N>
  struct get_impl
  {
    typedef mpl::bool_< ::std::numeric_limits<N>::is_integer > is_int ;

    typedef Integral<N> impl_int ;
    typedef Float <N> impl_float ;

    typedef typename mpl::if_<is_int,impl_int,impl_float>::type type ;
  } ;

} } }
# 14 "/usr/local/include/boost/numeric/conversion/bounds.hpp" 2 3

namespace boost { namespace numeric
{

template<class N>
struct bounds : boundsdetail::get_impl<N>::type
{} ;

} }
# 18 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 2 3





namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<std::float_round_style, std::round_toward_zero> round2zero_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_to_nearest> round2nearest_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_infinity> round2inf_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_neg_infinity> round2neg_inf_c ;
# 40 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  template<class RoundStyle,class RoundToZero,class RoundToNearest,class RoundToInf,class RoundToNegInf>
  struct for_round_style
  {
    typedef ct_switch4<RoundStyle
                       , round2zero_c, round2nearest_c, round2inf_c
                       , RoundToZero , RoundToNearest , RoundToInf , RoundToNegInf
                      > selector ;

    typedef typename selector::type type ;
  } ;
# 81 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  struct non_applicable { typedef mpl::false_ do_apply ; } ;
  struct applicable { typedef mpl::true_ do_apply ; } ;
# 96 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
    template<class Traits>
    struct LT_LoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LT_Zero : applicable
    {
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(0) ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LE_PrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s <= static_cast<S>(bounds<T>::lowest()) - static_cast<S>(1.0)
                 ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LT_HalfPrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) - static_cast<S>(0.5)
                 ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GT_HiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s > static_cast<S>(bounds<T>::highest())
                 ? cPosOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GE_SuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(1.0)
                 ? cPosOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GT_HalfSuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(0.5)
                 ? cPosOverflow : cInRange ;
      }
    } ;
# 215 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
    template<class PredA, class PredB>
    struct applyBoth
    {
      typedef typename PredA::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        range_check_result r = PredA::apply(s) ;
        if ( r == cInRange )
          r = PredB::apply(s);
        return r ;
      }
    } ;

    template<class PredA, class PredB>
    struct combine
    {
      typedef applyBoth<PredA,PredB> Both ;
      typedef void NNone ;

      typedef typename PredA::do_apply do_applyA ;
      typedef typename PredB::do_apply do_applyB ;

      typedef typename for_both<do_applyA, do_applyB, Both, PredA, PredB, NNone>::type type ;
    } ;
# 262 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  template<class Traits>
  struct dummy_range_checker
  {
    typedef typename Traits::argument_type argument_type ;

    static range_check_result out_of_range ( argument_type ) { return cInRange ; }
    static void validate_range ( argument_type ) {}
  } ;
# 279 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  template<class Traits, class IsNegOverflow, class IsPosOverflow, class OverflowHandler>
  struct generic_range_checker
  {
    typedef OverflowHandler overflow_handler ;

    typedef typename Traits::argument_type argument_type ;

    static range_check_result out_of_range ( argument_type s )
    {
      typedef typename combine<IsNegOverflow,IsPosOverflow>::type Predicate ;

      return Predicate::apply(s);
    }

    static void validate_range ( argument_type s )
      { OverflowHandler()( out_of_range(s) ) ; }
  } ;
# 305 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  template<class Traits,class OverflowHandler>
  struct GetRC_Sig2Sig_or_Unsig2Unsig
  {
    typedef dummy_range_checker<Traits> Dummy ;

    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;

    typedef typename Traits::subranged subranged ;

    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Sig2Unsig
  {
    typedef LT_Zero<Traits> Pred1 ;
    typedef GT_HiT <Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ChoiceA ;

    typedef generic_range_checker<Traits,Pred1,non_applicable,OverflowHandler> ChoiceB ;

    typedef typename Traits::target_type T ;
    typedef typename Traits::source_type S ;

    typedef typename subranged_Unsig2Sig<S,T>::type oposite_subranged ;

    typedef typename mpl::not_<oposite_subranged>::type positively_subranged ;

    typedef typename mpl::if_<positively_subranged,ChoiceA,ChoiceB>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Unsig2Sig
  {
    typedef GT_HiT<Traits> Pred1 ;

    typedef generic_range_checker<Traits,non_applicable,Pred1,OverflowHandler> type ;
  } ;

  template<class Traits,class OverflowHandler>
  struct GetRC_Int2Int
  {
    typedef GetRC_Sig2Sig_or_Unsig2Unsig<Traits,OverflowHandler> Sig2SigQ ;
    typedef GetRC_Sig2Unsig <Traits,OverflowHandler> Sig2UnsigQ ;
    typedef GetRC_Unsig2Sig <Traits,OverflowHandler> Unsig2SigQ ;
    typedef Sig2SigQ Unsig2UnsigQ ;

    typedef typename Traits::sign_mixture sign_mixture ;

    typedef typename
      for_sign_mixture<sign_mixture,Sig2SigQ,Sig2UnsigQ,Unsig2SigQ,Unsig2UnsigQ>::type
        selector ;

    typedef typename selector::type type ;
  } ;

  template<class Traits>
  struct GetRC_Int2Float
  {
    typedef dummy_range_checker<Traits> type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_Float2Int
  {
    typedef LE_PrevLoT <Traits> Pred1 ;
    typedef GE_SuccHiT <Traits> Pred2 ;
    typedef LT_HalfPrevLoT<Traits> Pred3 ;
    typedef GT_HalfSuccHiT<Traits> Pred4 ;
    typedef GT_HiT <Traits> Pred5 ;
    typedef LT_LoT <Traits> Pred6 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ToZero ;
    typedef generic_range_checker<Traits,Pred3,Pred4,OverflowHandler> ToNearest ;
    typedef generic_range_checker<Traits,Pred1,Pred5,OverflowHandler> ToInf ;
    typedef generic_range_checker<Traits,Pred6,Pred2,OverflowHandler> ToNegInf ;

    typedef typename Float2IntRounder::round_style round_style ;

    typedef typename for_round_style<round_style,ToZero,ToNearest,ToInf,ToNegInf>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Float2Float
  {
    typedef dummy_range_checker<Traits> Dummy ;

    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;

    typedef typename Traits::subranged subranged ;

    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_BuiltIn2BuiltIn
  {
    typedef GetRC_Int2Int<Traits,OverflowHandler> Int2IntQ ;
    typedef GetRC_Int2Float<Traits> Int2FloatQ ;
    typedef GetRC_Float2Int<Traits,OverflowHandler,Float2IntRounder> Float2IntQ ;
    typedef GetRC_Float2Float<Traits,OverflowHandler> Float2FloatQ ;

    typedef typename Traits::int_float_mixture int_float_mixture ;

    typedef typename for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ>::type selector ;

    typedef typename selector::type type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC
  {
    typedef GetRC_BuiltIn2BuiltIn<Traits,OverflowHandler,Float2IntRounder> BuiltIn2BuiltInQ ;

    typedef dummy_range_checker<Traits> Dummy ;

    typedef mpl::identity<Dummy> DummyQ ;

    typedef typename Traits::udt_builtin_mixture udt_builtin_mixture ;

    typedef typename for_udt_builtin_mixture<udt_builtin_mixture,BuiltIn2BuiltInQ,DummyQ,DummyQ,DummyQ>::type selector ;

    typedef typename selector::type type ;
  } ;
# 452 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  template<class Traits>
  struct trivial_converter_impl : public dummy_range_checker<Traits>
  {
    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static result_type low_level_convert ( argument_type s ) { return s ; }
    static source_type nearbyint ( argument_type s ) { return s ; }
    static result_type convert ( argument_type s ) { return s ; }
  } ;





  template<class Traits,class RangeChecker,class RawConverter,class Float2IntRounder>
  struct rounding_converter : public RangeChecker
                             ,public Float2IntRounder
                             ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef Float2IntRounder Float2IntRounderBase ;
    typedef RawConverter RawConverterBase ;

    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      source_type s1 = Float2IntRounderBase::nearbyint(s);
      return RawConverterBase::low_level_convert(s1);
    }
  } ;





  template<class Traits,class RangeChecker,class RawConverter>
  struct non_rounding_converter : public RangeChecker
                                 ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef RawConverter RawConverterBase ;

    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static source_type nearbyint ( argument_type s ) { return s ; }

    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      return RawConverterBase::low_level_convert(s);
    }
  } ;
# 528 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
  template<class Traits,class OverflowHandler,class Float2IntRounder,class RawConverter, class UserRangeChecker>
  struct get_non_trivial_converter
  {
    typedef GetRC<Traits,OverflowHandler,Float2IntRounder> InternalRangeCheckerQ ;

    typedef is_same<UserRangeChecker,UseInternalRangeChecker> use_internal_RC ;

    typedef mpl::identity<UserRangeChecker> UserRangeCheckerQ ;

    typedef typename
      mpl::eval_if<use_internal_RC,InternalRangeCheckerQ,UserRangeCheckerQ>::type
        RangeChecker ;

    typedef non_rounding_converter<Traits,RangeChecker,RawConverter> NonRounding ;
    typedef rounding_converter<Traits,RangeChecker,RawConverter,Float2IntRounder> Rounding ;

    typedef mpl::identity<NonRounding> NonRoundingQ ;
    typedef mpl::identity<Rounding> RoundingQ ;

    typedef typename Traits::int_float_mixture int_float_mixture ;

    typedef typename
      for_int_float_mixture<int_float_mixture, NonRoundingQ, NonRoundingQ, RoundingQ, NonRoundingQ>::type
        selector ;

    typedef typename selector::type type ;
  } ;

  template< class Traits
           ,class OverflowHandler
           ,class Float2IntRounder
           ,class RawConverter
           ,class UserRangeChecker
          >
  struct get_converter_impl
  {
# 574 "/usr/local/include/boost/numeric/conversion/detail/converter.hpp" 3
    typedef trivial_converter_impl<Traits> Trivial ;
    typedef mpl::identity <Trivial> TrivialQ ;

    typedef get_non_trivial_converter< Traits
                                      ,OverflowHandler
                                      ,Float2IntRounder
                                      ,RawConverter
                                      ,UserRangeChecker
                                     > NonTrivialQ ;

    typedef typename Traits::trivial trivial ;

    typedef typename mpl::eval_if<trivial,TrivialQ,NonTrivialQ>::type type ;
  } ;

} } }
# 17 "/usr/local/include/boost/numeric/conversion/converter.hpp" 2 3

namespace boost { namespace numeric
{

template<class T,
         class S,
         class Traits = conversion_traits<T,S>,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc< typename Traits::source_type> ,
         class RawConverter = raw_converter<Traits>,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct converter : convdetail::get_converter_impl<Traits,
                                                  OverflowHandler,
                                                  Float2IntRounder,
                                                  RawConverter,
                                                  UserRangeChecker
                                                 >::type
{
  typedef Traits traits ;

  typedef typename Traits::argument_type argument_type ;
  typedef typename Traits::result_type result_type ;

  result_type operator() ( argument_type s ) const { return this->convert(s) ; }
} ;



template<class S,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc<S> ,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct make_converter_from
{
  template<class T,
           class Traits = conversion_traits<T,S>,
           class RawConverter = raw_converter<Traits>
          >
  struct to
  {
    typedef converter<T,S,Traits,OverflowHandler,Float2IntRounder,RawConverter,UserRangeChecker> type ;
  } ;

} ;

} }
# 34 "/usr/local/include/boost/numeric/conversion/cast.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/numeric_cast_traits.hpp" 1 3
# 14 "/usr/local/include/boost/numeric/conversion/numeric_cast_traits.hpp" 3
namespace boost { namespace numeric {

    template <typename Target, typename Source, typename EnableIf = void>
    struct numeric_cast_traits
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<Source> rounding_policy;
    };

}}


# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 28 "/usr/local/include/boost/numeric/conversion/numeric_cast_traits.hpp" 2 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 1 3
# 12 "/usr/local/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 3
# 1 "/usr/local/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp" 1 3
# 12 "/usr/local/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp" 3
namespace boost { namespace numeric {

    template <>
    struct numeric_cast_traits
        <
            char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };
}}
# 13 "/usr/local/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 2 3


# 1 "/usr/local/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp" 1 3
# 9 "/usr/local/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp" 3
namespace boost { namespace numeric {


    template <>
    struct numeric_cast_traits
        <
            char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::long_long_type
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::long_long_type
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::ulong_long_type
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::ulong_long_type
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };
}}
# 16 "/usr/local/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 2 3
# 29 "/usr/local/include/boost/numeric/conversion/numeric_cast_traits.hpp" 2 3
# 35 "/usr/local/include/boost/numeric/conversion/cast.hpp" 2 3

namespace boost
{
    template <typename Target, typename Source>
    inline Target numeric_cast( Source arg )
    {
        typedef numeric::conversion_traits<Target, Source> conv_traits;
        typedef numeric::numeric_cast_traits<Target, Source> cast_traits;
        typedef boost::numeric::converter
            <
                Target,
                Source,
                conv_traits,
                typename cast_traits::overflow_policy,
                typename cast_traits::rounding_policy,
                boost::numeric::raw_converter< conv_traits >,
                typename cast_traits::range_checking_policy
            > converter;
        return converter::convert(arg);
    }

    using numeric::bad_numeric_cast;
}
# 37 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 2 3

namespace boost { namespace detail {

template <class Source >
struct detect_precision_loss
{
    typedef Source source_type;
    typedef boost::numeric::Trunc<Source> Rounder;
    typedef typename conditional<
        boost::is_arithmetic<Source>::value, Source, Source const&
    >::type argument_type ;

    static inline source_type nearbyint(argument_type s, bool& is_ok) noexcept {
        const source_type near_int = Rounder::nearbyint(s);
        if (near_int && is_ok) {
            const source_type orig_div_round = s / near_int;
            const source_type eps = std::numeric_limits<source_type>::epsilon();

            is_ok = !((orig_div_round > 1 ? orig_div_round - 1 : 1 - orig_div_round) > eps);
        }

        return s;
    }

    typedef typename Rounder::round_style round_style;
};

template <typename Base, class Source>
struct fake_precision_loss: public Base
{
    typedef Source source_type ;
    typedef typename conditional<
        boost::is_arithmetic<Source>::value, Source, Source const&
    >::type argument_type ;

    static inline source_type nearbyint(argument_type s, bool& ) noexcept {
        return s;
    }
};

struct nothrow_overflow_handler
{
    inline bool operator() ( boost::numeric::range_check_result r ) const noexcept {
        return (r == boost::numeric::cInRange);
    }
};

template <typename Target, typename Source>
inline bool noexcept_numeric_convert(const Source& arg, Target& result) noexcept {
    typedef boost::numeric::converter<
            Target,
            Source,
            boost::numeric::conversion_traits<Target, Source >,
            nothrow_overflow_handler,
            detect_precision_loss<Source >
    > converter_orig_t;

    typedef typename boost::conditional<
        boost::is_base_of< detect_precision_loss<Source >, converter_orig_t >::value,
        converter_orig_t,
        fake_precision_loss<converter_orig_t, Source>
    >::type converter_t;

    bool res = nothrow_overflow_handler()(converter_t::out_of_range(arg));
    result = converter_t::low_level_convert(converter_t::nearbyint(arg, res));
    return res;
}

template <typename Target, typename Source>
struct lexical_cast_dynamic_num_not_ignoring_minus
{
    static inline bool try_convert(const Source &arg, Target& result) noexcept {
        return noexcept_numeric_convert<Target, Source >(arg, result);
    }
};

template <typename Target, typename Source>
struct lexical_cast_dynamic_num_ignoring_minus
{
    static inline bool try_convert(const Source &arg, Target& result) noexcept {
        typedef typename boost::conditional<
                boost::is_float<Source>::value,
                boost::type_identity<Source>,
                boost::make_unsigned<Source>
        >::type usource_lazy_t;
        typedef typename usource_lazy_t::type usource_t;

        if (arg < 0) {
            const bool res = noexcept_numeric_convert<Target, usource_t>(0u - arg, result);
            result = static_cast<Target>(0u - result);
            return res;
        } else {
            return noexcept_numeric_convert<Target, usource_t>(arg, result);
        }
    }
};
# 152 "/usr/local/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
template <typename Target, typename Source>
struct dynamic_num_converter_impl
{
    static inline bool try_convert(const Source &arg, Target& result) noexcept {
        typedef typename boost::conditional<
            boost::is_unsigned<Target>::value &&
            (boost::is_signed<Source>::value || boost::is_float<Source>::value) &&
            !(boost::is_same<Source, bool>::value) &&
            !(boost::is_same<Target, bool>::value),
            lexical_cast_dynamic_num_ignoring_minus<Target, Source>,
            lexical_cast_dynamic_num_not_ignoring_minus<Target, Source>
        >::type caster_type;

        return caster_type::try_convert(arg, result);
    }
};

}}
# 44 "/usr/local/include/boost/lexical_cast/try_lexical_convert.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
          
# 38 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
# 1 "/usr/local/include/boost/type_traits/has_left_shift.hpp" 1 3
# 43 "/usr/local/include/boost/type_traits/has_left_shift.hpp" 3
# 1 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 1 3
# 25 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
          
# 26 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 43 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_left_shift_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_left_shift_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_left_shift_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_left_shift_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_left_shift_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_left_shift_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() << std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_left_shift : public boost::binary_op_detail:: has_left_shift_ret_imp <T, U, Ret> {};
   template <class T, class U>
   struct has_left_shift<T, U, void> : public boost::binary_op_detail:: has_left_shift_void_imp <T, U> {};
   template <class T, class U>
   struct has_left_shift<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_left_shift_dc_imp <T, U> {};


}
# 44 "/usr/local/include/boost/type_traits/has_left_shift.hpp" 2 3
# 39 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3
# 1 "/usr/local/include/boost/type_traits/has_right_shift.hpp" 1 3
# 43 "/usr/local/include/boost/type_traits/has_right_shift.hpp" 3
# 1 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 1 3
# 25 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
          
# 26 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 43 "/usr/local/include/boost/type_traits/detail/has_binary_operator.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_right_shift_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_right_shift_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_right_shift_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_right_shift_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_right_shift_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_right_shift_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() >> std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_right_shift : public boost::binary_op_detail:: has_right_shift_ret_imp <T, U, Ret> {};
   template <class T, class U>
   struct has_right_shift<T, U, void> : public boost::binary_op_detail:: has_right_shift_void_imp <T, U> {};
   template <class T, class U>
   struct has_right_shift<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_right_shift_dc_imp <T, U> {};


}
# 44 "/usr/local/include/boost/type_traits/has_right_shift.hpp" 2 3
# 40 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3

# 1 "/usr/local/include/boost/detail/lcast_precision.hpp" 1 3
# 11 "/usr/local/include/boost/detail/lcast_precision.hpp" 3
# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 12 "/usr/local/include/boost/detail/lcast_precision.hpp" 2 3
# 36 "/usr/local/include/boost/detail/lcast_precision.hpp" 3
namespace boost { namespace detail {

class lcast_abstract_stub {};





template<class T>
struct lcast_precision
{



    typedef typename boost::conditional<
        boost::is_abstract<T>::value
      , std::numeric_limits<lcast_abstract_stub>
      , std::numeric_limits<T>
      >::type limits;


    static const bool use_default_precision = !limits::is_specialized || limits::is_exact

         ;

    static const bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0


         ;

    static const bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0


         ;

    static const std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max

         ;

    static const unsigned int precision_dec = limits::digits10 + 1U;

    static_assert(!is_specialized_dec || precision_dec <= streamsize_max + 0UL, "!is_specialized_dec || precision_dec <= streamsize_max + 0UL")

         ;

    static const unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL

         ;

    static_assert(!is_specialized_bin || (limits::digits + 0UL < (0x7fffffffffffffffL * 2UL + 1UL) / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL), "!is_specialized_bin || (limits::digits + 0UL < ULONG_MAX / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)")



         ;

    static const std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec : 6


         ;
};


template<class T>
inline std::streamsize lcast_get_precision(T* = 0)
{

    return lcast_precision<T>::value;
# 166 "/usr/local/include/boost/detail/lcast_precision.hpp" 3
}

template<class T>
inline void lcast_set_precision(std::ios_base& stream, T*)
{
    stream.precision(lcast_get_precision<T>());
}

template<class Source, class Target>
inline void lcast_set_precision(std::ios_base& stream, Source*, Target*)
{
    std::streamsize const s = lcast_get_precision(static_cast<Source*>(0));
    std::streamsize const t = lcast_get_precision(static_cast<Target*>(0));
    stream.precision(s > t ? s : t);
}

}}
# 42 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3

# 1 "/usr/local/include/boost/lexical_cast/detail/widest_char.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/widest_char.hpp" 3
          





namespace boost { namespace detail {

    template <typename TargetChar, typename SourceChar>
    struct widest_char {
        typedef typename boost::conditional<
            (sizeof(TargetChar) > sizeof(SourceChar))
            , TargetChar
            , SourceChar
        >::type type;
    };

}}
# 44 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3






# 1 "/usr/local/include/boost/array.hpp" 1 3
# 45 "/usr/local/include/boost/array.hpp" 3
# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 46 "/usr/local/include/boost/array.hpp" 2 3
# 58 "/usr/local/include/boost/array.hpp" 3
namespace boost {

    template<class T, std::size_t N>
    class array {
      public:
        T elems[N];

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return elems; }
        const_iterator begin() const { return elems; }
        const_iterator cbegin() const { return elems; }

        iterator end() { return elems+N; }
        const_iterator end() const { return elems+N; }
        const_iterator cend() const { return elems+N; }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 99 "/usr/local/include/boost/array.hpp" 3
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        const_reverse_iterator crbegin() const {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }
        const_reverse_iterator crend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type i)
        {
            return (static_cast <bool> ((i < N)&&("out of range")) ? void (0) : __assert_fail ("(i < N)&&(\"out of range\")", "/usr/local/include/boost/array.hpp", 118, __extension__ __PRETTY_FUNCTION__)), elems[i];
        }

                            const_reference operator[](size_type i) const
        {
            return (static_cast <bool> ((i < N)&&("out of range")) ? void (0) : __assert_fail ("(i < N)&&(\"out of range\")", "/usr/local/include/boost/array.hpp", 123, __extension__ __PRETTY_FUNCTION__)), elems[i];
        }


        reference at(size_type i) { return rangecheck(i), elems[i]; }
                            const_reference at(size_type i) const { return rangecheck(i), elems[i]; }


        reference front()
        {
            return elems[0];
        }

        constexpr const_reference front() const
        {
            return elems[0];
        }

        reference back()
        {
            return elems[N-1];
        }

        constexpr const_reference back() const
        {
            return elems[N-1];
        }


        static constexpr size_type size() { return N; }
        static constexpr bool empty() { return false; }
        static constexpr size_type max_size() { return N; }
        enum { static_size = N };


        void swap (array<T,N>& y) {
            for (size_type i = 0; i < N; ++i)
                boost::swap(elems[i],y.elems[i]);
        }


        const T* data() const { return elems; }
        T* data() { return elems; }


        T* c_array() { return elems; }


        template <typename T2>
        array<T,N>& operator= (const array<T2,N>& rhs) {
            std::copy(rhs.begin(),rhs.end(), begin());
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& value)
        {
            std::fill_n(begin(),size(),value);
        }


        static constexpr bool rangecheck (size_type i) {
            return i >= size() ? boost::throw_exception(std::out_of_range ("array<>: index out of range")), true : true;
        }

    };

    template< class T >
    class array< T, 0 > {

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return iterator( reinterpret_cast< T * >( this ) ); }
        const_iterator begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
        const_iterator cbegin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }

        iterator end() { return begin(); }
        const_iterator end() const { return begin(); }
        const_iterator cend() const { return cbegin(); }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 228 "/usr/local/include/boost/array.hpp" 3
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        const_reverse_iterator crbegin() const {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }
        const_reverse_iterator crend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type )
        {
            return failed_rangecheck();
        }

                            const_reference operator[](size_type ) const
        {
            return failed_rangecheck();
        }


        reference at(size_type ) { return failed_rangecheck(); }
                            const_reference at(size_type ) const { return failed_rangecheck(); }


        reference front()
        {
            return failed_rangecheck();
        }

        constexpr const_reference front() const
        {
            return failed_rangecheck();
        }

        reference back()
        {
            return failed_rangecheck();
        }

        constexpr const_reference back() const
        {
            return failed_rangecheck();
        }


        static constexpr size_type size() { return 0; }
        static constexpr bool empty() { return true; }
        static constexpr size_type max_size() { return 0; }
        enum { static_size = 0 };

        void swap (array<T,0>& ) {
        }


        const T* data() const { return 0; }
        T* data() { return 0; }


        T* c_array() { return 0; }


        template <typename T2>
        array<T,0>& operator= (const array<T2,0>& ) {
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& ) {}


        static reference failed_rangecheck () {
                std::out_of_range e("attempt to access element of an empty array");
                boost::throw_exception(e);






                static T placeholder;
                return placeholder;

            }
    };


    template<class T, std::size_t N>
    bool operator== (const array<T,N>& x, const array<T,N>& y) {
        return std::equal(x.begin(), x.end(), y.begin());
    }
    template<class T, std::size_t N>
    bool operator< (const array<T,N>& x, const array<T,N>& y) {
        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
    }
    template<class T, std::size_t N>
    bool operator!= (const array<T,N>& x, const array<T,N>& y) {
        return !(x==y);
    }
    template<class T, std::size_t N>
    bool operator> (const array<T,N>& x, const array<T,N>& y) {
        return y<x;
    }
    template<class T, std::size_t N>
    bool operator<= (const array<T,N>& x, const array<T,N>& y) {
        return !(y<x);
    }
    template<class T, std::size_t N>
    bool operator>= (const array<T,N>& x, const array<T,N>& y) {
        return !(x<y);
    }


    template<class T, std::size_t N>
    inline void swap (array<T,N>& x, array<T,N>& y) {
        x.swap(y);
    }
# 382 "/usr/local/include/boost/array.hpp" 3
    template <typename T, std::size_t N>
    T(&get_c_array(boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }


    template <typename T, std::size_t N>
    const T(&get_c_array(const boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }
# 414 "/usr/local/include/boost/array.hpp" 3
    template <class It> std::size_t hash_range(It, It);

    template<class T, std::size_t N>
    std::size_t hash_value(const array<T,N>& arr)
    {
        return boost::hash_range(arr.begin(), arr.end());
    }

   template <size_t Idx, typename T, size_t N>
   T &get(boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "boost::get<>(boost::array &) index out of range");
       return arr[Idx];
       }

   template <size_t Idx, typename T, size_t N>
   const T &get(const boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "boost::get<>(const boost::array &) index out of range");
       return arr[Idx];
       }

}



namespace std {
   template <size_t Idx, typename T, size_t N>
   T &get(boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "std::get<>(boost::array &) index out of range");
       return arr[Idx];
       }

   template <size_t Idx, typename T, size_t N>
   const T &get(const boost::array<T,N> &arr) noexcept {
       static_assert(Idx < N, "std::get<>(const boost::array &) index out of range");
       return arr[Idx];
       }
}
# 51 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3

# 1 "/usr/local/include/boost/container/container_fwd.hpp" 1 3
# 19 "/usr/local/include/boost/container/container_fwd.hpp" 3
         
# 61 "/usr/local/include/boost/container/container_fwd.hpp" 3
# 1 "/usr/local/include/boost/container/detail/std_fwd.hpp" 1 3
# 19 "/usr/local/include/boost/container/detail/std_fwd.hpp" 3
         






# 1 "/usr/local/include/boost/move/detail/std_ns_begin.hpp" 1 3
# 27 "/usr/local/include/boost/container/detail/std_fwd.hpp" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {

template<class T>
class allocator;

template<class T>
struct less;

template<class T>
struct equal_to;

template<class T1, class T2>
struct pair;

template<class T>
struct char_traits;

struct input_iterator_tag;
struct forward_iterator_tag;
struct bidirectional_iterator_tag;
struct random_access_iterator_tag;

template<class Container>
class insert_iterator;

struct allocator_arg_t;

struct piecewise_construct_t;

 }
# 1 "/usr/local/include/boost/move/detail/std_ns_end.hpp" 1 3
# 58 "/usr/local/include/boost/container/detail/std_fwd.hpp" 2 3
# 62 "/usr/local/include/boost/container/container_fwd.hpp" 2 3


namespace boost{
namespace intrusive{
namespace detail{

}}}

namespace boost{ namespace container{ namespace dtl{
   namespace bi = boost::intrusive;
   namespace bid = boost::intrusive::detail;
}}}

namespace boost{ namespace container{ namespace pmr{
   namespace bi = boost::intrusive;
   namespace bid = boost::intrusive::detail;
}}}
# 88 "/usr/local/include/boost/container/container_fwd.hpp" 3
namespace boost {
namespace container {



template<class T1, class T2>
struct pair;

template<class T>
class new_allocator;

template <class T
         ,class Allocator = void
         ,class Options = void>
class vector;

template <class T
         ,class Allocator = void >
class stable_vector;

template <class T, std::size_t Capacity>
class static_vector;

template < class T, std::size_t N
         , class Allocator = void >
class small_vector;

template <class T
         ,class Allocator = void >
class deque;

template <class T
         ,class Allocator = void >
class list;

template <class T
         ,class Allocator = void >
class slist;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void>
class set;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void >
class multiset;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void >
class map;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void >
class multimap;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_set;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_multiset;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_map;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_multimap;

template <class CharT
         ,class Traits = std::char_traits<CharT>
         ,class Allocator = void >
class basic_string;

typedef basic_string <char> string;
typedef basic_string<wchar_t> wstring;

static const std::size_t ADP_nodes_per_block = 256u;
static const std::size_t ADP_max_free_blocks = 2u;
static const std::size_t ADP_overhead_percent = 1u;
static const std::size_t ADP_only_alignment = 0u;

template < class T
         , std::size_t NodesPerBlock = ADP_nodes_per_block
         , std::size_t MaxFreeBlocks = ADP_max_free_blocks
         , std::size_t OverheadPercent = ADP_overhead_percent
         , unsigned Version = 2
         >
class adaptive_pool;

template < class T
         , unsigned Version = 2
         , unsigned int AllocationDisableMask = 0>
class allocator;

static const std::size_t NodeAlloc_nodes_per_block = 256u;

template
   < class T
   , std::size_t NodesPerBlock = NodeAlloc_nodes_per_block
   , std::size_t Version = 2>
class node_allocator;

namespace pmr {

class memory_resource;

template<class T>
class polymorphic_allocator;

class monotonic_buffer_resource;

struct pool_options;

template <class Allocator>
class resource_adaptor_imp;

class unsynchronized_pool_resource;

class synchronized_pool_resource;

}





struct ordered_range_t
{};



static const ordered_range_t ordered_range = ordered_range_t();



struct ordered_unique_range_t
   : public ordered_range_t
{};



static const ordered_unique_range_t ordered_unique_range = ordered_unique_range_t();



struct default_init_t
{};



static const default_init_t default_init = default_init_t();




struct value_init_t
{};



static const value_init_t value_init = value_init_t();

namespace container_detail_really_deep_namespace {



struct dummy
{
   dummy()
   {
      (void)ordered_range;
      (void)ordered_unique_range;
      (void)default_init;
   }
};

}




}}
# 53 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3

# 1 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
          
# 33 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 34 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 35 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3
# 43 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
# 1 "/usr/include/c++/7/locale" 1 3
# 36 "/usr/include/c++/7/locale" 3
       
# 37 "/usr/include/c++/7/locale" 3




# 1 "/usr/include/c++/7/bits/locale_facets_nonio.h" 1 3
# 37 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
       
# 38 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3

# 1 "/usr/include/c++/7/ctime" 1 3
# 39 "/usr/include/c++/7/ctime" 3
       
# 40 "/usr/include/c++/7/ctime" 3
# 58 "/usr/include/c++/7/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 40 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 206 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/time_members.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 345 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __cxx11 {
# 365 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 386 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 403 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 427 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 452 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 480 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 509 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 535 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
# 556 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
# 583 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
# 603 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 621 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 640 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 678 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 697 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 720 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
# 794 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 815 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 834 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 854 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 881 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
# 926 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
# 1021 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 1050 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 1063 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 1078 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1092 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1105 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1135 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1148 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1165 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1182 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1198 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1234 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1256 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1268 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1281 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1294 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1307 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1320 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1334 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1348 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1362 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
# 1465 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1487 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1517 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1548 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1572 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1584 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1596 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1618 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1639 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1682 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1717 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1741 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1753 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
# 1796 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1824 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1838 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1851 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1869 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1887 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1898 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1918 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1937 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 1 3
# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 3
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) throw ();



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) throw ();



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) throw ();
# 121 "/usr/include/libintl.h" 3 4
}
# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    messages<_CharT>::messages(size_t __refs)
    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
      _M_name_messages(_S_get_c_name())
    { }

  template<typename _CharT>
    messages<_CharT>::messages(__c_locale __cloc, const char* __s,
          size_t __refs)
    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_messages = __tmp;
 }
      else
 _M_name_messages = _S_get_c_name();


      _M_c_locale_messages = _S_clone_c_locale(__cloc);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


  template<typename _CharT>
    messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
    : messages<_CharT>(__refs)
    {
      if (this->_M_name_messages != locale::facet::_S_get_c_name())
 {
   delete [] this->_M_name_messages;
   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
     {
       const size_t __len = __builtin_strlen(__s) + 1;
       char* __tmp = new char[__len];
       __builtin_memcpy(__tmp, __s, __len);
       this->_M_name_messages = __tmp;
     }
   else
     this->_M_name_messages = locale::facet::_S_get_c_name();
 }

      if (__builtin_strcmp(__s, "C") != 0
   && __builtin_strcmp(__s, "POSIX") != 0)
 {
   this->_S_destroy_c_locale(this->_M_c_locale_messages);
   this->_S_create_c_locale(this->_M_c_locale_messages, __s);
 }
    }


  template<>
    typename messages<char>::catalog
    messages<char>::do_open(const basic_string<char>&,
       const locale&) const;

  template<>
    void
    messages<char>::do_close(catalog) const;


  template<>
    typename messages<wchar_t>::catalog
    messages<wchar_t>::do_open(const basic_string<char>&,
          const locale&) const;

  template<>
    void
    messages<wchar_t>::do_close(catalog) const;



}
# 2009 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/include/c++/7/bits/codecvt.h" 1 3
# 39 "/usr/include/c++/7/bits/codecvt.h" 3
       
# 40 "/usr/include/c++/7/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/include/c++/7/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/include/c++/7/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/include/c++/7/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/include/c++/7/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/include/c++/7/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "/usr/include/c++/7/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "/usr/include/c++/7/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 2012 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3

# 1 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 1 3
# 33 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
       
# 34 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 367 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 573 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 605 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __mem, __days1,
       7, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_wday = __mem;
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __mem, __days2,
       7, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_wday = __mem;
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __mem,
       __months1, 12, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem;
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __mem,
       __months2, 12, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem;
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 31, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mday = __mem;
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __mem, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __mem, 10, 31,
        2, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mday = __mem;
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 23, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_hour = __mem;
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_hour = __mem;
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 59, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_min = __mem;
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __mem, 0, 60, 2,



      __io, __tmperr);
    if (!__tmperr)
    __tm->tm_sec = __mem;
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 2014 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3
# 42 "/usr/include/c++/7/locale" 2 3

# 1 "/usr/include/c++/7/bits/locale_conv.h" 1 3
# 38 "/usr/include/c++/7/bits/locale_conv.h" 3
# 1 "/usr/include/c++/7/bits/stringfwd.h" 1 3
# 39 "/usr/include/c++/7/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/7/bits/allocator.h" 1 3
# 40 "/usr/include/c++/7/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/7/bits/codecvt.h" 1 3
# 41 "/usr/include/c++/7/bits/locale_conv.h" 2 3
# 1 "/usr/include/c++/7/bits/unique_ptr.h" 1 3
# 42 "/usr/include/c++/7/bits/locale_conv.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 {
   __count = __next - __first;
   return false;
 }

      if (__result == codecvt_base::noconv)
 {
   __outstr.assign(__first, __last);
   __count = __last - __first;
 }
      else
 {
   __outstr.resize(__outchars);
   __count = __next - __first;
 }

      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }



namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;







      explicit
      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
# 198 "/usr/include/c++/7/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;
# 336 "/usr/include/c++/7/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && !_M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes = 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
 return true;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
# 44 "/usr/include/c++/7/locale" 2 3
# 44 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3
# 61 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
# 1 "/usr/local/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
          


namespace boost
{
    namespace detail
    {
        template < typename Char >
        struct lcast_char_constants {


            static const Char zero = static_cast<Char>('0');
            static const Char minus = static_cast<Char>('-');
            static const Char plus = static_cast<Char>('+');
            static const Char lowercase_e = static_cast<Char>('e');
            static const Char capital_e = static_cast<Char>('E');
            static const Char c_decimal_separator = static_cast<Char>('.');
        };
    }
}
# 62 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
          


# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 27 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 2 3


# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 30 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 2 3
# 1 "/usr/include/c++/7/cstdio" 1 3
# 39 "/usr/include/c++/7/cstdio" 3
       
# 40 "/usr/include/c++/7/cstdio" 3
# 31 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 2 3
# 55 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
namespace boost
{
    namespace detail
    {
        template<class T>
        inline
        typename boost::make_unsigned<T>::type lcast_to_unsigned(const T value) noexcept {
            typedef typename boost::make_unsigned<T>::type result_type;
            return value < 0
                ? static_cast<result_type>(0u - static_cast<result_type>(value))
                : static_cast<result_type>(value);
        }
    }

    namespace detail
    {
        template <class Traits, class T, class CharT>
        class lcast_put_unsigned: boost::noncopyable {
            typedef typename Traits::int_type int_type;
            typename boost::conditional<
                    (sizeof(unsigned) > sizeof(T))
                    , unsigned
                    , T
            >::type m_value;
            CharT* m_finish;
            CharT const m_czero;
            int_type const m_zero;

        public:
            lcast_put_unsigned(const T n_param, CharT* finish) noexcept
                : m_value(n_param), m_finish(finish)
                , m_czero(lcast_char_constants<CharT>::zero), m_zero(Traits::to_int_type(m_czero))
            {

                static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");

            }

            CharT* convert() {

                std::locale loc;
                if (loc == std::locale::classic()) {
                    return main_convert_loop();
                }

                typedef std::numpunct<CharT> numpunct;
                numpunct const& np = std::use_facet< numpunct >(loc);
                std::string const grouping = np.grouping();
                std::string::size_type const grouping_size = grouping.size();

                if (!grouping_size || grouping[0] <= 0) {
                    return main_convert_loop();
                }



                static_assert(std::numeric_limits<T>::digits10 < 0x7f, "std::numeric_limits<T>::digits10 < CHAR_MAX");

                CharT const thousands_sep = np.thousands_sep();
                std::string::size_type group = 0;
                char last_grp_size = grouping[0];
                char left = last_grp_size;

                do {
                    if (left == 0) {
                        ++group;
                        if (group < grouping_size) {
                            char const grp_size = grouping[group];
                            last_grp_size = (grp_size <= 0 ? static_cast<char>(0x7f) : grp_size);
                        }

                        left = last_grp_size;
                        --m_finish;
                        Traits::assign(*m_finish, thousands_sep);
                    }

                    --left;
                } while (main_convert_iteration());

                return m_finish;



            }

        private:
            inline bool main_convert_iteration() noexcept {
                --m_finish;
                int_type const digit = static_cast<int_type>(m_value % 10U);
                Traits::assign(*m_finish, Traits::to_char_type(m_zero + digit));
                m_value /= 10;
                return !!m_value;
            }

            inline CharT* main_convert_loop() noexcept {
                while (main_convert_iteration());
                return m_finish;
            }
        };
    }

    namespace detail
    {
        template <class Traits, class T, class CharT>
        class lcast_ret_unsigned: boost::noncopyable {
            bool m_multiplier_overflowed;
            T m_multiplier;
            T& m_value;
            const CharT* const m_begin;
            const CharT* m_end;

        public:
            lcast_ret_unsigned(T& value, const CharT* const begin, const CharT* end) noexcept
                : m_multiplier_overflowed(false), m_multiplier(1), m_value(value), m_begin(begin), m_end(end)
            {

                static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");






                static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits are not specialized for integral type passed to boost::lexical_cast")

                 ;

            }

            inline bool convert() {
                CharT const czero = lcast_char_constants<CharT>::zero;
                --m_end;
                m_value = static_cast<T>(0);

                if (m_begin > m_end || *m_end < czero || *m_end >= czero + 10)
                    return false;
                m_value = static_cast<T>(*m_end - czero);
                --m_end;




                std::locale loc;
                if (loc == std::locale::classic()) {
                    return main_convert_loop();
                }

                typedef std::numpunct<CharT> numpunct;
                numpunct const& np = std::use_facet< numpunct >(loc);
                std::string const& grouping = np.grouping();
                std::string::size_type const grouping_size = grouping.size();




                if (!grouping_size || grouping[0] <= 0) {
                    return main_convert_loop();
                }

                unsigned char current_grouping = 0;
                CharT const thousands_sep = np.thousands_sep();
                char remained = static_cast<char>(grouping[current_grouping] - 1);

                for (;m_end >= m_begin; --m_end)
                {
                    if (remained) {
                        if (!main_convert_iteration()) {
                            return false;
                        }
                        --remained;
                    } else {
                        if ( !Traits::eq(*m_end, thousands_sep) )
                        {
# 239 "/usr/local/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                            return main_convert_loop();
                        } else {
                            if (m_begin == m_end) return false;
                            if (current_grouping < grouping_size - 1) ++current_grouping;
                            remained = grouping[current_grouping];
                        }
                    }
                }

                return true;

            }

        private:


            inline bool main_convert_iteration() noexcept {
                CharT const czero = lcast_char_constants<CharT>::zero;
                T const maxv = (std::numeric_limits<T>::max)();

                m_multiplier_overflowed = m_multiplier_overflowed || (maxv/10 < m_multiplier);
                m_multiplier = static_cast<T>(m_multiplier * 10);

                T const dig_value = static_cast<T>(*m_end - czero);
                T const new_sub_value = static_cast<T>(m_multiplier * dig_value);



                if (*m_end < czero || *m_end >= czero + 10
                    || (dig_value && (
                        m_multiplier_overflowed
                        || static_cast<T>(maxv / dig_value) < m_multiplier
                        || static_cast<T>(maxv - new_sub_value) < m_value
                    ))
                ) return false;

                m_value = static_cast<T>(m_value + new_sub_value);

                return true;
            }

            bool main_convert_loop() noexcept {
                for ( ; m_end >= m_begin; --m_end) {
                    if (!main_convert_iteration()) {
                        return false;
                    }
                }

                return true;
            }
        };
    }
}
# 63 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3
# 1 "/usr/local/include/boost/lexical_cast/detail/inf_nan.hpp" 1 3
# 23 "/usr/local/include/boost/lexical_cast/detail/inf_nan.hpp" 3
          







# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 32 "/usr/local/include/boost/lexical_cast/detail/inf_nan.hpp" 2 3


# 1 "/usr/local/include/boost/math/special_functions/sign.hpp" 1 3
# 16 "/usr/local/include/boost/math/special_functions/sign.hpp" 3
# 1 "/usr/local/include/boost/math/tools/config.hpp" 1 3
# 14 "/usr/local/include/boost/math/tools/config.hpp" 3
# 1 "/usr/local/include/boost/predef/architecture/x86.h" 1 3







# 1 "/usr/local/include/boost/predef/architecture/x86/32.h" 1 3
# 12 "/usr/local/include/boost/predef/architecture/x86/32.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/architecture/x86/32.h" 2 3
# 82 "/usr/local/include/boost/predef/architecture/x86/32.h" 3
# 1 "/usr/local/include/boost/predef/architecture/x86.h" 1 3







# 1 "/usr/local/include/boost/predef/architecture/x86/32.h" 1 3
# 87 "/usr/local/include/boost/predef/architecture/x86/32.h" 3

# 9 "/usr/local/include/boost/predef/architecture/x86.h" 2 3
# 1 "/usr/local/include/boost/predef/architecture/x86/64.h" 1 3
# 12 "/usr/local/include/boost/predef/architecture/x86/64.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/architecture/x86/64.h" 2 3
# 45 "/usr/local/include/boost/predef/architecture/x86/64.h" 3
# 1 "/usr/local/include/boost/predef/architecture/x86.h" 1 3







# 1 "/usr/local/include/boost/predef/architecture/x86/32.h" 1 3
# 87 "/usr/local/include/boost/predef/architecture/x86/32.h" 3

# 9 "/usr/local/include/boost/predef/architecture/x86.h" 2 3
# 1 "/usr/local/include/boost/predef/architecture/x86/64.h" 1 3
# 50 "/usr/local/include/boost/predef/architecture/x86/64.h" 3

# 10 "/usr/local/include/boost/predef/architecture/x86.h" 2 3
# 38 "/usr/local/include/boost/predef/architecture/x86.h" 3

# 46 "/usr/local/include/boost/predef/architecture/x86/64.h" 2 3





# 10 "/usr/local/include/boost/predef/architecture/x86.h" 2 3
# 38 "/usr/local/include/boost/predef/architecture/x86.h" 3

# 83 "/usr/local/include/boost/predef/architecture/x86/32.h" 2 3





# 9 "/usr/local/include/boost/predef/architecture/x86.h" 2 3
# 1 "/usr/local/include/boost/predef/architecture/x86/64.h" 1 3
# 50 "/usr/local/include/boost/predef/architecture/x86/64.h" 3

# 10 "/usr/local/include/boost/predef/architecture/x86.h" 2 3
# 38 "/usr/local/include/boost/predef/architecture/x86.h" 3

# 15 "/usr/local/include/boost/math/tools/config.hpp" 2 3
# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 16 "/usr/local/include/boost/math/tools/config.hpp" 2 3




# 1 "/usr/include/c++/7/climits" 1 3
# 39 "/usr/include/c++/7/climits" 3
       
# 40 "/usr/include/c++/7/climits" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 43 "/usr/include/c++/7/climits" 2 3
# 21 "/usr/local/include/boost/math/tools/config.hpp" 2 3
# 1 "/usr/include/c++/7/cfloat" 1 3
# 39 "/usr/include/c++/7/cfloat" 3
       
# 40 "/usr/include/c++/7/cfloat" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 1 3 4
# 43 "/usr/include/c++/7/cfloat" 2 3
# 22 "/usr/local/include/boost/math/tools/config.hpp" 2 3







# 1 "/usr/local/include/boost/math/tools/user.hpp" 1 3
# 30 "/usr/local/include/boost/math/tools/config.hpp" 2 3
# 335 "/usr/local/include/boost/math/tools/config.hpp" 3
namespace boost{ namespace math{
namespace tools
{

template <class T>
inline T max (T a, T b, T c) noexcept(std::is_floating_point<T>::value)
{
   return (std::max)((std::max)(a, b), c);
}

template <class T>
inline T max (T a, T b, T c, T d) noexcept(std::is_floating_point<T>::value)
{
   return (std::max)((std::max)(a, b), (std::max)(c, d));
}

}

template <class T>
void suppress_unused_variable_warning(const T&) noexcept(std::is_floating_point<T>::value)
{
}

namespace detail{

template <class T>
struct is_integer_for_rounding
{
   static const bool value = boost::is_integral<T>::value

      || (std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer)

      ;
};

}

}}
# 17 "/usr/local/include/boost/math/special_functions/sign.hpp" 2 3
# 1 "/usr/local/include/boost/math/special_functions/math_fwd.hpp" 1 3
# 26 "/usr/local/include/boost/math/special_functions/math_fwd.hpp" 3
# 1 "/usr/include/c++/7/vector" 1 3
# 58 "/usr/include/c++/7/vector" 3
       
# 59 "/usr/include/c++/7/vector" 3





# 1 "/usr/include/c++/7/bits/stl_vector.h" 1 3
# 68 "/usr/include/c++/7/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 215 "/usr/include/c++/7/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 227 "/usr/include/c++/7/bits/stl_vector.h" 3
      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 282 "/usr/include/c++/7/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 295 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 326 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 344 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 383 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 409 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 433 "/usr/include/c++/7/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 446 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 460 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 481 "/usr/include/c++/7/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 500 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 517 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 545 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 688 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 708 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 740 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 779 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 794 "/usr/include/c++/7/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 812 "/usr/include/c++/7/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 843 "/usr/include/c++/7/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 861 "/usr/include/c++/7/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 919 "/usr/include/c++/7/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 938 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 974 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 995 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1011 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1041 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1058 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1083 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1125 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1177 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1204 "/usr/include/c++/7/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1228 "/usr/include/c++/7/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1281 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
 {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1364 "/usr/include/c++/7/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1451 "/usr/include/c++/7/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
 pointer
 _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }
# 1586 "/usr/include/c++/7/bits/stl_vector.h" 3
    };
# 1599 "/usr/include/c++/7/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1616 "/usr/include/c++/7/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 65 "/usr/include/c++/7/vector" 2 3
# 1 "/usr/include/c++/7/bits/stl_bvector.h" 1 3
# 63 "/usr/include/c++/7/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_start = _M_impl._M_finish = _Bit_iterator();
     _M_impl._M_end_of_storage = _Bit_pointer();
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 542 "/usr/include/c++/7/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
# 613 "/usr/include/c++/7/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 679 "/usr/include/c++/7/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 775 "/usr/include/c++/7/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                          ,
     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x) noexcept
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
# 991 "/usr/include/c++/7/bits/stl_bvector.h" 3
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>



      void

      emplace_back(_Args&&... __args)
      {
 push_back(bool(__args...));



      }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      if (__n)
 {
   _Bit_pointer __q = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
   this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
 }
      else
 {
   this->_M_impl._M_end_of_storage = _Bit_pointer();
   this->_M_impl._M_start = iterator(0, 0);
 }
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/usr/include/c++/7/vector" 2 3



# 1 "/usr/include/c++/7/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/7/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1))
                 );
      ++this->_M_impl._M_finish;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (this->_M_impl._M_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

   ++__new_finish;

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__position.base(), this->_M_impl._M_finish,
      __new_finish, _M_get_Tp_allocator());
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }
      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      _M_deallocate(this->_M_impl._M_start,
      this->_M_impl._M_end_of_storage
      - this->_M_impl._M_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __destroy_from = pointer();
       try
  {
    std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
    __destroy_from = __new_start + __size;
    std::__uninitialized_move_if_noexcept_a(
        this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (__destroy_from)
      std::_Destroy(__destroy_from, __destroy_from + __n,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/usr/include/c++/7/vector" 2 3
# 27 "/usr/local/include/boost/math/special_functions/math_fwd.hpp" 2 3
# 1 "/usr/local/include/boost/math/special_functions/detail/round_fwd.hpp" 1 3
# 12 "/usr/local/include/boost/math/special_functions/detail/round_fwd.hpp" 3
# 1 "/usr/local/include/boost/math/tools/promotion.hpp" 1 3
# 42 "/usr/local/include/boost/math/tools/promotion.hpp" 3
namespace boost
{
  namespace math
  {
    namespace tools
    {
# 68 "/usr/local/include/boost/math/tools/promotion.hpp" 3
      template <class T>
      struct promote_arg
      {
        typedef typename mpl::if_<is_integral<T>, double, T>::type type;
      };


      template <> struct promote_arg<float> { typedef float type; };
      template <> struct promote_arg<double>{ typedef double type; };
      template <> struct promote_arg<long double> { typedef long double type; };
      template <> struct promote_arg<int> { typedef double type; };

      template <class T1, class T2>
      struct promote_args_2
      {

        typedef typename promote_arg<T1>::type T1P;
        typedef typename promote_arg<T2>::type T2P;

        typedef typename mpl::if_<
          typename mpl::and_<is_floating_point<T1P>, is_floating_point<T2P> >::type,

           typename mpl::if_< typename mpl::or_<is_same<__float128, T1P>, is_same<__float128, T2P> >::type,
            __float128,

             typename mpl::if_< typename mpl::or_<is_same<long double, T1P>, is_same<long double, T2P> >::type,
               long double,
               typename mpl::if_< typename mpl::or_<is_same<double, T1P>, is_same<double, T2P> >::type,
                  double,
                  float
             >::type

             >::type

             >::type,

          typename mpl::if_< typename mpl::and_<mpl::not_<is_floating_point<T2P> >, ::boost::is_convertible<T1P, T2P> >, T2P, T1P>::type>::type type;
      };


      template <> struct promote_args_2<float, float> { typedef float type; };
      template <> struct promote_args_2<double, double>{ typedef double type; };
      template <> struct promote_args_2<long double, long double> { typedef long double type; };
      template <> struct promote_args_2<int, int> { typedef double type; };
      template <> struct promote_args_2<int, float> { typedef double type; };
      template <> struct promote_args_2<float, int> { typedef double type; };
      template <> struct promote_args_2<int, double> { typedef double type; };
      template <> struct promote_args_2<double, int> { typedef double type; };
      template <> struct promote_args_2<int, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, int> { typedef long double type; };
      template <> struct promote_args_2<float, double> { typedef double type; };
      template <> struct promote_args_2<double, float> { typedef double type; };
      template <> struct promote_args_2<float, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, float> { typedef long double type; };
      template <> struct promote_args_2<double, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, double> { typedef long double type; };

      template <class T1, class T2=float, class T3=float, class T4=float, class T5=float, class T6=float>
      struct promote_args
      {
         typedef typename promote_args_2<
            typename remove_cv<T1>::type,
            typename promote_args_2<
               typename remove_cv<T2>::type,
               typename promote_args_2<
                  typename remove_cv<T3>::type,
                  typename promote_args_2<
                     typename remove_cv<T4>::type,
                     typename promote_args_2<
                        typename remove_cv<T5>::type, typename remove_cv<T6>::type
                     >::type
                  >::type
               >::type
            >::type
         >::type type;







      };






      template <class T1, class T2=float, class T3=float, class T4=float, class T5=float, class T6=float>
      struct promote_args_permissive
      {
         typedef typename promote_args_2<
            typename remove_cv<T1>::type,
            typename promote_args_2<
               typename remove_cv<T2>::type,
               typename promote_args_2<
                  typename remove_cv<T3>::type,
                  typename promote_args_2<
                     typename remove_cv<T4>::type,
                     typename promote_args_2<
                        typename remove_cv<T5>::type, typename remove_cv<T6>::type
                     >::type
                  >::type
               >::type
            >::type
         >::type type;
      };

    }
  }
}
# 13 "/usr/local/include/boost/math/special_functions/detail/round_fwd.hpp" 2 3





namespace boost
{
   namespace math
   {

   template <class T, class Policy>
   typename tools::promote_args<T>::type trunc(const T& v, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type trunc(const T& v);
   template <class T, class Policy>
   int itrunc(const T& v, const Policy& pol);
   template <class T>
   int itrunc(const T& v);
   template <class T, class Policy>
   long ltrunc(const T& v, const Policy& pol);
   template <class T>
   long ltrunc(const T& v);

   template <class T, class Policy>
   boost::long_long_type lltrunc(const T& v, const Policy& pol);
   template <class T>
   boost::long_long_type lltrunc(const T& v);

   template <class T, class Policy>
   typename tools::promote_args<T>::type round(const T& v, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type round(const T& v);
   template <class T, class Policy>
   int iround(const T& v, const Policy& pol);
   template <class T>
   int iround(const T& v);
   template <class T, class Policy>
   long lround(const T& v, const Policy& pol);
   template <class T>
   long lround(const T& v);

   template <class T, class Policy>
   boost::long_long_type llround(const T& v, const Policy& pol);
   template <class T>
   boost::long_long_type llround(const T& v);

   template <class T, class Policy>
   T modf(const T& v, T* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, T* ipart);
   template <class T, class Policy>
   T modf(const T& v, int* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, int* ipart);
   template <class T, class Policy>
   T modf(const T& v, long* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, long* ipart);

   template <class T, class Policy>
   T modf(const T& v, boost::long_long_type* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, boost::long_long_type* ipart);


   }
}
# 28 "/usr/local/include/boost/math/special_functions/math_fwd.hpp" 2 3

# 1 "/usr/local/include/boost/math/policies/policy.hpp" 1 3
# 9 "/usr/local/include/boost/math/policies/policy.hpp" 3
# 1 "/usr/local/include/boost/mpl/list.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/list.hpp" 3
# 1 "/usr/local/include/boost/mpl/limits/list.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/list.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/list.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/list20.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/list/list20.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/list10.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/list/list10.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/list0.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/list/list0.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/push_front.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/list/aux_/push_front.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/item.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/list/aux_/item.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/tag.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/list/aux_/tag.hpp" 3
namespace boost { namespace mpl { namespace aux {

struct list_tag;
struct l_iter_tag;

}}}
# 19 "/usr/local/include/boost/mpl/list/aux_/item.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Size
    , typename T
    , typename Next
    >
struct l_item
{




    typedef aux::list_tag tag;
    typedef l_item type;

    typedef Size size;
    typedef T item;
    typedef Next next;
};

struct l_end
{



    typedef aux::list_tag tag;
    typedef l_end type;
    typedef long_<0> size;
};

}}
# 20 "/usr/local/include/boost/mpl/list/aux_/push_front.hpp" 2 3


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::list_tag >
{
    template< typename List, typename T > struct apply
    {
        typedef l_item<
              typename next<typename List::size>::type
            , T
            , typename List::type
            > type;
    };
};

}}
# 20 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/pop_front.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/list/aux_/pop_front.hpp" 3
namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename mpl::next<List>::type type;
    };
};

}}
# 21 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/push_back.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/list/aux_/push_back.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct has_push_back_impl;

template<>
struct has_push_back_impl< aux::list_tag >
{
    template< typename Seq > struct apply
        : false_
    {
    };
};

}}
# 22 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/front.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/list/aux_/front.hpp" 3
namespace boost { namespace mpl {

template<>
struct front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename List::item type;
    };
};

}}
# 23 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/clear.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/list/aux_/clear.hpp" 3
namespace boost { namespace mpl {

template<>
struct clear_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_end type;
    };
};

}}
# 24 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/O1_size.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/list/aux_/O1_size.hpp" 3
namespace boost { namespace mpl {

template<>
struct O1_size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 25 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/size.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/list/aux_/size.hpp" 3
namespace boost { namespace mpl {

template<>
struct size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 26 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/empty.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/list/aux_/empty.hpp" 3
namespace boost { namespace mpl {

template<>
struct empty_impl< aux::list_tag >
{
    template< typename List > struct apply
        : not_<typename List::size>
    {
    };
};

}}
# 27 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/list/aux_/begin_end.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/list/aux_/begin_end.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/iterator.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/list/aux_/iterator.hpp" 3
namespace boost { namespace mpl {



template< typename Node >
struct l_iter
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;
};

template< typename Node >
struct deref< l_iter<Node> >
{
    typedef typename Node::item type;
};

template< typename Node >
struct next< l_iter<Node> >
{
    typedef l_iter< typename Node::next > type;
};
# 62 "/usr/local/include/boost/mpl/list/aux_/iterator.hpp" 3
template<> struct l_iter<l_end>
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;




};

template< typename T1 , typename Tag > struct lambda< l_iter< T1 > , Tag , int_<1> > { typedef false_ is_le; typedef l_iter< T1 > result_; typedef result_ type; };

}}
# 19 "/usr/local/include/boost/mpl/list/aux_/begin_end.hpp" 2 3



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_iter<typename List::type> type;
    };
};

template<>
struct end_impl< aux::list_tag >
{
    template< typename > struct apply
    {
        typedef l_iter<l_end> type;
    };
};

}}
# 28 "/usr/local/include/boost/mpl/list/list0.hpp" 2 3


namespace boost { namespace mpl {

template< typename Dummy = na > struct list0;

template<> struct list0<na>
    : l_end
{
    typedef l_end type;
};

}}
# 19 "/usr/local/include/boost/mpl/list/list10.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/list/list10.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1 3
# 30 "/usr/local/include/boost/mpl/list/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0
    >
struct list1
    : l_item<
          long_<1>
        , T0
        , l_end
        >
{
    typedef list1 type;
};

template<
      typename T0, typename T1
    >
struct list2
    : l_item<
          long_<2>
        , T0
        , list1<T1>
        >
{
    typedef list2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list3
    : l_item<
          long_<3>
        , T0
        , list2< T1,T2 >
        >
{
    typedef list3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list4
    : l_item<
          long_<4>
        , T0
        , list3< T1,T2,T3 >
        >
{
    typedef list4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list5
    : l_item<
          long_<5>
        , T0
        , list4< T1,T2,T3,T4 >
        >
{
    typedef list5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list6
    : l_item<
          long_<6>
        , T0
        , list5< T1,T2,T3,T4,T5 >
        >
{
    typedef list6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list7
    : l_item<
          long_<7>
        , T0
        , list6< T1,T2,T3,T4,T5,T6 >
        >
{
    typedef list7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list8
    : l_item<
          long_<8>
        , T0
        , list7< T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef list8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list9
    : l_item<
          long_<9>
        , T0
        , list8< T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef list9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list10
    : l_item<
          long_<10>
        , T0
        , list9< T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef list10 type;
};

}}
# 31 "/usr/local/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/list/list10.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/list/list20.hpp" 2 3
# 27 "/usr/local/include/boost/mpl/list/list20.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1 3
# 30 "/usr/local/include/boost/mpl/list/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list11
    : l_item<
          long_<11>
        , T0
        , list10< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef list11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list12
    : l_item<
          long_<12>
        , T0
        , list11< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef list12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list13
    : l_item<
          long_<13>
        , T0
        , list12< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef list13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list14
    : l_item<
          long_<14>
        , T0
        , list13< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef list14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list15
    : l_item<
          long_<15>
        , T0
        , list14< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef list15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list16
    : l_item<
          long_<16>
        , T0
        , list15< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef list16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list17
    : l_item<
          long_<17>
        , T0
        , list16< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef list17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list18
    : l_item<
          long_<18>
        , T0
        , list17< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef list18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list19
    : l_item<
          long_<19>
        , T0
        , list18< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef list19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list20
    : l_item<
          long_<20>
        , T0
        , list19< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef list20 type;
};

}}
# 31 "/usr/local/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/list/list20.hpp" 2 3
# 37 "/usr/local/include/boost/mpl/list.hpp" 2 3
# 46 "/usr/local/include/boost/mpl/list.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct list;

template<

    >
struct list<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list0< >
{
    typedef list0< >::type type;
};

template<
      typename T0
    >
struct list<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list1<T0>
{
    typedef typename list1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct list<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list2< T0,T1 >
{
    typedef typename list2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list3< T0,T1,T2 >
{
    typedef typename list3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list4< T0,T1,T2,T3 >
{
    typedef typename list4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list5< T0,T1,T2,T3,T4 >
{
    typedef typename list5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename list6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename list7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename list8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : list15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename list15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : list16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename list16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : list17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename list17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : list18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename list18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : list19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename list19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list
    : list20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename list20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 47 "/usr/local/include/boost/mpl/list.hpp" 2 3
# 10 "/usr/local/include/boost/math/policies/policy.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/contains.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/contains.hpp" 3
# 1 "/usr/local/include/boost/mpl/contains_fwd.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/contains_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct contains_impl;
template< typename Sequence, typename T > struct contains;

}}
# 19 "/usr/local/include/boost/mpl/contains.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/aux_/contains_impl.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/contains_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/find.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/find.hpp" 3
# 1 "/usr/local/include/boost/mpl/find_if.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/find_if.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/find_if_pred.hpp" 1 3
# 14 "/usr/local/include/boost/mpl/aux_/find_if_pred.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/iter_apply.hpp" 1 3
# 17 "/usr/local/include/boost/mpl/aux_/iter_apply.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/iter_apply.hpp" 2 3


namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Iterator
    >
struct iter_apply1
    : apply1< F,typename deref<Iterator>::type >
{
};

template<
      typename F
    , typename Iterator1
    , typename Iterator2
    >
struct iter_apply2
    : apply2<
          F
        , typename deref<Iterator1>::type
        , typename deref<Iterator2>::type
        >
{
};

}}}
# 15 "/usr/local/include/boost/mpl/aux_/find_if_pred.hpp" 2 3


namespace boost { namespace mpl { namespace aux {

template< typename Predicate >
struct find_if_pred
{
    template< typename Iterator >
    struct apply
    {
        typedef not_< aux::iter_apply1<Predicate,Iterator> > type;
    };
};

}}}
# 18 "/usr/local/include/boost/mpl/find_if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/arg.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/find_if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/iter_fold_if.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/iter_fold_if.hpp" 3
# 1 "/usr/local/include/boost/mpl/logical.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/iter_fold_if.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/pair.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/pair.hpp" 3
namespace boost { namespace mpl {

template<
      typename T1 = na
    , typename T2 = na
    >
struct pair
{
    typedef pair type;
    typedef T1 first;
    typedef T2 second;

   
};

template<
      typename P = na
    >
struct first
{

    typedef typename P::first type;



   
};

template<
      typename P = na
    >
struct second
{

    typedef typename P::second type;



   
};


template<> struct pair< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pair< T1 , T2 > { }; }; template< typename Tag > struct lambda< pair< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef pair< na , na > result_; typedef pair< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< pair< T1 , T2 > > : int_<2> { }; template<> struct template_arity< pair< na , na > > : int_<-1> { }; }
template<> struct first< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : first< T1 > { }; }; template< typename Tag > struct lambda< first< na > , Tag , int_<-1> > { typedef false_ is_le; typedef first< na > result_; typedef first< na > type; }; namespace aux { template< typename T1 > struct template_arity< first< T1 > > : int_<1> { }; template<> struct template_arity< first< na > > : int_<-1> { }; }
template<> struct second< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : second< T1 > { }; }; template< typename Tag > struct lambda< second< na > , Tag , int_<-1> > { typedef false_ is_le; typedef second< na > result_; typedef second< na > type; }; namespace aux { template< typename T1 > struct template_arity< second< T1 > > : int_<1> { }; template<> struct template_arity< second< na > > : int_<-1> { }; }

}}
# 24 "/usr/local/include/boost/mpl/iter_fold_if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/iter_fold_if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2 3
# 32 "/usr/local/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 1 3
# 13 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename Iterator, typename State >
struct iter_fold_if_null_step
{
    typedef State state;
    typedef Iterator iterator;
};

template< bool >
struct iter_fold_if_step_impl
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef typename apply2< StateOp,State,Iterator >::type state;
        typedef typename IteratorOp::type iterator;
    };
};

template<>
struct iter_fold_if_step_impl<false>
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef State state;
        typedef Iterator iterator;
    };
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename Predicate
    >
struct iter_fold_if_forward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,ForwardOp, mpl::next<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename BackwardOp
    , typename Predicate
    >
struct iter_fold_if_backward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,BackwardOp, identity<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename ForwardPredicate
    , typename BackwardOp
    , typename BackwardPredicate
    >
struct iter_fold_if_impl
{
 private:
    typedef iter_fold_if_null_step< Iterator,State > forward_step0;
    typedef iter_fold_if_forward_step< typename forward_step0::iterator, typename forward_step0::state, ForwardOp, ForwardPredicate > forward_step1;
    typedef iter_fold_if_forward_step< typename forward_step1::iterator, typename forward_step1::state, ForwardOp, ForwardPredicate > forward_step2;
    typedef iter_fold_if_forward_step< typename forward_step2::iterator, typename forward_step2::state, ForwardOp, ForwardPredicate > forward_step3;
    typedef iter_fold_if_forward_step< typename forward_step3::iterator, typename forward_step3::state, ForwardOp, ForwardPredicate > forward_step4;


    typedef typename if_<
          typename forward_step4::not_last
        , iter_fold_if_impl<
              typename forward_step4::iterator
            , typename forward_step4::state
            , ForwardOp
            , ForwardPredicate
            , BackwardOp
            , BackwardPredicate
            >
        , iter_fold_if_null_step<
              typename forward_step4::iterator
            , typename forward_step4::state
            >
        >::type backward_step4;

    typedef iter_fold_if_backward_step< typename forward_step3::iterator, typename backward_step4::state, BackwardOp, BackwardPredicate > backward_step3;
    typedef iter_fold_if_backward_step< typename forward_step2::iterator, typename backward_step3::state, BackwardOp, BackwardPredicate > backward_step2;
    typedef iter_fold_if_backward_step< typename forward_step1::iterator, typename backward_step2::state, BackwardOp, BackwardPredicate > backward_step1;
    typedef iter_fold_if_backward_step< typename forward_step0::iterator, typename backward_step1::state, BackwardOp, BackwardPredicate > backward_step0;


 public:
    typedef typename backward_step0::state state;
    typedef typename backward_step4::iterator iterator;
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 33 "/usr/local/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/iter_fold_if.hpp" 2 3







namespace boost { namespace mpl {

namespace aux {

template< typename Predicate, typename LastIterator >
struct iter_fold_if_pred
{
    template< typename State, typename Iterator > struct apply

        : and_<
              not_< is_same<Iterator,LastIterator> >
            , apply1<Predicate,Iterator>
            >
    {







    };
};

}

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    , typename ForwardPredicate = na
    , typename BackwardOp = na
    , typename BackwardPredicate = na
    >
struct iter_fold_if
{

    typedef typename begin<Sequence>::type first_;
    typedef typename end<Sequence>::type last_;

    typedef typename eval_if<
          is_na<BackwardPredicate>
        , if_< is_na<BackwardOp>, always<false_>, always<true_> >
        , identity<BackwardPredicate>
        >::type backward_pred_;



    struct result_ :



        aux::iter_fold_if_impl<
          first_
        , State
        , ForwardOp
        , protect< aux::iter_fold_if_pred< ForwardPredicate,last_ > >
        , BackwardOp
        , backward_pred_
        >

    { };




public:

    typedef pair<
          typename result_::state
        , typename result_::iterator
        > type;

   




};

template<> struct iter_fold_if< na , na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct apply : iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > { }; }; template< typename Tag > struct lambda< iter_fold_if< na , na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold_if< na , na , na , na , na , na > result_; typedef iter_fold_if< na , na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > > : int_<6> { }; template<> struct template_arity< iter_fold_if< na , na , na , na , na , na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/find_if.hpp" 2 3




namespace boost { namespace mpl {



template<
      typename Sequence = na
    , typename Predicate = na
    >
struct find_if
{
    typedef typename iter_fold_if<
          Sequence
        , void
        , mpl::arg<1>
        , protect< aux::find_if_pred<Predicate> >
        >::type result_;

    typedef typename second<result_>::type type;

   
};

template<> struct find_if< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find_if< T1 , T2 > { }; }; template< typename Tag > struct lambda< find_if< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find_if< na , na > result_; typedef find_if< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find_if< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find_if< na , na > > : int_<-1> { }; }

}}
# 18 "/usr/local/include/boost/mpl/find.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/same_as.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/same_as.hpp" 3
namespace boost { namespace mpl {

template< typename T1 >
struct same_as
{
    template< typename T2 > struct apply

        : is_same<T1,T2>
    {




    };
};

template< typename T1 >
struct not_same_as
{
    template< typename T2 > struct apply

        : not_< is_same<T1,T2> >
    {




    };
};

}}
# 19 "/usr/local/include/boost/mpl/find.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct find
    : find_if< Sequence,same_as<T> >
{
   
};

template<> struct find< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find< T1 , T2 > { }; }; template< typename Tag > struct lambda< find< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find< na , na > result_; typedef find< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find< na , na > > : int_<-1> { }; }

}}
# 21 "/usr/local/include/boost/mpl/aux_/contains_impl.hpp" 2 3







namespace boost { namespace mpl {

template< typename Tag >
struct contains_impl
{
    template< typename Sequence, typename T > struct apply

        : not_< is_same<
              typename find<Sequence,T>::type
            , typename end<Sequence>::type
            > >
    {
# 54 "/usr/local/include/boost/mpl/aux_/contains_impl.hpp" 3
    };
};

 template<> struct contains_impl<non_sequence_tag> {};

}}
# 21 "/usr/local/include/boost/mpl/contains.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct contains
    : contains_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};

template<> struct contains< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : contains< T1 , T2 > { }; }; template< typename Tag > struct lambda< contains< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef contains< na , na > result_; typedef contains< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< contains< T1 , T2 > > : int_<2> { }; template<> struct template_arity< contains< na , na > > : int_<-1> { }; }

}}
# 11 "/usr/local/include/boost/math/policies/policy.hpp" 2 3


# 1 "/usr/local/include/boost/mpl/remove_if.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/remove_if.hpp" 3
# 1 "/usr/local/include/boost/mpl/fold.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/fold.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/fold_impl.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/aux_/fold_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/fold_impl.hpp" 2 3
# 34 "/usr/local/include/boost/mpl/aux_/fold_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp" 3
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, state3, typename deref<iter3>::type >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl
{
    typedef fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,First,Last,State,ForwardOp >
    : fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/usr/local/include/boost/mpl/aux_/fold_impl.hpp" 2 3
# 21 "/usr/local/include/boost/mpl/fold.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct fold
{
    typedef typename aux::fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , ForwardOp
        >::state type;

   
};

template<> struct fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef fold< na , na , na > result_; typedef fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< fold< na , na , na > > : int_<-1> { }; }

}}
# 19 "/usr/local/include/boost/mpl/remove_if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/reverse_fold.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/reverse_fold.hpp" 3
# 1 "/usr/local/include/boost/mpl/arg.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/reverse_fold.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/reverse_fold_impl.hpp" 1 3
# 20 "/usr/local/include/boost/mpl/aux_/reverse_fold_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/reverse_fold_impl.hpp" 2 3
# 35 "/usr/local/include/boost/mpl/aux_/reverse_fold_impl.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp" 3
namespace boost { namespace mpl { namespace aux {



template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 0,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef fwd_state0 bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef fwd_state1 bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 2,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef fwd_state2 bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 3,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef fwd_state3 bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 4,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef fwd_state4 bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter4 iterator;
};

template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef reverse_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , iter4
        , Last
        , fwd_state4
        , BackwardOp
        , ForwardOp
        > nested_chunk;

    typedef typename nested_chunk::state bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef typename nested_chunk::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef reverse_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , BackwardOp
        , ForwardOp
        > nested_step;

    typedef typename apply2<
          BackwardOp
        , typename nested_step::state
        , typename deref<First>::type
        >::type state;

    typedef typename nested_step::iterator iterator;
};

template<
      typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,Last,Last,State,BackwardOp,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/reverse_fold_impl.hpp" 2 3
# 22 "/usr/local/include/boost/mpl/reverse_fold.hpp" 2 3


namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename BackwardOp = na
    , typename ForwardOp = arg<1>
    >
struct reverse_fold
{
    typedef typename aux::reverse_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , BackwardOp
        , ForwardOp
        >::state type;

   
};

template<> struct reverse_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_fold< na , na , na > result_; typedef reverse_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_fold< na , na , na > > : int_<-1> { }; }

}}
# 20 "/usr/local/include/boost/mpl/remove_if.hpp" 2 3




# 1 "/usr/local/include/boost/mpl/apply.hpp" 1 3
# 25 "/usr/local/include/boost/mpl/remove_if.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/aux_/inserter_algorithm.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/aux_/inserter_algorithm.hpp" 3
# 1 "/usr/local/include/boost/mpl/back_inserter.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/back_inserter.hpp" 3
# 1 "/usr/local/include/boost/mpl/push_back.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/push_back.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/push_back_impl.hpp" 1 3
# 26 "/usr/local/include/boost/mpl/aux_/push_back_impl.hpp" 3
namespace boost { namespace mpl {

struct has_push_back_arg {};



template< typename Tag >
struct push_back_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST44 : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } } mpl_assert_arg44; enum { mpl_assertion_in_line_44 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_back_arg >::value ))>( mpl_assert_arg44::assert_arg() ) ) }



             ;
    };
};

template< typename Tag >
struct has_push_back_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_back< Seq, has_push_back_arg > >
    {







    };
};

 template<> struct push_back_impl<non_sequence_tag> {};
 template<> struct has_push_back_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/push_back.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_back
    : push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};


template<
      typename Sequence = na
    >
struct has_push_back
    : has_push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};


template<> struct push_back< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_back< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_back< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_back< na , na > result_; typedef push_back< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_back< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_back< na , na > > : int_<-1> { }; }
template<> struct has_push_back< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_back< T1 > { }; }; template< typename Tag > struct lambda< has_push_back< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_back< na > result_; typedef has_push_back< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_back< T1 > > : int_<1> { }; template<> struct template_arity< has_push_back< na > > : int_<-1> { }; }

}}
# 19 "/usr/local/include/boost/mpl/back_inserter.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/inserter.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/inserter.hpp" 3
namespace boost { namespace mpl {

template<
      typename Sequence
    , typename Operation
    >
struct inserter
{
    typedef Sequence state;
    typedef Operation operation;
};

}}
# 20 "/usr/local/include/boost/mpl/back_inserter.hpp" 2 3

namespace boost {
namespace mpl {

template<
      typename Sequence
    >
struct back_inserter
    : inserter< Sequence,push_back<> >
{
};

}}
# 19 "/usr/local/include/boost/mpl/aux_/inserter_algorithm.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/front_inserter.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/front_inserter.hpp" 3
namespace boost { namespace mpl {

template<
      typename Sequence
    >
struct front_inserter
    : inserter< Sequence,push_front<> >
{
};

}}
# 20 "/usr/local/include/boost/mpl/aux_/inserter_algorithm.hpp" 2 3




# 1 "/usr/local/include/boost/mpl/clear.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/clear.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/clear_impl.hpp" 1 3
# 21 "/usr/local/include/boost/mpl/aux_/clear_impl.hpp" 3
namespace boost { namespace mpl {



template< typename Tag >
struct clear_impl
{
    template< typename Sequence > struct apply;
};

 template<> struct clear_impl<non_sequence_tag> {};

}}
# 19 "/usr/local/include/boost/mpl/clear.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct clear
    : clear_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct clear< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : clear< T1 > { }; }; template< typename Tag > struct lambda< clear< na > , Tag , int_<-1> > { typedef false_ is_le; typedef clear< na > result_; typedef clear< na > type; }; namespace aux { template< typename T1 > struct template_arity< clear< T1 > > : int_<1> { }; template<> struct template_arity< clear< na > > : int_<-1> { }; }

}}
# 25 "/usr/local/include/boost/mpl/aux_/inserter_algorithm.hpp" 2 3
# 26 "/usr/local/include/boost/mpl/remove_if.hpp" 2 3

namespace boost { namespace mpl {

namespace aux {

template< typename Pred, typename InsertOp > struct remove_if_helper
{
    template< typename Sequence, typename U > struct apply
    {
        typedef typename eval_if<
              typename apply1<Pred,U>::type
            , identity<Sequence>
            , apply2<InsertOp,Sequence,U>
            >::type type;
    };
};

template<
      typename Sequence
    , typename Predicate
    , typename Inserter
    >
struct remove_if_impl
    : fold<
          Sequence
        , typename Inserter::state
        , protect< aux::remove_if_helper<
              typename lambda<Predicate>::type
            , typename Inserter::operation
            > >
        >
{
};

template<
      typename Sequence
    , typename Predicate
    , typename Inserter
    >
struct reverse_remove_if_impl
    : reverse_fold<
          Sequence
        , typename Inserter::state
        , protect< aux::remove_if_helper<
              typename lambda<Predicate>::type
            , typename Inserter::operation
            > >
        >
{
};

}

 template< typename P1 = na , typename P2 = na , typename P3 = na > struct remove_if : aux::remove_if_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct remove_if< P1 , P2,na > : if_< has_push_back< typename clear<P1>::type> , aux::remove_if_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::reverse_remove_if_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template< typename P1 = na , typename P2 = na , typename P3 = na > struct reverse_remove_if : aux::reverse_remove_if_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct reverse_remove_if< P1 , P2,na > : if_< has_push_back<P1> , aux::reverse_remove_if_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::remove_if_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template<> struct remove_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : remove_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< remove_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef remove_if< na , na , na > result_; typedef remove_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< remove_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< remove_if< na , na , na > > : int_<-1> { }; } template<> struct reverse_remove_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_remove_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_remove_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_remove_if< na , na , na > result_; typedef reverse_remove_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_remove_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_remove_if< na , na , na > > : int_<-1> { }; }

}}
# 14 "/usr/local/include/boost/math/policies/policy.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/vector.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/vector.hpp" 3
# 1 "/usr/local/include/boost/mpl/limits/vector.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/vector.hpp" 2 3
# 46 "/usr/local/include/boost/mpl/vector.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct vector;

template<

    >
struct vector<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector0< >
{
    typedef vector0< >::type type;
};

template<
      typename T0
    >
struct vector<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector1<T0>
{
    typedef typename vector1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct vector<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector2< T0,T1 >
{
    typedef typename vector2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector3< T0,T1,T2 >
{
    typedef typename vector3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector4< T0,T1,T2,T3 >
{
    typedef typename vector4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector5< T0,T1,T2,T3,T4 >
{
    typedef typename vector5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename vector6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename vector7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename vector8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : vector15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : vector16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : vector17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : vector18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : vector19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector
    : vector20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename vector20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 47 "/usr/local/include/boost/mpl/vector.hpp" 2 3
# 15 "/usr/local/include/boost/math/policies/policy.hpp" 2 3



# 1 "/usr/local/include/boost/mpl/comparison.hpp" 1 3
# 18 "/usr/local/include/boost/mpl/comparison.hpp" 3
# 1 "/usr/local/include/boost/mpl/not_equal_to.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/not_equal_to.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct not_equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< not_equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< not_equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct not_equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct not_equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct not_equal_to

    : not_equal_to_impl<
          typename not_equal_to_tag<N1>::type
        , typename not_equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct not_equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< not_equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_equal_to< na , na > result_; typedef not_equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< not_equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< not_equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct not_equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value != N2::value ) >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/not_equal_to.hpp" 2 3
# 19 "/usr/local/include/boost/mpl/comparison.hpp" 2 3

# 1 "/usr/local/include/boost/mpl/greater.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/greater.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater

    : greater_impl<
          typename greater_tag<N1>::type
        , typename greater_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater< na , na > result_; typedef greater< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value > N2::value ) >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/greater.hpp" 2 3
# 21 "/usr/local/include/boost/mpl/comparison.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/less_equal.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/less_equal.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less_equal

    : less_equal_impl<
          typename less_equal_tag<N1>::type
        , typename less_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< less_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less_equal< na , na > result_; typedef less_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value <= N2::value ) >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/less_equal.hpp" 2 3
# 22 "/usr/local/include/boost/mpl/comparison.hpp" 2 3
# 1 "/usr/local/include/boost/mpl/greater_equal.hpp" 1 3
# 19 "/usr/local/include/boost/mpl/greater_equal.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/usr/local/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/usr/local/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 1 3
# 12 "/usr/local/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater_equal

    : greater_equal_impl<
          typename greater_equal_tag<N1>::type
        , typename greater_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater_equal< na , na > result_; typedef greater_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value >= N2::value ) >
    {
    };
};

}}
# 38 "/usr/local/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/usr/local/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/usr/local/include/boost/mpl/greater_equal.hpp" 2 3
# 23 "/usr/local/include/boost/mpl/comparison.hpp" 2 3
# 19 "/usr/local/include/boost/math/policies/policy.hpp" 2 3


# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 22 "/usr/local/include/boost/math/policies/policy.hpp" 2 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 27 "/usr/local/include/boost/math/policies/policy.hpp" 2 3
# 1 "/usr/include/c++/7/stdlib.h" 1 3
# 28 "/usr/local/include/boost/math/policies/policy.hpp" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 29 "/usr/local/include/boost/math/policies/policy.hpp" 2 3
# 1 "/usr/include/c++/7/math.h" 1 3
# 30 "/usr/local/include/boost/math/policies/policy.hpp" 2 3

namespace boost{ namespace math{

namespace tools{

template <class T>
constexpr int digits() noexcept;
template <class T>
constexpr T epsilon() noexcept(std::is_floating_point<T>::value);

}

namespace policies{
# 197 "/usr/local/include/boost/math/policies/policy.hpp" 3
enum error_policy_type
{
   throw_on_error = 0,
   errno_on_error = 1,
   ignore_error = 2,
   user_error = 3
};

template <error_policy_type N = throw_on_error> struct domain_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const domain_error<N>*); char test_is_default_arg(const domain_error<throw_on_error>*); template <class T> struct is_domain_error_imp { template <error_policy_type N> static char test(const domain_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_domain_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_domain_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct pole_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const pole_error<N>*); char test_is_default_arg(const pole_error<throw_on_error>*); template <class T> struct is_pole_error_imp { template <error_policy_type N> static char test(const pole_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_pole_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_pole_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct overflow_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const overflow_error<N>*); char test_is_default_arg(const overflow_error<throw_on_error>*); template <class T> struct is_overflow_error_imp { template <error_policy_type N> static char test(const overflow_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_overflow_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_overflow_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct underflow_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const underflow_error<N>*); char test_is_default_arg(const underflow_error<ignore_error>*); template <class T> struct is_underflow_error_imp { template <error_policy_type N> static char test(const underflow_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_underflow_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_underflow_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct denorm_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const denorm_error<N>*); char test_is_default_arg(const denorm_error<ignore_error>*); template <class T> struct is_denorm_error_imp { template <error_policy_type N> static char test(const denorm_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_denorm_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_denorm_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct evaluation_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const evaluation_error<N>*); char test_is_default_arg(const evaluation_error<throw_on_error>*); template <class T> struct is_evaluation_error_imp { template <error_policy_type N> static char test(const evaluation_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_evaluation_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_evaluation_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct rounding_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const rounding_error<N>*); char test_is_default_arg(const rounding_error<throw_on_error>*); template <class T> struct is_rounding_error_imp { template <error_policy_type N> static char test(const rounding_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_rounding_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_rounding_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct indeterminate_result_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const indeterminate_result_error<N>*); char test_is_default_arg(const indeterminate_result_error<ignore_error>*); template <class T> struct is_indeterminate_result_error_imp { template <error_policy_type N> static char test(const indeterminate_result_error<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_indeterminate_result_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_indeterminate_result_error_imp<T>::value>{};




template <bool N = true> struct promote_float : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const promote_float<N>*); char test_is_default_arg(const promote_float<true>*); template <class T> struct is_promote_float_imp { template <bool N> static char test(const promote_float<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_promote_float : public boost::mpl::bool_< ::boost::math::policies::detail::is_promote_float_imp<T>::value>{};
template <bool N = true> struct promote_double : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const promote_double<N>*); char test_is_default_arg(const promote_double<true>*); template <class T> struct is_promote_double_imp { template <bool N> static char test(const promote_double<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_promote_double : public boost::mpl::bool_< ::boost::math::policies::detail::is_promote_double_imp<T>::value>{};
template <bool N = true> struct assert_undefined : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const assert_undefined<N>*); char test_is_default_arg(const assert_undefined<true>*); template <class T> struct is_assert_undefined_imp { template <bool N> static char test(const assert_undefined<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_assert_undefined : public boost::mpl::bool_< ::boost::math::policies::detail::is_assert_undefined_imp<T>::value>{};



enum discrete_quantile_policy_type
{
   real,
   integer_round_outwards,
   integer_round_inwards,
   integer_round_down,
   integer_round_up,
   integer_round_nearest
};

template <discrete_quantile_policy_type N = integer_round_outwards> struct discrete_quantile : public boost::mpl::int_<N>{}; namespace detail{ template <discrete_quantile_policy_type N> char test_is_valid_arg(const discrete_quantile<N>*); char test_is_default_arg(const discrete_quantile<integer_round_outwards>*); template <class T> struct is_discrete_quantile_imp { template <discrete_quantile_policy_type N> static char test(const discrete_quantile<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_discrete_quantile : public boost::mpl::bool_< ::boost::math::policies::detail::is_discrete_quantile_imp<T>::value>{};



template <int N = 0> struct digits10 : public boost::mpl::int_<N>{}; namespace detail{ template <int N> char test_is_valid_arg(const digits10<N>*); char test_is_default_arg(const digits10<0>*); template <class T> struct is_digits10_imp { template <int N> static char test(const digits10<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_digits10 : public boost::mpl::bool_< ::boost::math::policies::detail::is_digits10_imp<T>::value>{};
template <int N = 0> struct digits2 : public boost::mpl::int_<N>{}; namespace detail{ template <int N> char test_is_valid_arg(const digits2<N>*); char test_is_default_arg(const digits2<0>*); template <class T> struct is_digits2_imp { template <int N> static char test(const digits2<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_digits2 : public boost::mpl::bool_< ::boost::math::policies::detail::is_digits2_imp<T>::value>{};



template <unsigned long N = 1000000> struct max_series_iterations : public boost::mpl::int_<N>{}; namespace detail{ template <unsigned long N> char test_is_valid_arg(const max_series_iterations<N>*); char test_is_default_arg(const max_series_iterations<1000000>*); template <class T> struct is_max_series_iterations_imp { template <unsigned long N> static char test(const max_series_iterations<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_max_series_iterations : public boost::mpl::bool_< ::boost::math::policies::detail::is_max_series_iterations_imp<T>::value>{};
template <unsigned long N = 200> struct max_root_iterations : public boost::mpl::int_<N>{}; namespace detail{ template <unsigned long N> char test_is_valid_arg(const max_root_iterations<N>*); char test_is_default_arg(const max_root_iterations<200>*); template <class T> struct is_max_root_iterations_imp { template <unsigned long N> static char test(const max_root_iterations<N>*); static double test(...); static const bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_max_root_iterations : public boost::mpl::bool_< ::boost::math::policies::detail::is_max_root_iterations_imp<T>::value>{};







struct default_policy{};

namespace detail{



template <class Digits10, class Digits2>
struct precision
{



   typedef typename mpl::if_c<
      (Digits10::value == 0),
      digits2<0>,
      digits2<((Digits10::value + 1) * 1000L) / 301L>
   >::type digits2_type;
public:





   typedef typename mpl::if_c<
      (Digits2::value > digits2_type::value),
      Digits2, digits2_type>::type type;

};

template <class A, class B, bool b>
struct select_result
{
   typedef A type;
};
template <class A, class B>
struct select_result<A, B, false>
{
   typedef typename mpl::deref<B>::type type;
};

template <class Seq, class Pred, class DefaultType>
struct find_arg
{
private:
   typedef typename mpl::find_if<Seq, Pred>::type iter;
   typedef typename mpl::end<Seq>::type end_type;
public:
   typedef typename select_result<
      DefaultType, iter,
      ::boost::is_same<iter, end_type>::value>::type type;
};

double test_is_valid_arg(...);
double test_is_default_arg(...);
char test_is_valid_arg(const default_policy*);
char test_is_default_arg(const default_policy*);

template <class T>
struct is_valid_policy_imp
{
   static const bool value = sizeof(::boost::math::policies::detail::test_is_valid_arg(static_cast<T*>(0))) == 1;
};

template <class T>
struct is_default_policy_imp
{
   static const bool value = sizeof(::boost::math::policies::detail::test_is_default_arg(static_cast<T*>(0))) == 1;
};

template <class T> struct is_valid_policy
: public mpl::bool_<
   ::boost::math::policies::detail::is_valid_policy_imp<T>::value>
{};

template <class T> struct is_default_policy
: public mpl::bool_<
   ::boost::math::policies::detail::is_default_policy_imp<T>::value>
{
   template <class U>
   struct apply
   {
      typedef is_default_policy<U> type;
   };
};

template <class Seq, class T, int N>
struct append_N
{
   typedef typename mpl::push_back<Seq, T>::type new_seq;
   typedef typename append_N<new_seq, T, N-1>::type type;
};

template <class Seq, class T>
struct append_N<Seq, T, 0>
{
   typedef Seq type;
};





template <bool f, bool d>
struct default_args
{
   typedef promote_float<false> arg1;
   typedef promote_double<false> arg2;
};

template <>
struct default_args<false, false>
{
   typedef default_policy arg1;
   typedef default_policy arg2;
};

template <>
struct default_args<true, false>
{
   typedef promote_float<false> arg1;
   typedef default_policy arg2;
};

template <>
struct default_args<false, true>
{
   typedef promote_double<false> arg1;
   typedef default_policy arg2;
};

typedef default_args<true, true>::arg1 forwarding_arg1;
typedef default_args<true, true>::arg2 forwarding_arg2;

}




template <class A1 = default_policy,
          class A2 = default_policy,
          class A3 = default_policy,
          class A4 = default_policy,
          class A5 = default_policy,
          class A6 = default_policy,
          class A7 = default_policy,
          class A8 = default_policy,
          class A9 = default_policy,
          class A10 = default_policy,
          class A11 = default_policy,
          class A12 = default_policy,
          class A13 = default_policy>
struct policy
{
private:



   static_assert(::boost::math::policies::detail::is_valid_policy<A1>::value, "::boost::math::policies::detail::is_valid_policy<A1>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A2>::value, "::boost::math::policies::detail::is_valid_policy<A2>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A3>::value, "::boost::math::policies::detail::is_valid_policy<A3>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A4>::value, "::boost::math::policies::detail::is_valid_policy<A4>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A5>::value, "::boost::math::policies::detail::is_valid_policy<A5>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A6>::value, "::boost::math::policies::detail::is_valid_policy<A6>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A7>::value, "::boost::math::policies::detail::is_valid_policy<A7>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A8>::value, "::boost::math::policies::detail::is_valid_policy<A8>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A9>::value, "::boost::math::policies::detail::is_valid_policy<A9>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A10>::value, "::boost::math::policies::detail::is_valid_policy<A10>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A11>::value, "::boost::math::policies::detail::is_valid_policy<A11>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A12>::value, "::boost::math::policies::detail::is_valid_policy<A12>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A13>::value, "::boost::math::policies::detail::is_valid_policy<A13>::value");



   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;

public:
   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, domain_error<> >::type domain_error_type;
   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, pole_error<> >::type pole_error_type;
   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, overflow_error<> >::type overflow_error_type;
   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, underflow_error<> >::type underflow_error_type;
   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, denorm_error<> >::type denorm_error_type;
   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, evaluation_error<> >::type evaluation_error_type;
   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, rounding_error<> >::type rounding_error_type;
   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, indeterminate_result_error<> >::type indeterminate_result_error_type;
private:



   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;
   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, digits2<> >::type bits_precision_type;
public:
   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;



   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, promote_float<> >::type promote_float_type;
   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, promote_double<> >::type promote_double_type;



   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, discrete_quantile<> >::type discrete_quantile_type;



   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, assert_undefined<> >::type assert_undefined_type;



   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, max_series_iterations<> >::type max_series_iterations_type;
   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, max_root_iterations<> >::type max_root_iterations_type;
};





template <>
struct policy<default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>
{
public:
   typedef domain_error<> domain_error_type;
   typedef pole_error<> pole_error_type;
   typedef overflow_error<> overflow_error_type;
   typedef underflow_error<> underflow_error_type;
   typedef denorm_error<> denorm_error_type;
   typedef evaluation_error<> evaluation_error_type;
   typedef rounding_error<> rounding_error_type;
   typedef indeterminate_result_error<> indeterminate_result_error_type;

   typedef digits2<> precision_type;



   typedef promote_float<> promote_float_type;
   typedef promote_double<> promote_double_type;
   typedef discrete_quantile<> discrete_quantile_type;
   typedef assert_undefined<> assert_undefined_type;
   typedef max_series_iterations<> max_series_iterations_type;
   typedef max_root_iterations<> max_root_iterations_type;
};

template <>
struct policy<detail::forwarding_arg1, detail::forwarding_arg2, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>
{
public:
   typedef domain_error<> domain_error_type;
   typedef pole_error<> pole_error_type;
   typedef overflow_error<> overflow_error_type;
   typedef underflow_error<> underflow_error_type;
   typedef denorm_error<> denorm_error_type;
   typedef evaluation_error<> evaluation_error_type;
   typedef rounding_error<> rounding_error_type;
   typedef indeterminate_result_error<> indeterminate_result_error_type;

   typedef digits2<> precision_type;



   typedef promote_float<false> promote_float_type;
   typedef promote_double<false> promote_double_type;
   typedef discrete_quantile<> discrete_quantile_type;
   typedef assert_undefined<> assert_undefined_type;
   typedef max_series_iterations<> max_series_iterations_type;
   typedef max_root_iterations<> max_root_iterations_type;
};

template <class Policy,
          class A1 = default_policy,
          class A2 = default_policy,
          class A3 = default_policy,
          class A4 = default_policy,
          class A5 = default_policy,
          class A6 = default_policy,
          class A7 = default_policy,
          class A8 = default_policy,
          class A9 = default_policy,
          class A10 = default_policy,
          class A11 = default_policy,
          class A12 = default_policy,
          class A13 = default_policy>
struct normalise
{
private:
   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;
   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, typename Policy::domain_error_type >::type domain_error_type;
   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, typename Policy::pole_error_type >::type pole_error_type;
   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, typename Policy::overflow_error_type >::type overflow_error_type;
   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, typename Policy::underflow_error_type >::type underflow_error_type;
   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, typename Policy::denorm_error_type >::type denorm_error_type;
   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, typename Policy::evaluation_error_type >::type evaluation_error_type;
   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, typename Policy::rounding_error_type >::type rounding_error_type;
   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, typename Policy::indeterminate_result_error_type >::type indeterminate_result_error_type;



   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;
   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, typename Policy::precision_type >::type bits_precision_type;
   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;



   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, typename Policy::promote_float_type >::type promote_float_type;
   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, typename Policy::promote_double_type >::type promote_double_type;



   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, typename Policy::discrete_quantile_type >::type discrete_quantile_type;



   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, typename Policy::assert_undefined_type >::type assert_undefined_type;



   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, typename Policy::max_series_iterations_type>::type max_series_iterations_type;
   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, typename Policy::max_root_iterations_type>::type max_root_iterations_type;



   typedef mpl::vector<
      domain_error_type,
      pole_error_type,
      overflow_error_type,
      underflow_error_type,
      denorm_error_type,
      evaluation_error_type,
      rounding_error_type,
      indeterminate_result_error_type,
      precision_type,
      promote_float_type,
      promote_double_type,
      discrete_quantile_type,
      assert_undefined_type,
      max_series_iterations_type,
      max_root_iterations_type> result_list;



   typedef typename mpl::remove_if<result_list, detail::is_default_policy<mpl::_> >::type reduced_list;



   typedef typename detail::append_N<reduced_list, default_policy, (14 - ::boost::mpl::size<reduced_list>::value)>::type result_type;
public:
   typedef policy<
      typename mpl::at<result_type, mpl::int_<0> >::type,
      typename mpl::at<result_type, mpl::int_<1> >::type,
      typename mpl::at<result_type, mpl::int_<2> >::type,
      typename mpl::at<result_type, mpl::int_<3> >::type,
      typename mpl::at<result_type, mpl::int_<4> >::type,
      typename mpl::at<result_type, mpl::int_<5> >::type,
      typename mpl::at<result_type, mpl::int_<6> >::type,
      typename mpl::at<result_type, mpl::int_<7> >::type,
      typename mpl::at<result_type, mpl::int_<8> >::type,
      typename mpl::at<result_type, mpl::int_<9> >::type,
      typename mpl::at<result_type, mpl::int_<10> >::type,
      typename mpl::at<result_type, mpl::int_<11> >::type,
      typename mpl::at<result_type, mpl::int_<12> >::type > type;
};



template <>
struct normalise<policy<>,
          promote_float<false>,
          promote_double<false>,
          discrete_quantile<>,
          assert_undefined<>,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy>
{
   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;
};

template <>
struct normalise<policy<detail::forwarding_arg1, detail::forwarding_arg2>,
          promote_float<false>,
          promote_double<false>,
          discrete_quantile<>,
          assert_undefined<>,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy>
{
   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;
};

inline constexpr policy<> make_policy() noexcept
{ return policy<>(); }

template <class A1>
inline constexpr typename normalise<policy<>, A1>::type make_policy(const A1&) noexcept
{
   typedef typename normalise<policy<>, A1>::type result_type;
   return result_type();
}

template <class A1, class A2>
inline constexpr typename normalise<policy<>, A1, A2>::type make_policy(const A1&, const A2&) noexcept
{
   typedef typename normalise<policy<>, A1, A2>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3>
inline constexpr typename normalise<policy<>, A1, A2, A3>::type make_policy(const A1&, const A2&, const A3&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4>::type make_policy(const A1&, const A2&, const A3&, const A4&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline constexpr typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&, const A11&) noexcept
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type result_type;
   return result_type();
}




template <class Real, class Policy>
struct evaluation
{
   typedef Real type;
};

template <class Policy>
struct evaluation<float, Policy>
{
   typedef typename mpl::if_<typename Policy::promote_float_type, double, float>::type type;
};

template <class Policy>
struct evaluation<double, Policy>
{
   typedef typename mpl::if_<typename Policy::promote_double_type, long double, double>::type type;
};
# 797 "/usr/local/include/boost/math/policies/policy.hpp" 3
template <class Real, class Policy>
struct precision
{
   static_assert((::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)), "(::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0))");

   typedef typename Policy::precision_type precision_type;
   typedef typename mpl::if_c<
      ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)),

      precision_type,
      typename mpl::if_c<
         ((::std::numeric_limits<Real>::digits <= precision_type::value)
         || (Policy::precision_type::value <= 0)),

         digits2< ::std::numeric_limits<Real>::digits>,

         precision_type
      >::type
   >::type type;
# 833 "/usr/local/include/boost/math/policies/policy.hpp" 3
};





template <class Policy>
struct precision<__float128, Policy>
{
   typedef mpl::int_<113> type;
};



namespace detail{

template <class T, class Policy>
inline constexpr int digits_imp(mpl::true_ const&) noexcept
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");



   typedef typename boost::math::policies::precision<T, Policy>::type p_t;
   return p_t::value;
}

template <class T, class Policy>
inline constexpr int digits_imp(mpl::false_ const&) noexcept
{
   return tools::digits<T>();
}

}

template <class T, class Policy>
inline constexpr int digits() noexcept
{
   typedef mpl::bool_< std::numeric_limits<T>::is_specialized > tag_type;
   return detail::digits_imp<T, Policy>(tag_type());
}
template <class T, class Policy>
inline constexpr int digits_base10() noexcept
{
   return boost::math::policies::digits<T, Policy>() * 301 / 1000L;
}

template <class Policy>
inline constexpr unsigned long get_max_series_iterations() noexcept
{
   typedef typename Policy::max_series_iterations_type iter_type;
   return iter_type::value;
}

template <class Policy>
inline constexpr unsigned long get_max_root_iterations() noexcept
{
   typedef typename Policy::max_root_iterations_type iter_type;
   return iter_type::value;
}

namespace detail{

template <class T, class Digits, class Small, class Default>
struct series_factor_calc
{
   static T get() noexcept(std::is_floating_point<T>::value)
   {
      return ldexp(T(1.0), 1 - Digits::value);
   }
};

template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::true_, mpl::true_>
{
   static constexpr T get() noexcept(std::is_floating_point<T>::value)
   {
      return boost::math::tools::epsilon<T>();
   }
};
template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::true_, mpl::false_>
{
   static constexpr T get() noexcept(std::is_floating_point<T>::value)
   {
      return 1 / static_cast<T>(static_cast<boost::uintmax_t>(1u) << (Digits::value - 1));
   }
};
template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::false_, mpl::true_>
{
   static constexpr T get() noexcept(std::is_floating_point<T>::value)
   {
      return boost::math::tools::epsilon<T>();
   }
};

template <class T, class Policy>
inline constexpr T get_epsilon_imp(mpl::true_ const&) noexcept(std::is_floating_point<T>::value)
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");
   static_assert(::std::numeric_limits<T>::radix == 2, "::std::numeric_limits<T>::radix == 2");




   typedef typename boost::math::policies::precision<T, Policy>::type p_t;
   typedef mpl::bool_<p_t::value <= std::numeric_limits<boost::uintmax_t>::digits> is_small_int;
   typedef mpl::bool_<p_t::value >= std::numeric_limits<T>::digits> is_default_value;
   return series_factor_calc<T, p_t, is_small_int, is_default_value>::get();
}

template <class T, class Policy>
inline constexpr T get_epsilon_imp(mpl::false_ const&) noexcept(std::is_floating_point<T>::value)
{
   return tools::epsilon<T>();
}

}

template <class T, class Policy>
inline constexpr T get_epsilon() noexcept(std::is_floating_point<T>::value)
{
   typedef mpl::bool_< (std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::radix == 2)) > tag_type;
   return detail::get_epsilon_imp<T, Policy>(tag_type());
}

namespace detail{

template <class A1,
          class A2,
          class A3,
          class A4,
          class A5,
          class A6,
          class A7,
          class A8,
          class A9,
          class A10,
          class A11>
char test_is_policy(const policy<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11>*);
double test_is_policy(...);

template <class P>
struct is_policy_imp
{
   static const bool value = (sizeof(::boost::math::policies::detail::test_is_policy(static_cast<P*>(0))) == 1);
};

}

template <class P>
struct is_policy : public mpl::bool_< ::boost::math::policies::detail::is_policy_imp<P>::value> {};




template <class Policy>
struct constructor_error_check
{
   typedef typename Policy::domain_error_type domain_error_type;
   typedef typename mpl::if_c<
      (domain_error_type::value == throw_on_error) || (domain_error_type::value == user_error) || (domain_error_type::value == errno_on_error),
      mpl::true_,
      mpl::false_>::type type;
};

template <class Policy>
struct method_error_check
{
   typedef typename Policy::domain_error_type domain_error_type;
   typedef typename mpl::if_c<
      (domain_error_type::value == throw_on_error) && (domain_error_type::value != user_error),
      mpl::false_,
      mpl::true_>::type type;
};



template <class Policy>
struct is_noexcept_error_policy
{
   typedef typename Policy::domain_error_type t1;
   typedef typename Policy::pole_error_type t2;
   typedef typename Policy::overflow_error_type t3;
   typedef typename Policy::underflow_error_type t4;
   typedef typename Policy::denorm_error_type t5;
   typedef typename Policy::evaluation_error_type t6;
   typedef typename Policy::rounding_error_type t7;
   typedef typename Policy::indeterminate_result_error_type t8;

   static const bool value = ((t1::value != throw_on_error) && (t1::value != user_error) && (t2::value != throw_on_error) && (t2::value != user_error) && (t3::value != throw_on_error) && (t3::value != user_error) && (t4::value != throw_on_error) && (t4::value != user_error) && (t5::value != throw_on_error) && (t5::value != user_error) && (t6::value != throw_on_error) && (t6::value != user_error) && (t7::value != throw_on_error) && (t7::value != user_error) && (t8::value != throw_on_error) && (t8::value != user_error))







                                                                     ;
};

}}}
# 30 "/usr/local/include/boost/math/special_functions/math_fwd.hpp" 2 3


# 1 "/usr/local/include/boost/config/no_tr1/complex.hpp" 1 3
# 33 "/usr/local/include/boost/math/special_functions/math_fwd.hpp" 2 3



namespace boost
{
   namespace math
   {


   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type
         beta(RT1 a, RT2 b);

   template <class RT1, class RT2, class A>
   typename tools::promote_args<RT1, RT2, A>::type
         beta(RT1 a, RT2 b, A x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         beta(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         betac(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         betac(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibeta_inv(T1 a, T2 b, T3 p, T4* py);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibeta_inv(T1 a, T2 b, T3 p, T4* py, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inv(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inv(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inva(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inva(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_invb(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_invb(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibetac_inv(T1 a, T2 b, T3 q, T4* py);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibetac_inv(T1 a, T2 b, T3 q, T4* py, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inv(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inv(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inva(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inva(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_invb(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_invb(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_derivative(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_derivative(RT1 a, RT2 b, RT3 x, const Policy& pol);


   template <class T, class Policy>
   T binomial_coefficient(unsigned n, unsigned k, const Policy& pol);
   template <class T>
   T binomial_coefficient(unsigned n, unsigned k);


   template <class RT>
   typename tools::promote_args<RT>::type erf(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erf(RT z, const Policy&);

   template <class RT>
   typename tools::promote_args<RT>::type erfc(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erfc(RT z, const Policy&);

   template <class RT>
   typename tools::promote_args<RT>::type erf_inv(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erf_inv(RT z, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type erfc_inv(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erfc_inv(RT z, const Policy& pol);


   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         legendre_next(unsigned l, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_p(int l, T x);
   template <class T>
   typename tools::promote_args<T>::type
          legendre_p_prime(int l, T x);


   template <class T, class Policy>
   inline std::vector<T> legendre_p_zeros(int l, const Policy& pol);

   template <class T>
   inline std::vector<T> legendre_p_zeros(int l);


   template <class T, class Policy>
   typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
         legendre_p(int l, T x, const Policy& pol);
   template <class T, class Policy>
   inline typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
      legendre_p_prime(int l, T x, const Policy& pol);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_q(unsigned l, T x);

   template <class T, class Policy>
   typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
         legendre_q(unsigned l, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         legendre_next(unsigned l, unsigned m, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_p(int l, int m, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
         legendre_p(int l, int m, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         laguerre_next(unsigned n, T1 x, T2 Ln, T3 Lnm1);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      laguerre_next(unsigned n, unsigned l, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
      laguerre(unsigned n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
      laguerre(unsigned n, unsigned m, T x, const Policy& pol);

   template <class T1, class T2>
   struct laguerre_result
   {
      typedef typename mpl::if_<
         policies::is_policy<T2>,
         typename tools::promote_args<T1>::type,
         typename tools::promote_args<T2>::type
      >::type type;
   };

   template <class T1, class T2>
   typename laguerre_result<T1, T2>::type
      laguerre(unsigned n, T1 m, T2 x);

   template <class T>
   typename tools::promote_args<T>::type
      hermite(unsigned n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
      hermite(unsigned n, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      hermite_next(unsigned n, T1 x, T2 Hn, T3 Hnm1);

   template<class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type chebyshev_next(T1 const & x, T2 const & Tn, T3 const & Tn_1);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_t(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_t(unsigned n, Real const & x);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_u(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_u(unsigned n, Real const & x);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_t_prime(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_t_prime(unsigned n, Real const & x);

   template<class Real, class T2>
   Real chebyshev_clenshaw_recurrence(const Real* const c, size_t length, const T2& x);

   template <class T1, class T2>
   std::complex<typename tools::promote_args<T1, T2>::type>
         spherical_harmonic(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   std::complex<typename tools::promote_args<T1, T2>::type>
      spherical_harmonic(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         spherical_harmonic_r(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
      spherical_harmonic_r(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         spherical_harmonic_i(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
      spherical_harmonic_i(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);


   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rf(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rf(T1 x, T2 y, T3 z, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rd(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rd(T1 x, T2 y, T3 z, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         ellint_rc(T1 x, T2 y);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         ellint_rc(T1 x, T2 y, const Policy& pol);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ellint_rj(T1 x, T2 y, T3 z, T4 p);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ellint_rj(T1 x, T2 y, T3 z, T4 p, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      ellint_rg(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
      ellint_rg(T1 x, T2 y, T3 z, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_2(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_2(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_2(T1 k, T2 phi, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_1(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_1(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_1(T1 k, T2 phi, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_d(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_d(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_d(T1 k, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type jacobi_zeta(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type jacobi_zeta(T1 k, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type heuman_lambda(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type heuman_lambda(T1 k, T2 phi, const Policy& pol);

   namespace detail{

   template <class T, class U, class V>
   struct ellint_3_result
   {
      typedef typename mpl::if_<
         policies::is_policy<V>,
         typename tools::promote_args<T, U>::type,
         typename tools::promote_args<T, U, V>::type
      >::type type;
   };

   }


   template <class T1, class T2, class T3>
   typename detail::ellint_3_result<T1, T2, T3>::type ellint_3(T1 k, T2 v, T3 phi);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type ellint_3(T1 k, T2 v, T3 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_3(T1 k, T2 v);



   template <class RT>
   struct max_factorial;
   template <class RT>
   RT factorial(unsigned int);
   template <class RT, class Policy>
   RT factorial(unsigned int, const Policy& pol);
   template <class RT>
   RT unchecked_factorial(unsigned int );
   template <class RT>
   RT double_factorial(unsigned i);
   template <class RT, class Policy>
   RT double_factorial(unsigned i, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type falling_factorial(RT x, unsigned n);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type falling_factorial(RT x, unsigned n, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type rising_factorial(RT x, int n);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type rising_factorial(RT x, int n, const Policy& pol);


   template <class RT>
   typename tools::promote_args<RT>::type tgamma(RT z);

   template <class RT>
   typename tools::promote_args<RT>::type tgamma1pm1(RT z);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type tgamma1pm1(RT z, const Policy& pol);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type tgamma(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type tgamma(RT1 a, RT2 z, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type lgamma(RT z, int* sign);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type lgamma(RT z, int* sign, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type lgamma(RT x);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type lgamma(RT x, const Policy& pol);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type tgamma_lower(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type tgamma_lower(RT1 a, RT2 z, const Policy&);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type gamma_q(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type gamma_q(RT1 a, RT2 z, const Policy&);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type gamma_p(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type gamma_p(RT1 a, RT2 z, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type tgamma_delta_ratio(T1 z, T2 delta);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type tgamma_delta_ratio(T1 z, T2 delta, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type tgamma_ratio(T1 a, T2 b);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type tgamma_ratio(T1 a, T2 b, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_derivative(T1 a, T2 x);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_derivative(T1 a, T2 x, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_inv(T1 a, T2 p);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_inva(T1 a, T2 p, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_inva(T1 a, T2 p);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_inv(T1 a, T2 p, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_q_inv(T1 a, T2 q);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_q_inv(T1 a, T2 q, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_q_inva(T1 a, T2 q);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_q_inva(T1 a, T2 q, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type digamma(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type digamma(T x, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type trigamma(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type trigamma(T x, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type polygamma(int n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type polygamma(int n, T x, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         hypot(T1 x, T2 y);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         hypot(T1 x, T2 y, const Policy&);


   template <class RT>
   typename tools::promote_args<RT>::type cbrt(RT z);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type cbrt(RT z, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type log1p(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type log1p(T, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type log1pmx(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type log1pmx(T, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type expm1(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type expm1(T, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         powm1(const T1 a, const T2 z);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         powm1(const T1 a, const T2 z, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type sqrt1pm1(const T& val);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sqrt1pm1(const T& val, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type sinc_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sinc_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type sinhc_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sinhc_pi(T x, const Policy&);


   template<typename T>
   typename tools::promote_args<T>::type asinh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type asinh(T x, const Policy&);

   template<typename T>
   typename tools::promote_args<T>::type acosh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type acosh(T x, const Policy&);

   template<typename T>
   typename tools::promote_args<T>::type atanh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type atanh(T x, const Policy&);

   namespace detail{

      typedef mpl::int_<0> bessel_no_int_tag;
      typedef mpl::int_<1> bessel_maybe_int_tag;
      typedef mpl::int_<2> bessel_int_tag;

      template <class T1, class T2, class Policy>
      struct bessel_traits
      {
         typedef typename mpl::if_<
            is_integral<T1>,
            typename tools::promote_args<T2>::type,
            typename tools::promote_args<T1, T2>::type
         >::type result_type;

         typedef typename policies::precision<result_type, Policy>::type precision_type;

         typedef typename mpl::if_<
            mpl::or_<
               mpl::less_equal<precision_type, mpl::int_<0> >,
               mpl::greater<precision_type, mpl::int_<64> > >,
            bessel_no_int_tag,
            typename mpl::if_<
               is_integral<T1>,
               bessel_int_tag,
               bessel_maybe_int_tag
            >::type
         >::type optimisation_tag;
         typedef typename mpl::if_<
            mpl::or_<
               mpl::less_equal<precision_type, mpl::int_<0> >,
               mpl::greater<precision_type, mpl::int_<113> > >,
            bessel_no_int_tag,
            typename mpl::if_<
               is_integral<T1>,
               bessel_int_tag,
               bessel_maybe_int_tag
            >::type
         >::type optimisation_tag128;
      };
   }


   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_j(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_j_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_j(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_j_prime(T1 v, T2 x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_bessel(unsigned v, T x, const Policy& pol);
   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_bessel_prime(unsigned v, T x, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_bessel(unsigned v, T x);
   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_bessel_prime(unsigned v, T x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_i(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_i_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_i(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_i_prime(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_k(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_k_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_k(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_k_prime(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_neumann(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_neumann_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_neumann(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_neumann_prime(T1 v, T2 x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_neumann(unsigned v, T x, const Policy& pol);
   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_neumann_prime(unsigned v, T x, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_neumann(unsigned v, T x);
   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_neumann_prime(unsigned v, T x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type cyl_bessel_j_zero(T v, int m, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type cyl_bessel_j_zero(T v, int m);

   template <class T, class OutputIterator>
   OutputIterator cyl_bessel_j_zero(T v,
                          int start_index,
                          unsigned number_of_zeros,
                          OutputIterator out_it);

   template <class T, class OutputIterator, class Policy>
   OutputIterator cyl_bessel_j_zero(T v,
                          int start_index,
                          unsigned number_of_zeros,
                          OutputIterator out_it,
                          const Policy&);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type cyl_neumann_zero(T v, int m, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type cyl_neumann_zero(T v, int m);

   template <class T, class OutputIterator>
   OutputIterator cyl_neumann_zero(T v,
                         int start_index,
                         unsigned number_of_zeros,
                         OutputIterator out_it);

   template <class T, class OutputIterator, class Policy>
   OutputIterator cyl_neumann_zero(T v,
                         int start_index,
                         unsigned number_of_zeros,
                         OutputIterator out_it,
                         const Policy&);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> cyl_hankel_1(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> cyl_hankel_1(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> cyl_hankel_2(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> cyl_hankel_2(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> sph_hankel_1(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> sph_hankel_1(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> sph_hankel_2(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> sph_hankel_2(T1 v, T2 x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_ai(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_ai(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_bi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_bi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_ai_prime(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_ai_prime(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_bi_prime(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_bi_prime(T x);

   template <class T>
   T airy_ai_zero(int m);
   template <class T, class Policy>
   T airy_ai_zero(int m, const Policy&);

   template <class OutputIterator>
   OutputIterator airy_ai_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it);
   template <class OutputIterator, class Policy>
   OutputIterator airy_ai_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it,
                     const Policy&);

   template <class T>
   T airy_bi_zero(int m);
   template <class T, class Policy>
   T airy_bi_zero(int m, const Policy&);

   template <class OutputIterator>
   OutputIterator airy_bi_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it);
   template <class OutputIterator, class Policy>
   OutputIterator airy_bi_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it,
                     const Policy&);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sin_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type sin_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type cos_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type cos_pi(T x);

   template <class T>
   int fpclassify (T t);

   template <class T>
   bool isfinite (T z);

   template <class T>
   bool isinf (T t);

   template <class T>
   bool isnan (T t);

   template <class T>
   bool isnormal (T t);

   template<class T>
   int signbit (T x);

   template <class T>
   int sign (const T& z);

   template <class T, class U>
   typename tools::promote_args_permissive<T, U>::type copysign (const T& x, const U& y);

   template <class T>
   typename tools::promote_args_permissive<T>::type changesign (const T& z);


   namespace detail{

   template <class T, class U>
   struct expint_result
   {
      typedef typename mpl::if_<
         policies::is_policy<U>,
         typename tools::promote_args<T>::type,
         typename tools::promote_args<U>::type
      >::type type;
   };

   }

   template <class T, class Policy>
   typename tools::promote_args<T>::type expint(unsigned n, T z, const Policy&);

   template <class T, class U>
   typename detail::expint_result<T, U>::type expint(T const z, U const u);

   template <class T>
   typename tools::promote_args<T>::type expint(T z);


   template <class T, class Policy>
   typename tools::promote_args<T>::type zeta(T s, const Policy&);


   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type owens_t(T1 h, T2 a, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type owens_t(T1 h, T2 a);


   template <class T, class U, class V, class Policy>
   typename tools::promote_args<T, U, V>::type jacobi_elliptic(T k, U theta, V* pcn, V* pdn, const Policy&);

   template <class T, class U, class V>
   typename tools::promote_args<T, U, V>::type jacobi_elliptic(T k, U theta, V* pcn = 0, V* pdn = 0);

   template <class U, class T, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sn(U k, T theta, const Policy& pol);

   template <class U, class T>
   typename tools::promote_args<T, U>::type jacobi_sn(U k, T theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cn(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cn(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_dn(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_dn(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_dc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_dc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_ns(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_ns(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_sd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_ds(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_ds(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_nc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_nc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_nd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_nd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_sc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cs(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cs(T k, U theta);


   template <class T>
   typename tools::promote_args<T>::type zeta(T s);


   template <int N, typename T, class Policy>
   typename tools::promote_args<T>::type pow(T base, const Policy& policy);

   template <int N, typename T>
   typename tools::promote_args<T>::type pow(T base);


   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type nextafter(const T&, const U&, const Policy&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type nextafter(const T&, const U&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_next(const T&, const Policy&);
   template <class T>
   typename tools::promote_args<T>::type float_next(const T&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_prior(const T&, const Policy&);
   template <class T>
   typename tools::promote_args<T>::type float_prior(const T&);
   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type float_distance(const T&, const U&, const Policy&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type float_distance(const T&, const U&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_advance(T val, int distance, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type float_advance(const T& val, int distance);

   template <class T, class Policy>
   typename tools::promote_args<T>::type ulp(const T& val, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type ulp(const T& val);

   template <class T, class U>
   typename tools::promote_args<T, U>::type relative_difference(const T&, const U&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type epsilon_difference(const T&, const U&);

   template<class T>
   constexpr T unchecked_bernoulli_b2n(const std::size_t n);
   template <class T, class Policy>
   T bernoulli_b2n(const int i, const Policy &pol);
   template <class T>
   T bernoulli_b2n(const int i);
   template <class T, class OutputIterator, class Policy>
   OutputIterator bernoulli_b2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it,
                                       const Policy& pol);
   template <class T, class OutputIterator>
   OutputIterator bernoulli_b2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it);
   template <class T, class Policy>
   T tangent_t2n(const int i, const Policy &pol);
   template <class T>
   T tangent_t2n(const int i);
   template <class T, class OutputIterator, class Policy>
   OutputIterator tangent_t2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it,
                                       const Policy& pol);
   template <class T, class OutputIterator>
   OutputIterator tangent_t2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it);


   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_w0(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_w0(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_wm1(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_wm1(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_w0_prime(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_w0_prime(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_wm1_prime(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_wm1_prime(T z);




    }
}
# 18 "/usr/local/include/boost/math/special_functions/sign.hpp" 2 3
# 1 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 1 3
# 23 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
# 1 "/usr/include/c++/7/cstring" 1 3
# 39 "/usr/include/c++/7/cstring" 3
       
# 40 "/usr/include/c++/7/cstring" 3
# 24 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 2 3

# 1 "/usr/local/include/boost/assert.hpp" 1 3
# 58 "/usr/local/include/boost/assert.hpp" 3
# 1 "/usr/include/assert.h" 1 3 4
# 59 "/usr/local/include/boost/assert.hpp" 2 3
# 26 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 2 3
# 1 "/usr/local/include/boost/cstdint.hpp" 1 3
# 27 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 2 3
# 1 "/usr/local/include/boost/predef/other/endian.h" 1 3
# 12 "/usr/local/include/boost/predef/other/endian.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/other/endian.h" 2 3
# 1 "/usr/local/include/boost/predef/library/c/gnu.h" 1 3
# 12 "/usr/local/include/boost/predef/library/c/gnu.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/library/c/gnu.h" 2 3

# 1 "/usr/local/include/boost/predef/library/c/_prefix.h" 1 3
# 11 "/usr/local/include/boost/predef/library/c/_prefix.h" 3
# 1 "/usr/local/include/boost/predef/detail/_cassert.h" 1 3
# 12 "/usr/local/include/boost/predef/detail/_cassert.h" 3
# 1 "/usr/include/c++/7/cassert" 1 3
# 41 "/usr/include/c++/7/cassert" 3
       
# 42 "/usr/include/c++/7/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 44 "/usr/include/c++/7/cassert" 2 3
# 13 "/usr/local/include/boost/predef/detail/_cassert.h" 2 3
# 12 "/usr/local/include/boost/predef/library/c/_prefix.h" 2 3
# 15 "/usr/local/include/boost/predef/library/c/gnu.h" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 18 "/usr/local/include/boost/predef/library/c/gnu.h" 2 3
# 61 "/usr/local/include/boost/predef/library/c/gnu.h" 3

# 14 "/usr/local/include/boost/predef/other/endian.h" 2 3
# 1 "/usr/local/include/boost/predef/os/macos.h" 1 3
# 17 "/usr/local/include/boost/predef/os/macos.h" 3
# 1 "/usr/local/include/boost/predef/os/ios.h" 1 3
# 13 "/usr/local/include/boost/predef/os/ios.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 14 "/usr/local/include/boost/predef/os/ios.h" 2 3
# 51 "/usr/local/include/boost/predef/os/ios.h" 3

# 18 "/usr/local/include/boost/predef/os/macos.h" 2 3


# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 21 "/usr/local/include/boost/predef/os/macos.h" 2 3
# 65 "/usr/local/include/boost/predef/os/macos.h" 3

# 15 "/usr/local/include/boost/predef/other/endian.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd.h" 1 3
# 16 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/macos.h" 1 3
# 65 "/usr/local/include/boost/predef/os/macos.h" 3

# 17 "/usr/local/include/boost/predef/os/bsd.h" 2 3


# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 20 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 52 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 11 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd.h" 1 3
# 94 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 95 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 11 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd.h" 1 3
# 94 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 95 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 96 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 11 "/usr/local/include/boost/predef/os/bsd/free.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd.h" 1 3
# 94 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 95 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 96 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 97 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 11 "/usr/local/include/boost/predef/os/bsd/open.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd.h" 1 3
# 94 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 95 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 96 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 97 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 98 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 11 "/usr/local/include/boost/predef/os/bsd/net.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd.h" 1 3
# 94 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 95 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 96 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 97 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 98 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 99 "/usr/local/include/boost/predef/os/bsd.h" 2 3



# 12 "/usr/local/include/boost/predef/os/bsd/net.h" 2 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 99 "/usr/local/include/boost/predef/os/bsd.h" 2 3



# 12 "/usr/local/include/boost/predef/os/bsd/open.h" 2 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 98 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 99 "/usr/local/include/boost/predef/os/bsd.h" 2 3



# 12 "/usr/local/include/boost/predef/os/bsd/free.h" 2 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 97 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 98 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 99 "/usr/local/include/boost/predef/os/bsd.h" 2 3



# 12 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 2 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 96 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 97 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 98 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 99 "/usr/local/include/boost/predef/os/bsd.h" 2 3



# 12 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 2 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 53 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 54 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 55 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 56 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 57 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 94 "/usr/local/include/boost/predef/os/bsd.h" 3
# 1 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 1 3
# 48 "/usr/local/include/boost/predef/os/bsd/bsdi.h" 3

# 95 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 1 3
# 50 "/usr/local/include/boost/predef/os/bsd/dragonfly.h" 3

# 96 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/free.h" 1 3
# 67 "/usr/local/include/boost/predef/os/bsd/free.h" 3

# 97 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/open.h" 1 3
# 251 "/usr/local/include/boost/predef/os/bsd/open.h" 3

# 98 "/usr/local/include/boost/predef/os/bsd.h" 2 3
# 1 "/usr/local/include/boost/predef/os/bsd/net.h" 1 3
# 84 "/usr/local/include/boost/predef/os/bsd/net.h" 3

# 99 "/usr/local/include/boost/predef/os/bsd.h" 2 3



# 16 "/usr/local/include/boost/predef/other/endian.h" 2 3
# 1 "/usr/local/include/boost/predef/os/android.h" 1 3
# 12 "/usr/local/include/boost/predef/os/android.h" 3
# 1 "/usr/local/include/boost/predef/make.h" 1 3
# 13 "/usr/local/include/boost/predef/os/android.h" 2 3
# 48 "/usr/local/include/boost/predef/os/android.h" 3

# 17 "/usr/local/include/boost/predef/other/endian.h" 2 3
# 194 "/usr/local/include/boost/predef/other/endian.h" 3










# 28 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 2 3
# 81 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
namespace boost {
namespace math {
namespace detail {
# 92 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
struct native_tag {};
template <bool has_limits>
struct generic_tag {};
struct ieee_tag {};
struct ieee_copy_all_bits_tag : public ieee_tag {};
struct ieee_copy_leading_bits_tag : public ieee_tag {};
# 125 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
struct unknown_precision{};
struct single_precision {};
struct double_precision {};
struct extended_double_precision {};



template<class T> struct fp_traits_native
{
    typedef native_tag method;
};



template<class T, class U> struct fp_traits_non_native
{

   typedef generic_tag<std::numeric_limits<T>::is_specialized> method;



};
# 177 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
template<> struct fp_traits_non_native<float, single_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint32_t sign = 0x80000000u;
    static const uint32_t exponent = 0x7f800000;
    static const uint32_t flag = 0x00000000;
    static const uint32_t significand = 0x007fffff;

    typedef uint32_t bits;
    static void get_bits(float x, uint32_t& a) { std::memcpy(&a, &x, 4); }
    static void set_bits(float& x, uint32_t a) { std::memcpy(&x, &a, 4); }
};
# 232 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
template<> struct fp_traits_non_native<double, double_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint64_t sign = ((uint64_t)0x80000000u) << 32;
    static const uint64_t exponent = ((uint64_t)0x7ff00000) << 32;
    static const uint64_t flag = 0;
    static const uint64_t significand
        = (((uint64_t)0x000fffff) << 32) + ((uint64_t)0xffffffffu);

    typedef uint64_t bits;
    static void get_bits(double x, uint64_t& a) { std::memcpy(&a, &x, 8); }
    static void set_bits(double& x, uint64_t a) { std::memcpy(&x, &a, 8); }
};
# 292 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
template<> struct fp_traits_non_native<long double, double_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint64_t sign = (uint64_t)0x80000000u << 32;
    static const uint64_t exponent = (uint64_t)0x7ff00000 << 32;
    static const uint64_t flag = 0;
    static const uint64_t significand
        = ((uint64_t)0x000fffff << 32) + (uint64_t)0xffffffffu;

    typedef uint64_t bits;
    static void get_bits(long double x, uint64_t& a) { std::memcpy(&a, &x, 8); }
    static void set_bits(long double& x, uint64_t a) { std::memcpy(&x, &a, 8); }
};
# 318 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
template<>
struct fp_traits_non_native<long double, extended_double_precision>
{
    typedef ieee_copy_leading_bits_tag method;

    static const uint32_t sign = 0x80000000u;
    static const uint32_t exponent = 0x7fff0000;
    static const uint32_t flag = 0x00008000;
    static const uint32_t significand = 0x00007fff;

    typedef uint32_t bits;

    static void get_bits(long double x, uint32_t& a)
    {
        std::memcpy(&a, reinterpret_cast<const unsigned char*>(&x) + 6, 4);
    }

    static void set_bits(long double& x, uint32_t a)
    {
        std::memcpy(reinterpret_cast<unsigned char*>(&x) + 6, &a, 4);
    }
};
# 490 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
template<int n, bool fp> struct size_to_precision
{
   typedef unknown_precision type;
};

template<> struct size_to_precision<4, true>
{
    typedef single_precision type;
};

template<> struct size_to_precision<8, true>
{
    typedef double_precision type;
};

template<> struct size_to_precision<10, true>
{
    typedef extended_double_precision type;
};

template<> struct size_to_precision<12, true>
{
    typedef extended_double_precision type;
};

template<> struct size_to_precision<16, true>
{
    typedef extended_double_precision type;
};






template <class T>
struct select_native
{
    typedef typename size_to_precision<sizeof(T), ::boost::is_floating_point<T>::value>::type precision;
    typedef fp_traits_non_native<T, precision> type;
};
template<>
struct select_native<float>
{
    typedef fp_traits_native<float> type;
};
template<>
struct select_native<double>
{
    typedef fp_traits_native<double> type;
};
template<>
struct select_native<long double>
{
    typedef fp_traits_native<long double> type;
};
# 564 "/usr/local/include/boost/math/special_functions/detail/fp_traits.hpp" 3
template<class T> struct fp_traits
{
    typedef typename size_to_precision<sizeof(T), ::boost::is_floating_point<T>::value>::type precision;

    typedef typename select_native<T>::type type;



    typedef fp_traits_non_native<T, precision> sign_change_type;
};



}
}
}
# 19 "/usr/local/include/boost/math/special_functions/sign.hpp" 2 3

namespace boost{ namespace math{

namespace detail {




    template<class T>
    inline int signbit_impl(T x, native_tag const&)
    {
        return (std::signbit)(x) ? 1 : 0;
    }





    template<class T>
    inline int signbit_impl(T x, generic_tag<true> const&)
    {
        return x < 0;
    }

    template<class T>
    inline int signbit_impl(T x, generic_tag<false> const&)
    {
        return x < 0;
    }
# 67 "/usr/local/include/boost/math/special_functions/sign.hpp" 3
    template<class T>
    inline int signbit_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        return a & traits::sign ? 1 : 0;
    }

    template<class T>
    inline int signbit_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);

        return a & traits::sign ? 1 : 0;
    }






    template<class T>
    inline T (changesign_impl)(T x, generic_tag<true> const&)
    {
        return -x;
    }

    template<class T>
    inline T (changesign_impl)(T x, generic_tag<false> const&)
    {
        return -x;
    }
# 126 "/usr/local/include/boost/math/special_functions/sign.hpp" 3
    template<class T>
    inline T changesign_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::sign_change_type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a ^= traits::sign;
        traits::set_bits(x,a);
        return x;
    }

    template<class T>
    inline T (changesign_impl)(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::sign_change_type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a ^= traits::sign;
        traits::set_bits(x,a);
        return x;
    }


}

template<class T> int (signbit)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type result_type;
   return detail::signbit_impl(static_cast<result_type>(x), method());
}

template <class T>
inline int sign (const T& z)
{
   return (z == 0) ? 0 : (boost::math::signbit)(z) ? -1 : 1;
}

template <class T> typename tools::promote_args_permissive<T>::type (changesign)(const T& x)
{
   typedef typename detail::fp_traits<T>::sign_change_type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type result_type;

   return detail::changesign_impl(static_cast<result_type>(x), method());
}

template <class T, class U>
inline typename tools::promote_args_permissive<T, U>::type
   copysign (const T& x, const U& y)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args_permissive<T, U>::type result_type;
   return (boost::math::signbit)(static_cast<result_type>(x)) != (boost::math::signbit)(static_cast<result_type>(y))
      ? (boost::math::changesign)(static_cast<result_type>(x)) : static_cast<result_type>(x);
}

}
}
# 35 "/usr/local/include/boost/lexical_cast/detail/inf_nan.hpp" 2 3
# 1 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 1 3
# 14 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
# 1 "/usr/include/c++/7/math.h" 1 3
# 15 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 2 3


# 1 "/usr/local/include/boost/math/tools/real_cast.hpp" 1 3
# 15 "/usr/local/include/boost/math/tools/real_cast.hpp" 3
namespace boost{ namespace math
{
  namespace tools
  {
    template <class To, class T>
    inline constexpr To real_cast(T t) noexcept(((std::is_floating_point<T>::value) && (std::is_floating_point<To>::value)))
    {
       return static_cast<To>(t);
    }
  }
}
}
# 18 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 2 3
# 86 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/quadmath.h" 1 3 4
# 24 "/usr/lib/gcc/x86_64-linux-gnu/7/include/quadmath.h" 3 4
# 1 "/usr/include/c++/7/stdlib.h" 1 3 4
# 25 "/usr/lib/gcc/x86_64-linux-gnu/7/include/quadmath.h" 2 3 4


extern "C" {




typedef _Complex float __attribute__((mode(TC))) __complex128;
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7/include/quadmath.h" 3 4
extern __float128 acosq (__float128) throw ();
extern __float128 acoshq (__float128) throw ();
extern __float128 asinq (__float128) throw ();
extern __float128 asinhq (__float128) throw ();
extern __float128 atanq (__float128) throw ();
extern __float128 atanhq (__float128) throw ();
extern __float128 atan2q (__float128, __float128) throw ();
extern __float128 cbrtq (__float128) throw ();
extern __float128 ceilq (__float128) throw ();
extern __float128 copysignq (__float128, __float128) throw ();
extern __float128 coshq (__float128) throw ();
extern __float128 cosq (__float128) throw ();
extern __float128 erfq (__float128) throw ();
extern __float128 erfcq (__float128) throw ();
extern __float128 expq (__float128) throw ();
extern __float128 expm1q (__float128) throw ();
extern __float128 fabsq (__float128) throw ();
extern __float128 fdimq (__float128, __float128) throw ();
extern int finiteq (__float128) throw ();
extern __float128 floorq (__float128) throw ();
extern __float128 fmaq (__float128, __float128, __float128) throw ();
extern __float128 fmaxq (__float128, __float128) throw ();
extern __float128 fminq (__float128, __float128) throw ();
extern __float128 fmodq (__float128, __float128) throw ();
extern __float128 frexpq (__float128, int *) throw ();
extern __float128 hypotq (__float128, __float128) throw ();
extern int isinfq (__float128) throw ();
extern int ilogbq (__float128) throw ();
extern int isnanq (__float128) throw ();
extern __float128 j0q (__float128) throw ();
extern __float128 j1q (__float128) throw ();
extern __float128 jnq (int, __float128) throw ();
extern __float128 ldexpq (__float128, int) throw ();
extern __float128 lgammaq (__float128) throw ();
extern long long int llrintq (__float128) throw ();
extern long long int llroundq (__float128) throw ();
extern __float128 logbq (__float128) throw ();
extern __float128 logq (__float128) throw ();
extern __float128 log10q (__float128) throw ();
extern __float128 log2q (__float128) throw ();
extern __float128 log1pq (__float128) throw ();
extern long int lrintq (__float128) throw ();
extern long int lroundq (__float128) throw ();
extern __float128 modfq (__float128, __float128 *) throw ();
extern __float128 nanq (const char *) throw ();
extern __float128 nearbyintq (__float128) throw ();
extern __float128 nextafterq (__float128, __float128) throw ();
extern __float128 powq (__float128, __float128) throw ();
extern __float128 remainderq (__float128, __float128) throw ();
extern __float128 remquoq (__float128, __float128, int *) throw ();
extern __float128 rintq (__float128) throw ();
extern __float128 roundq (__float128) throw ();
extern __float128 scalblnq (__float128, long int) throw ();
extern __float128 scalbnq (__float128, int) throw ();
extern int signbitq (__float128) throw ();
extern void sincosq (__float128, __float128 *, __float128 *) throw ();
extern __float128 sinhq (__float128) throw ();
extern __float128 sinq (__float128) throw ();
extern __float128 sqrtq (__float128) throw ();
extern __float128 tanq (__float128) throw ();
extern __float128 tanhq (__float128) throw ();
extern __float128 tgammaq (__float128) throw ();
extern __float128 truncq (__float128) throw ();
extern __float128 y0q (__float128) throw ();
extern __float128 y1q (__float128) throw ();
extern __float128 ynq (int, __float128) throw ();



extern __float128 cabsq (__complex128) throw ();
extern __float128 cargq (__complex128) throw ();
extern __float128 cimagq (__complex128) throw ();
extern __float128 crealq (__complex128) throw ();
extern __complex128 cacosq (__complex128) throw ();
extern __complex128 cacoshq (__complex128) throw ();
extern __complex128 casinq (__complex128) throw ();
extern __complex128 casinhq (__complex128) throw ();
extern __complex128 catanq (__complex128) throw ();
extern __complex128 catanhq (__complex128) throw ();
extern __complex128 ccosq (__complex128) throw ();
extern __complex128 ccoshq (__complex128) throw ();
extern __complex128 cexpq (__complex128) throw ();
extern __complex128 cexpiq (__float128) throw ();
extern __complex128 clogq (__complex128) throw ();
extern __complex128 clog10q (__complex128) throw ();
extern __complex128 conjq (__complex128) throw ();
extern __complex128 cpowq (__complex128, __complex128) throw ();
extern __complex128 cprojq (__complex128) throw ();
extern __complex128 csinq (__complex128) throw ();
extern __complex128 csinhq (__complex128) throw ();
extern __complex128 csqrtq (__complex128) throw ();
extern __complex128 ctanq (__complex128) throw ();
extern __complex128 ctanhq (__complex128) throw ();



extern __float128 strtoflt128 (const char *, char **) throw ();
extern int quadmath_snprintf (char *str, size_t size,
         const char *format, ...) throw ();
# 179 "/usr/lib/gcc/x86_64-linux-gnu/7/include/quadmath.h" 3 4
extern inline __attribute__ ((__gnu_inline__)) __float128
cimagq (__complex128 __z) throw ()
{
  return __imag__ __z;
}

extern inline __attribute__ ((__gnu_inline__)) __float128
crealq (__complex128 __z) throw ()
{
  return __real__ __z;
}

extern inline __attribute__ ((__gnu_inline__)) __complex128
conjq (__complex128 __z) throw ()
{
  return __extension__ ~__z;
}


}
# 87 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 2 3
# 96 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
namespace boost{






namespace math_detail{






template <class T>
inline bool is_nan_helper(T t, const boost::true_type&)
{






   return (::std:: fpclassify(t) == (int)0);

}





template <class T>
inline bool is_nan_helper(T, const boost::false_type&)
{
   return false;
}


inline bool is_nan_helper(__float128 f, const boost::true_type&) { return ::isnanq(f); }
inline bool is_nan_helper(__float128 f, const boost::false_type&) { return ::isnanq(f); }
# 145 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
}

namespace math{

namespace detail{


template <class T>
inline int fpclassify_imp (T t, const native_tag&)
{
   return (std::fpclassify)(t);
}


template <class T>
inline int fpclassify_imp (T t, const generic_tag<true>&)
{
   ;



   if(::boost::math_detail::is_nan_helper(t, ::boost::is_floating_point<T>()))
      return 0;
# 176 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
   T at = (t < T(0)) ? -t : t;







   if(at <= (std::numeric_limits<T>::max)())
   {
      if(at >= (std::numeric_limits<T>::min)())
         return 4;
      return (at != 0) ? 3 : 2;
   }
   else if(at > (std::numeric_limits<T>::max)())
      return 1;
   return 0;
}

template <class T>
inline int fpclassify_imp (T t, const generic_tag<false>&)
{
# 206 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
   ;

   return t == 0 ? 2 : 4;
}

template<class T>
int fpclassify_imp (T x, ieee_copy_all_bits_tag)
{
   typedef typename fp_traits<T>::type traits;

   ;

   typename traits::bits a;
   traits::get_bits(x,a);
   ;
   a &= traits::exponent | traits::flag | traits::significand;
   ;
   ;

   if(a <= traits::significand) {
      if(a == 0)
         return 2;
      else
         return 3;
   }

   if(a < traits::exponent) return 4;

   a &= traits::significand;
   if(a == 0) return 1;

   return 0;
}

template<class T>
int fpclassify_imp (T x, ieee_copy_leading_bits_tag)
{
   typedef typename fp_traits<T>::type traits;

   ;

   typename traits::bits a;
   traits::get_bits(x,a);
   a &= traits::exponent | traits::flag | traits::significand;

   if(a <= traits::significand) {
      if(x == 0)
         return 2;
      else
         return 3;
   }

   if(a < traits::exponent) return 4;

   a &= traits::significand;
   traits::set_bits(x,a);
   if(x == 0) return 1;

   return 0;
}
# 274 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
}

template <class T>
inline int fpclassify (T t)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;
   typedef typename tools::promote_args_permissive<T>::type value_type;





   return detail::fpclassify_imp(static_cast<value_type>(t), method());

}
# 308 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
namespace detail {


    template<class T>
    inline bool isfinite_impl(T x, native_tag const&)
    {
        return (std::isfinite)(x);
    }


    template<class T>
    inline bool isfinite_impl(T x, generic_tag<true> const&)
    {
        return x >= -(std::numeric_limits<T>::max)()
            && x <= (std::numeric_limits<T>::max)();
    }

    template<class T>
    inline bool isfinite_impl(T x, generic_tag<false> const&)
    {




       (void)x;
       return true;
    }

    template<class T>
    inline bool isfinite_impl(T x, ieee_tag const&)
    {
        typedef typename detail::fp_traits<T>::type traits;
        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent;
        return a != traits::exponent;
    }
# 353 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
}

template<class T>
inline bool (isfinite)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isfinite_impl(static_cast<value_type>(x), method());
}
# 379 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
namespace detail {


    template<class T>
    inline bool isnormal_impl(T x, native_tag const&)
    {
        return (std::isnormal)(x);
    }


    template<class T>
    inline bool isnormal_impl(T x, generic_tag<true> const&)
    {
        if(x < 0) x = -x;
        return x >= (std::numeric_limits<T>::min)()
            && x <= (std::numeric_limits<T>::max)();
    }

    template<class T>
    inline bool isnormal_impl(T x, generic_tag<false> const&)
    {




       return !(x == 0);
    }

    template<class T>
    inline bool isnormal_impl(T x, ieee_tag const&)
    {
        typedef typename detail::fp_traits<T>::type traits;
        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::flag;
        return (a != 0) && (a < traits::exponent);
    }
# 424 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
}

template<class T>
inline bool (isnormal)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isnormal_impl(static_cast<value_type>(x), method());
}
# 450 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
namespace detail {


    template<class T>
    inline bool isinf_impl(T x, native_tag const&)
    {
        return (std::isinf)(x);
    }


    template<class T>
    inline bool isinf_impl(T x, generic_tag<true> const&)
    {
        (void)x;
        return std::numeric_limits<T>::has_infinity
            && ( x == std::numeric_limits<T>::infinity()
                 || x == -std::numeric_limits<T>::infinity());
    }

    template<class T>
    inline bool isinf_impl(T x, generic_tag<false> const&)
    {




        (void)x;
        return false;
    }

    template<class T>
    inline bool isinf_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        return a == traits::exponent;
    }

    template<class T>
    inline bool isinf_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        if(a != traits::exponent)
            return false;

        traits::set_bits(x,0);
        return x == 0;
    }
# 513 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
}

template<class T>
inline bool (isinf)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isinf_impl(static_cast<value_type>(x), method());
}
# 537 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
template<>
inline bool (isinf)(__float128 x)
{
   return ::isinfq(x);
}




namespace detail {


    template<class T>
    inline bool isnan_impl(T x, native_tag const&)
    {
        return (std::isnan)(x);
    }


    template<class T>
    inline bool isnan_impl(T x, generic_tag<true> const&)
    {
        return std::numeric_limits<T>::has_infinity
            ? !(x <= std::numeric_limits<T>::infinity())
            : x != x;
    }

    template<class T>
    inline bool isnan_impl(T x, generic_tag<false> const&)
    {




        (void)x;
        return false;
    }

    template<class T>
    inline bool isnan_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        return a > traits::exponent;
    }

    template<class T>
    inline bool isnan_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef typename fp_traits<T>::type traits;

        typename traits::bits a;
        traits::get_bits(x,a);

        a &= traits::exponent | traits::significand;
        if(a < traits::exponent)
            return false;

        a &= traits::significand;
        traits::set_bits(x,a);
        return x != 0;
    }

}

template<class T>
inline bool (isnan)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   return detail::isnan_impl(x, method());
}
# 629 "/usr/local/include/boost/math/special_functions/fpclassify.hpp" 3
template<>
inline bool (isnan)(__float128 x)
{
   return ::isnanq(x);
}


}
}
# 36 "/usr/local/include/boost/lexical_cast/detail/inf_nan.hpp" 2 3



namespace boost {
    namespace detail
    {
        template <class CharT>
        bool lc_iequal(const CharT* val, const CharT* lcase, const CharT* ucase, unsigned int len) noexcept {
            for( unsigned int i=0; i < len; ++i ) {
                if ( val[i] != lcase[i] && val[i] != ucase[i] ) return false;
            }

            return true;
        }


        template <class CharT, class T>
        inline bool parse_inf_nan_impl(const CharT* begin, const CharT* end, T& value
            , const CharT* lc_NAN, const CharT* lc_nan
            , const CharT* lc_INFINITY, const CharT* lc_infinity
            , const CharT opening_brace, const CharT closing_brace) noexcept
        {
            using namespace std;
            if (begin == end) return false;
            const CharT minus = lcast_char_constants<CharT>::minus;
            const CharT plus = lcast_char_constants<CharT>::plus;
            const int inifinity_size = 8;


            bool const has_minus = (*begin == minus);
            if (has_minus || *begin == plus) {
                ++ begin;
            }

            if (end - begin < 3) return false;
            if (lc_iequal(begin, lc_nan, lc_NAN, 3)) {
                begin += 3;
                if (end != begin) {


                    if (end - begin < 2) return false;
                    -- end;
                    if (*begin != opening_brace || *end != closing_brace) return false;
                }

                if( !has_minus ) value = std::numeric_limits<T>::quiet_NaN();
                else value = (boost::math::changesign) (std::numeric_limits<T>::quiet_NaN());
                return true;
            } else if (
                (
                  end - begin == 3
                  && lc_iequal(begin, lc_infinity, lc_INFINITY, 3)
                )
                ||
                (
                  end - begin == inifinity_size
                  && lc_iequal(begin, lc_infinity, lc_INFINITY, inifinity_size)
                )
             )
            {
                if( !has_minus ) value = std::numeric_limits<T>::infinity();
                else value = (boost::math::changesign) (std::numeric_limits<T>::infinity());
                return true;
            }

            return false;
        }

        template <class CharT, class T>
        bool put_inf_nan_impl(CharT* begin, CharT*& end, const T& value
                         , const CharT* lc_nan
                         , const CharT* lc_infinity) noexcept
        {
            using namespace std;
            const CharT minus = lcast_char_constants<CharT>::minus;
            if ((boost::math::isnan)(value)) {
                if ((boost::math::signbit)(value)) {
                    *begin = minus;
                    ++ begin;
                }

                memcpy(begin, lc_nan, 3 * sizeof(CharT));
                end = begin + 3;
                return true;
            } else if ((boost::math::isinf)(value)) {
                if ((boost::math::signbit)(value)) {
                    *begin = minus;
                    ++ begin;
                }

                memcpy(begin, lc_infinity, 3 * sizeof(CharT));
                end = begin + 3;
                return true;
            }

            return false;
        }



        template <class T>
        bool parse_inf_nan(const wchar_t* begin, const wchar_t* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , L"NAN", L"nan"
                               , L"INFINITY", L"infinity"
                               , L'(', L')');
        }

        template <class T>
        bool put_inf_nan(wchar_t* begin, wchar_t*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, L"nan", L"infinity");
        }



        template <class T>
        bool parse_inf_nan(const char16_t* begin, const char16_t* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , u"NAN", u"nan"
                               , u"INFINITY", u"infinity"
                               , u'(', u')');
        }

        template <class T>
        bool put_inf_nan(char16_t* begin, char16_t*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, u"nan", u"infinity");
        }


        template <class T>
        bool parse_inf_nan(const char32_t* begin, const char32_t* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , U"NAN", U"nan"
                               , U"INFINITY", U"infinity"
                               , U'(', U')');
        }

        template <class T>
        bool put_inf_nan(char32_t* begin, char32_t*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, U"nan", U"infinity");
        }


        template <class CharT, class T>
        bool parse_inf_nan(const CharT* begin, const CharT* end, T& value) noexcept {
            return parse_inf_nan_impl(begin, end, value
                               , "NAN", "nan"
                               , "INFINITY", "infinity"
                               , '(', ')');
        }

        template <class CharT, class T>
        bool put_inf_nan(CharT* begin, CharT*& end, const T& value) noexcept {
            return put_inf_nan_impl(begin, end, value, "nan", "infinity");
        }
    }
}
# 64 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3
# 78 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
# 1 "/usr/local/include/boost/detail/basic_pointerbuf.hpp" 1 3
# 24 "/usr/local/include/boost/detail/basic_pointerbuf.hpp" 3
namespace boost { namespace detail {





template <class charT, class BufferT >
class basic_pointerbuf : public BufferT {
protected:
   typedef BufferT base_type;
   typedef basic_pointerbuf<charT, BufferT> this_type;
   typedef typename base_type::int_type int_type;
   typedef typename base_type::char_type char_type;
   typedef typename base_type::pos_type pos_type;
   typedef ::std::streamsize streamsize;
   typedef typename base_type::off_type off_type;

public:
   basic_pointerbuf() : base_type() { this_type::setbuf(0, 0); }
   const charT* getnext() { return this->gptr(); }


    using base_type::pptr;
    using base_type::pbase;





protected:




   inline base_type* setbuf(char_type* s, streamsize n);
   inline typename this_type::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);
   inline typename this_type::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);

private:
   basic_pointerbuf& operator=(const basic_pointerbuf&);
   basic_pointerbuf(const basic_pointerbuf&);
};

template<class charT, class BufferT>
BufferT*
basic_pointerbuf<charT, BufferT>::setbuf(char_type* s, streamsize n)
{
   this->setg(s, s, s + n);
   return this;
}

template<class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
{
   typedef typename boost::int_t<sizeof(way) * 8>::least cast_type;

   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   std::ptrdiff_t size = this->egptr() - this->eback();
   std::ptrdiff_t pos = this->gptr() - this->eback();
   charT* g = this->eback();
   switch(static_cast<cast_type>(way))
   {
   case ::std::ios_base::beg:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + off, g + size);
      break;
   case ::std::ios_base::end:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + size - off, g + size);
      break;
   case ::std::ios_base::cur:
   {
      std::ptrdiff_t newpos = static_cast<std::ptrdiff_t>(pos + off);
      if((newpos < 0) || (newpos > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + newpos, g + size);
      break;
   }
   default: ;
   }




   return static_cast<pos_type>(this->gptr() - this->eback());



}

template<class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekpos(pos_type sp, ::std::ios_base::openmode which)
{
   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   off_type size = static_cast<off_type>(this->egptr() - this->eback());
   charT* g = this->eback();
   if(off_type(sp) <= size)
   {
      this->setg(g, g + off_type(sp), g + size);
   }
   return pos_type(off_type(-1));
}

}}
# 79 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3


# 1 "/usr/include/c++/7/cwchar" 1 3
# 39 "/usr/include/c++/7/cwchar" 3
       
# 40 "/usr/include/c++/7/cwchar" 3
# 82 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2 3


namespace boost {

    namespace detail
    {


        template <class BufferType, class CharT>
        class basic_unlockedbuf : public basic_pointerbuf<CharT, BufferType> {
        public:
           typedef basic_pointerbuf<CharT, BufferType> base_type;
           typedef typename base_type::streamsize streamsize;


            using base_type::pptr;
            using base_type::pbase;
            using base_type::setbuf;





        };
    }

    namespace detail
    {
        struct do_not_construct_out_buffer_t{};
        struct do_not_construct_out_stream_t{
            do_not_construct_out_stream_t(do_not_construct_out_buffer_t*){}
        };

        template <class CharT, class Traits>
        struct out_stream_helper_trait {
# 125 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
            typedef std::basic_ostream<CharT, Traits> out_stream_t;
            typedef basic_unlockedbuf<std::basic_stringbuf<CharT, Traits>, CharT> stringbuffer_t;
            typedef basic_unlockedbuf<std::basic_streambuf<CharT, Traits>, CharT> buffer_t;

        };
    }

    namespace detail
    {
        template< class CharT
                , class Traits
                , bool RequiresStringbuffer
                , std::size_t CharacterBufferSize
                >
        class lexical_istream_limited_src: boost::noncopyable {
            typedef typename boost::conditional<
                RequiresStringbuffer,
                typename out_stream_helper_trait<CharT, Traits>::out_stream_t,
                do_not_construct_out_stream_t
            >::type deduced_out_stream_t;

            typedef typename boost::conditional<
                RequiresStringbuffer,
                typename out_stream_helper_trait<CharT, Traits>::stringbuffer_t,
                do_not_construct_out_buffer_t
            >::type deduced_out_buffer_t;

            deduced_out_buffer_t out_buffer;
            deduced_out_stream_t out_stream;
            CharT buffer[CharacterBufferSize];



            const CharT* start;
            const CharT* finish;

        public:
            lexical_istream_limited_src() noexcept
              : out_buffer()
              , out_stream(&out_buffer)
              , start(buffer)
              , finish(buffer + CharacterBufferSize)
            {}

            const CharT* cbegin() const noexcept {
                return start;
            }

            const CharT* cend() const noexcept {
                return finish;
            }

        private:

            bool shl_char(CharT ch) noexcept {
                Traits::assign(buffer[0], ch);
                finish = start + 1;
                return true;
            }


            template <class T>
            bool shl_char(T ch) {
                static_assert(( sizeof(T) <= sizeof(CharT)) , "boost::lexical_cast does not support narrowing of char types." "Use boost::locale instead")

                                                 ;

                std::locale loc;
                CharT const w = std::use_facet< std::ctype<CharT> >(loc).widen(ch);



                Traits::assign(buffer[0], w);
                finish = start + 1;
                return true;
            }


            bool shl_char_array(CharT const* str_value) noexcept {
                start = str_value;
                finish = start + Traits::length(str_value);
                return true;
            }

            template <class T>
            bool shl_char_array(T const* str_value) {
                static_assert(( sizeof(T) <= sizeof(CharT)), "boost::lexical_cast does not support narrowing of char types." "Use boost::locale instead")

                                                 ;
                return shl_input_streamable(str_value);
            }

            bool shl_char_array_limited(CharT const* str, std::size_t max_size) noexcept {
                start = str;
                finish = std::find(start, start + max_size, Traits::to_char_type(0));
                return true;
            }

            template<typename InputStreamable>
            bool shl_input_streamable(InputStreamable& input) {







                out_stream.exceptions(std::ios::badbit);
                try {

                bool const result = !(out_stream << input).fail();
                const deduced_out_buffer_t* const p = static_cast<deduced_out_buffer_t*>(
                    out_stream.rdbuf()
                );
                start = p->pbase();
                finish = p->pptr();
                return result;

                } catch (const ::std::ios_base::failure& ) {
                    return false;
                }

            }

            template <class T>
            inline bool shl_unsigned(const T n) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                start = lcast_put_unsigned<Traits, T, CharT>(n, tmp_finish).convert();
                finish = tmp_finish;
                return true;
            }

            template <class T>
            inline bool shl_signed(const T n) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                typedef typename boost::make_unsigned<T>::type utype;
                CharT* tmp_start = lcast_put_unsigned<Traits, utype, CharT>(lcast_to_unsigned(n), tmp_finish).convert();
                if (n < 0) {
                    --tmp_start;
                    CharT const minus = lcast_char_constants<CharT>::minus;
                    Traits::assign(*tmp_start, minus);
                }
                start = tmp_start;
                finish = tmp_finish;
                return true;
            }

            template <class T, class SomeCharT>
            bool shl_real_type(const T& val, SomeCharT* ) {
                lcast_set_precision(out_stream, &val);
                return shl_input_streamable(val);
            }

            bool shl_real_type(float val, char* begin) {
                using namespace std;
                const double val_as_double = val;
                finish = start +



                    sprintf(begin,

                    "%.*g", static_cast<int>(boost::detail::lcast_get_precision<float>()), val_as_double);
                return finish > start;
            }

            bool shl_real_type(double val, char* begin) {
                using namespace std;
                finish = start +



                    sprintf(begin,

                    "%.*g", static_cast<int>(boost::detail::lcast_get_precision<double>()), val);
                return finish > start;
            }


            bool shl_real_type(long double val, char* begin) {
                using namespace std;
                finish = start +



                    sprintf(begin,

                    "%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double>()), val );
                return finish > start;
            }




            bool shl_real_type(float val, wchar_t* begin) {
                using namespace std;
                const double val_as_double = val;
                finish = start + swprintf(begin, CharacterBufferSize,
                                       L"%.*g",
                                       static_cast<int>(boost::detail::lcast_get_precision<float >()),
                                       val_as_double );
                return finish > start;
            }

            bool shl_real_type(double val, wchar_t* begin) {
                using namespace std;
                finish = start + swprintf(begin, CharacterBufferSize,
                                          L"%.*g", static_cast<int>(boost::detail::lcast_get_precision<double >()), val );
                return finish > start;
            }

            bool shl_real_type(long double val, wchar_t* begin) {
                using namespace std;
                finish = start + swprintf(begin, CharacterBufferSize,
                                          L"%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double >()), val );
                return finish > start;
            }

            template <class T>
            bool shl_real(T val) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                if (put_inf_nan(buffer, tmp_finish, val)) {
                    finish = tmp_finish;
                    return true;
                }

                return shl_real_type(val, static_cast<CharT*>(buffer));
            }


        public:
            template<class Alloc>
            bool operator<<(std::basic_string<CharT,Traits,Alloc> const& str) noexcept {
                start = str.data();
                finish = start + str.length();
                return true;
            }

            template<class Alloc>
            bool operator<<(boost::container::basic_string<CharT,Traits,Alloc> const& str) noexcept {
                start = str.data();
                finish = start + str.length();
                return true;
            }

            bool operator<<(bool value) noexcept {
                CharT const czero = lcast_char_constants<CharT>::zero;
                Traits::assign(buffer[0], Traits::to_char_type(czero + value));
                finish = start + 1;
                return true;
            }

            template <class C>
            typename boost::disable_if<boost::is_const<C>, bool>::type
            operator<<(const iterator_range<C*>& rng) noexcept {
                return (*this) << iterator_range<const C*>(rng.begin(), rng.end());
            }

            bool operator<<(const iterator_range<const CharT*>& rng) noexcept {
                start = rng.begin();
                finish = rng.end();
                return true;
            }

            bool operator<<(const iterator_range<const signed char*>& rng) noexcept {
                return (*this) << iterator_range<const char*>(
                    reinterpret_cast<const char*>(rng.begin()),
                    reinterpret_cast<const char*>(rng.end())
                );
            }

            bool operator<<(const iterator_range<const unsigned char*>& rng) noexcept {
                return (*this) << iterator_range<const char*>(
                    reinterpret_cast<const char*>(rng.begin()),
                    reinterpret_cast<const char*>(rng.end())
                );
            }

            bool operator<<(char ch) { return shl_char(ch); }
            bool operator<<(unsigned char ch) { return ((*this) << static_cast<char>(ch)); }
            bool operator<<(signed char ch) { return ((*this) << static_cast<char>(ch)); }

            bool operator<<(wchar_t const* str) { return shl_char_array(str); }
            bool operator<<(wchar_t * str) { return shl_char_array(str); }

            bool operator<<(wchar_t ch) { return shl_char(ch); }



            bool operator<<(char16_t ch) { return shl_char(ch); }
            bool operator<<(char16_t * str) { return shl_char_array(str); }
            bool operator<<(char16_t const * str) { return shl_char_array(str); }


            bool operator<<(char32_t ch) { return shl_char(ch); }
            bool operator<<(char32_t * str) { return shl_char_array(str); }
            bool operator<<(char32_t const * str) { return shl_char_array(str); }

            bool operator<<(unsigned char const* ch) { return ((*this) << reinterpret_cast<char const*>(ch)); }
            bool operator<<(unsigned char * ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
            bool operator<<(signed char const* ch) { return ((*this) << reinterpret_cast<char const*>(ch)); }
            bool operator<<(signed char * ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
            bool operator<<(char const* str_value) { return shl_char_array(str_value); }
            bool operator<<(char* str_value) { return shl_char_array(str_value); }
            bool operator<<(short n) { return shl_signed(n); }
            bool operator<<(int n) { return shl_signed(n); }
            bool operator<<(long n) { return shl_signed(n); }
            bool operator<<(unsigned short n) { return shl_unsigned(n); }
            bool operator<<(unsigned int n) { return shl_unsigned(n); }
            bool operator<<(unsigned long n) { return shl_unsigned(n); }


            bool operator<<(boost::ulong_long_type n) { return shl_unsigned(n); }
            bool operator<<(boost::long_long_type n) { return shl_signed(n); }






            bool operator<<(const boost::uint128_type& n) { return shl_unsigned(n); }
            bool operator<<(const boost::int128_type& n) { return shl_signed(n); }

            bool operator<<(float val) { return shl_real(val); }
            bool operator<<(double val) { return shl_real(val); }
            bool operator<<(long double val) {

                return shl_real(val);



            }


            template <class C, std::size_t N>
            typename boost::disable_if<boost::is_const<C>, bool>::type
            operator<<(boost::array<C, N> const& input) noexcept {
                static_assert((sizeof(boost::array<const C, N>) == sizeof(boost::array<C, N>)), "boost::array<C, N> and boost::array<const C, N> must have exactly the same layout.")


                 ;
                return ((*this) << reinterpret_cast<boost::array<const C, N> const& >(input));
            }

            template <std::size_t N>
            bool operator<<(boost::array<const CharT, N> const& input) noexcept {
                return shl_char_array_limited(input.data(), N);
            }

            template <std::size_t N>
            bool operator<<(boost::array<const unsigned char, N> const& input) noexcept {
                return ((*this) << reinterpret_cast<boost::array<const char, N> const& >(input));
            }

            template <std::size_t N>
            bool operator<<(boost::array<const signed char, N> const& input) noexcept {
                return ((*this) << reinterpret_cast<boost::array<const char, N> const& >(input));
            }



            template <class C, std::size_t N>
            bool operator<<(std::array<C, N> const& input) noexcept {
                static_assert((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>)), "std::array and boost::array must have exactly the same layout. " "Bug in implementation of std::array or boost::array.")



                 ;
                return ((*this) << reinterpret_cast<boost::array<C, N> const& >(input));
            }

            template <class InStreamable>
            bool operator<<(const InStreamable& input) { return shl_input_streamable(input); }
        };


        template <class CharT, class Traits>
        class lexical_ostream_limited_src: boost::noncopyable {

            const CharT* start;
            const CharT* const finish;

        public:
            lexical_ostream_limited_src(const CharT* begin, const CharT* end) noexcept
              : start(begin)
              , finish(end)
            {}


        private:
            template <typename Type>
            bool shr_unsigned(Type& output) {
                if (start == finish) return false;
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                bool const has_minus = Traits::eq(minus, *start);


                if (has_minus || Traits::eq(plus, *start)) {
                    ++start;
                }

                bool const succeed = lcast_ret_unsigned<Traits, Type, CharT>(output, start, finish).convert();

                if (has_minus) {
                    output = static_cast<Type>(0u - output);
                }

                return succeed;
            }

            template <typename Type>
            bool shr_signed(Type& output) {
                if (start == finish) return false;
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                typedef typename make_unsigned<Type>::type utype;
                utype out_tmp = 0;
                bool const has_minus = Traits::eq(minus, *start);


                if (has_minus || Traits::eq(plus, *start)) {
                    ++start;
                }

                bool succeed = lcast_ret_unsigned<Traits, utype, CharT>(out_tmp, start, finish).convert();
                if (has_minus) {
                    utype const comp_val = (static_cast<utype>(1) << std::numeric_limits<Type>::digits);
                    succeed = succeed && out_tmp<=comp_val;
                    output = static_cast<Type>(0u - out_tmp);
                } else {
                    utype const comp_val = static_cast<utype>((std::numeric_limits<Type>::max)());
                    succeed = succeed && out_tmp<=comp_val;
                    output = static_cast<Type>(out_tmp);
                }
                return succeed;
            }

            template<typename InputStreamable>
            bool shr_using_base_class(InputStreamable& output)
            {
                static_assert((!boost::is_pointer<InputStreamable>::value), "boost::lexical_cast can not convert to pointers")


                 ;
# 581 "/usr/local/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                typedef typename out_stream_helper_trait<CharT, Traits>::buffer_t buffer_t;
                buffer_t buf;


                buf.setbuf(const_cast<CharT*>(start), static_cast<typename buffer_t::streamsize>(finish - start));



                std::basic_istream<CharT, Traits> stream(&buf);




                stream.exceptions(std::ios::badbit);
                try {

                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<InputStreamable*>(0));

                return (stream >> output)
                    && (stream.get() == Traits::eof());


                } catch (const ::std::ios_base::failure& ) {
                    return false;
                }

            }

            template<class T>
            inline bool shr_xchar(T& output) noexcept {
                static_assert(( sizeof(CharT) == sizeof(T) ), "boost::lexical_cast does not support narrowing of character types." "Use boost::locale instead")

                                                 ;
                bool const ok = (finish - start == 1);
                if (ok) {
                    CharT out;
                    Traits::assign(out, *start);
                    output = static_cast<T>(out);
                }
                return ok;
            }

            template <std::size_t N, class ArrayT>
            bool shr_std_array(ArrayT& output) noexcept {
                using namespace std;
                const std::size_t size = static_cast<std::size_t>(finish - start);
                if (size > N - 1) {
                    return false;
                }

                memcpy(&output[0], start, size * sizeof(CharT));
                output[size] = Traits::to_char_type(0);
                return true;
            }


        public:
            bool operator>>(unsigned short& output) { return shr_unsigned(output); }
            bool operator>>(unsigned int& output) { return shr_unsigned(output); }
            bool operator>>(unsigned long int& output) { return shr_unsigned(output); }
            bool operator>>(short& output) { return shr_signed(output); }
            bool operator>>(int& output) { return shr_signed(output); }
            bool operator>>(long int& output) { return shr_signed(output); }

            bool operator>>(boost::ulong_long_type& output) { return shr_unsigned(output); }
            bool operator>>(boost::long_long_type& output) { return shr_signed(output); }






            bool operator>>(boost::uint128_type& output) { return shr_unsigned(output); }
            bool operator>>(boost::int128_type& output) { return shr_signed(output); }


            bool operator>>(char& output) { return shr_xchar(output); }
            bool operator>>(unsigned char& output) { return shr_xchar(output); }
            bool operator>>(signed char& output) { return shr_xchar(output); }

            bool operator>>(wchar_t& output) { return shr_xchar(output); }


            bool operator>>(char16_t& output) { return shr_xchar(output); }


            bool operator>>(char32_t& output) { return shr_xchar(output); }

            template<class Alloc>
            bool operator>>(std::basic_string<CharT,Traits,Alloc>& str) {
                str.assign(start, finish); return true;
            }

            template<class Alloc>
            bool operator>>(boost::container::basic_string<CharT,Traits,Alloc>& str) {
                str.assign(start, finish); return true;
            }

            template <std::size_t N>
            bool operator>>(boost::array<CharT, N>& output) noexcept {
                return shr_std_array<N>(output);
            }

            template <std::size_t N>
            bool operator>>(boost::array<unsigned char, N>& output) noexcept {
                return ((*this) >> reinterpret_cast<boost::array<char, N>& >(output));
            }

            template <std::size_t N>
            bool operator>>(boost::array<signed char, N>& output) noexcept {
                return ((*this) >> reinterpret_cast<boost::array<char, N>& >(output));
            }


            template <class C, std::size_t N>
            bool operator>>(std::array<C, N>& output) noexcept {
                static_assert((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>)), "std::array<C, N> and boost::array<C, N> must have exactly the same layout.")


                 ;
                return ((*this) >> reinterpret_cast<boost::array<C, N>& >(output));
            }


            bool operator>>(bool& output) noexcept {
                output = false;

                if (start == finish) return false;
                CharT const zero = lcast_char_constants<CharT>::zero;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const minus = lcast_char_constants<CharT>::minus;

                const CharT* const dec_finish = finish - 1;
                output = Traits::eq(*dec_finish, zero + 1);
                if (!output && !Traits::eq(*dec_finish, zero)) {
                    return false;
                }

                if (start == dec_finish) return true;


                if (Traits::eq(plus, *start) || (Traits::eq(minus, *start) && !output)) {
                    ++ start;
                }


                while (start != dec_finish) {
                    if (!Traits::eq(zero, *start)) {
                        return false;
                    }

                    ++ start;
                }

                return true;
            }

        private:

            template <class T>
            bool float_types_converter_internal(T& output) {
                if (parse_inf_nan(start, finish, output)) return true;
                bool const return_value = shr_using_base_class(output);







                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const capital_e = lcast_char_constants<CharT>::capital_e;
                CharT const lowercase_e = lcast_char_constants<CharT>::lowercase_e;
                if ( return_value &&
                     (
                        Traits::eq(*(finish-1), lowercase_e)
                        || Traits::eq(*(finish-1), capital_e)
                        || Traits::eq(*(finish-1), minus)
                        || Traits::eq(*(finish-1), plus)
                     )
                ) return false;

                return return_value;
            }

        public:
            bool operator>>(float& output) { return float_types_converter_internal(output); }
            bool operator>>(double& output) { return float_types_converter_internal(output); }
            bool operator>>(long double& output) { return float_types_converter_internal(output); }



            template <typename InputStreamable>
            bool operator>>(InputStreamable& output) {
                return shr_using_base_class(output);
            }
        };
    }
}
# 55 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 2 3

namespace boost {

    namespace detail
    {

        template < class Char >
        struct normalize_single_byte_char
        {
            typedef Char type;
        };

        template <>
        struct normalize_single_byte_char< signed char >
        {
            typedef char type;
        };

        template <>
        struct normalize_single_byte_char< unsigned char >
        {
            typedef char type;
        };
    }

    namespace detail
    {


        template < class T > struct deduce_character_type_later {};
    }

    namespace detail
    {



        template < typename Type >
        struct stream_char_common: public boost::conditional<
            boost::detail::is_character< Type >::value,
            Type,
            boost::detail::deduce_character_type_later< Type >
        > {};

        template < typename Char >
        struct stream_char_common< Char* >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< Char* >
        > {};

        template < typename Char >
        struct stream_char_common< const Char* >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< const Char* >
        > {};

        template < typename Char >
        struct stream_char_common< boost::iterator_range< Char* > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::iterator_range< Char* > >
        > {};

        template < typename Char >
        struct stream_char_common< boost::iterator_range< const Char* > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::iterator_range< const Char* > >
        > {};

        template < class Char, class Traits, class Alloc >
        struct stream_char_common< std::basic_string< Char, Traits, Alloc > >
        {
            typedef Char type;
        };

        template < class Char, class Traits, class Alloc >
        struct stream_char_common< boost::container::basic_string< Char, Traits, Alloc > >
        {
            typedef Char type;
        };

        template < typename Char, std::size_t N >
        struct stream_char_common< boost::array< Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::array< Char, N > >
        > {};

        template < typename Char, std::size_t N >
        struct stream_char_common< boost::array< const Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::array< const Char, N > >
        > {};


        template < typename Char, std::size_t N >
        struct stream_char_common< std::array<Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< std::array< Char, N > >
        > {};

        template < typename Char, std::size_t N >
        struct stream_char_common< std::array< const Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< std::array< const Char, N > >
        > {};



        template <> struct stream_char_common< boost::int128_type >: public boost::type_identity< char > {};
        template <> struct stream_char_common< boost::uint128_type >: public boost::type_identity< char > {};
# 181 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
    }

    namespace detail
    {





        template < class Char >
        struct deduce_source_char_impl
        {
            typedef typename boost::detail::normalize_single_byte_char< Char >::type type;
        };

        template < class T >
        struct deduce_source_char_impl< deduce_character_type_later< T > >
        {
            typedef boost::has_left_shift< std::basic_ostream< char >, T > result_t;






            typedef typename boost::conditional<
                result_t::value, char, wchar_t
            >::type type;

            static_assert((result_t::value || boost::has_left_shift< std::basic_ostream< type >, T >::value), "Source type is neither std::ostream`able nor std::wostream`able")
                                                                                  ;

        };
    }

    namespace detail
    {





        template < class Char >
        struct deduce_target_char_impl
        {
            typedef typename normalize_single_byte_char< Char >::type type;
        };

        template < class T >
        struct deduce_target_char_impl< deduce_character_type_later<T> >
        {
            typedef boost::has_right_shift<std::basic_istream<char>, T > result_t;






            typedef typename boost::conditional<
                result_t::value, char, wchar_t
            >::type type;

            static_assert((result_t::value || boost::has_right_shift<std::basic_istream<wchar_t>, T >::value), "Target type is neither std::istream`able nor std::wistream`able")
                                                                                  ;

        };
    }

    namespace detail
    {
# 266 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
        template < class T >
        struct deduce_target_char
        {
            typedef typename stream_char_common< T >::type stage1_type;
            typedef typename deduce_target_char_impl< stage1_type >::type stage2_type;

            typedef stage2_type type;
        };

        template < class T >
        struct deduce_source_char
        {
            typedef typename stream_char_common< T >::type stage1_type;
            typedef typename deduce_source_char_impl< stage1_type >::type stage2_type;

            typedef stage2_type type;
        };
    }

    namespace detail
    {


        template < class Char, class T >
        struct extract_char_traits
                : boost::false_type
        {
            typedef std::char_traits< Char > trait_t;
        };

        template < class Char, class Traits, class Alloc >
        struct extract_char_traits< Char, std::basic_string< Char, Traits, Alloc > >
            : boost::true_type
        {
            typedef Traits trait_t;
        };

        template < class Char, class Traits, class Alloc>
        struct extract_char_traits< Char, boost::container::basic_string< Char, Traits, Alloc > >
            : boost::true_type
        {
            typedef Traits trait_t;
        };
    }

    namespace detail
    {
        template<class T>
        struct array_to_pointer_decay
        {
            typedef T type;
        };

        template<class T, std::size_t N>
        struct array_to_pointer_decay<T[N]>
        {
            typedef const T * type;
        };
    }

    namespace detail
    {

        template< class Source,
                  class Enable = void
                >
        struct lcast_src_length
        {
            static const std::size_t value = 1;
        };
# 350 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
        template <class Source>
        struct lcast_src_length<
                    Source, typename boost::enable_if<boost::is_integral<Source> >::type
                >
        {

            static const std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2



               ;




        };
# 377 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
        template<class Source>
        struct lcast_src_length<
                Source, typename boost::enable_if<boost::is_float<Source> >::type
            >
        {


            static_assert(std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L, "std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L")


                 ;

            static const std::size_t value = 5 + lcast_precision<Source>::value + 6

                 ;



        };
    }

    namespace detail
    {
        template <class Source, class Target>
        struct lexical_cast_stream_traits {
            typedef typename boost::detail::array_to_pointer_decay<Source>::type src;
            typedef typename boost::remove_cv<src>::type no_cv_src;

            typedef boost::detail::deduce_source_char<no_cv_src> deduce_src_char_metafunc;
            typedef typename deduce_src_char_metafunc::type src_char_t;
            typedef typename boost::detail::deduce_target_char<Target>::type target_char_t;

            typedef typename boost::detail::widest_char<
                target_char_t, src_char_t
            >::type char_type;
# 424 "/usr/local/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
            typedef typename boost::conditional<
                boost::detail::extract_char_traits<char_type, Target>::value,
                typename boost::detail::extract_char_traits<char_type, Target>,
                typename boost::detail::extract_char_traits<char_type, no_cv_src>
            >::type::trait_t traits;

            typedef boost::integral_constant<
              bool,
              boost::is_same<char, src_char_t>::value &&
                (sizeof(char) != sizeof(target_char_t)) &&
                (!(boost::detail::is_character<no_cv_src>::value))
             > is_string_widening_required_t;

            typedef boost::integral_constant<
              bool,
             !(boost::is_integral<no_cv_src>::value ||
                  boost::detail::is_character<
                    typename deduce_src_char_metafunc::stage1_type
                  >::value
              )
             > is_source_input_not_optimized_t;



            static const bool requires_stringbuf = (is_string_widening_required_t::value || is_source_input_not_optimized_t::value)

             ;

            typedef boost::detail::lcast_src_length<no_cv_src> len_t;
        };
    }

    namespace detail
    {
        template<typename Target, typename Source>
        struct lexical_converter_impl
        {
            typedef lexical_cast_stream_traits<Source, Target> stream_trait;

            typedef detail::lexical_istream_limited_src<
                typename stream_trait::char_type,
                typename stream_trait::traits,
                stream_trait::requires_stringbuf,
                stream_trait::len_t::value + 1
            > i_interpreter_type;

            typedef detail::lexical_ostream_limited_src<
                typename stream_trait::char_type,
                typename stream_trait::traits
            > o_interpreter_type;

            static inline bool try_convert(const Source& arg, Target& result) {
                i_interpreter_type i_interpreter;


                if (!(i_interpreter.operator <<(arg)))
                    return false;

                o_interpreter_type out(i_interpreter.cbegin(), i_interpreter.cend());


                if(!(out.operator >>(result)))
                    return false;

                return true;
            }
        };
    }

}
# 45 "/usr/local/include/boost/lexical_cast/try_lexical_convert.hpp" 2 3




namespace boost {
    namespace detail
    {
        template<typename T>
        struct is_stdstring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_stdstring< std::basic_string<CharT, Traits, Alloc> >
            : boost::true_type
        {};



        template<typename T>
        struct is_booststring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_booststring< boost::container::basic_string<CharT, Traits, Alloc> >
            : boost::true_type
        {};

        template<typename Target, typename Source>
        struct is_arithmetic_and_not_xchars
        {
            typedef boost::integral_constant<
                bool,
                !(boost::detail::is_character<Target>::value) &&
                    !(boost::detail::is_character<Source>::value) &&
                    boost::is_arithmetic<Source>::value &&
                    boost::is_arithmetic<Target>::value
                > type;

            static const bool value = ( type::value )

              ;
        };





        template<typename Target, typename Source>
        struct is_xchar_to_xchar
        {
            typedef boost::integral_constant<
                bool,
                sizeof(Source) == sizeof(Target) &&
                     sizeof(Source) == sizeof(char) &&
                     boost::detail::is_character<Target>::value &&
                     boost::detail::is_character<Source>::value
                > type;

            static const bool value = ( type::value )

              ;
        };

        template<typename Target, typename Source>
        struct is_char_array_to_stdstring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, CharT* >
            : boost::true_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, const CharT* >
            : boost::true_type
        {};



        template<typename Target, typename Source>
        struct is_char_array_to_booststring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_booststring< boost::container::basic_string<CharT, Traits, Alloc>, CharT* >
            : boost::true_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_booststring< boost::container::basic_string<CharT, Traits, Alloc>, const CharT* >
            : boost::true_type
        {};

        template <typename Target, typename Source>
        struct copy_converter_impl
        {



            template <class T>
            static inline bool try_convert(T&& arg, Target& result) {
                result = static_cast<T&&>(arg);
                return true;
            }






        };
    }

    namespace conversion { namespace detail {

        template <typename Target, typename Source>
        inline bool try_lexical_convert(const Source& arg, Target& result)
        {
            typedef typename boost::detail::array_to_pointer_decay<Source>::type src;

            typedef boost::integral_constant<
                bool,
                boost::detail::is_xchar_to_xchar<Target, src >::value ||
                boost::detail::is_char_array_to_stdstring<Target, src >::value ||
                boost::detail::is_char_array_to_booststring<Target, src >::value ||
                (
                     boost::is_same<Target, src >::value &&
                     (boost::detail::is_stdstring<Target >::value || boost::detail::is_booststring<Target >::value)
                ) ||
                (
                     boost::is_same<Target, src >::value &&
                     boost::detail::is_character<Target >::value
                )
            > shall_we_copy_t;

            typedef boost::detail::is_arithmetic_and_not_xchars<Target, src >
                shall_we_copy_with_dynamic_check_t;



            typedef typename boost::conditional<
                shall_we_copy_t::value,
                boost::type_identity<boost::detail::copy_converter_impl<Target, src > >,
                boost::conditional<
                     shall_we_copy_with_dynamic_check_t::value,
                     boost::detail::dynamic_num_converter_impl<Target, src >,
                     boost::detail::lexical_converter_impl<Target, src >
                >
            >::type caster_type_lazy;

            typedef typename caster_type_lazy::type caster_type;

            return caster_type::try_convert(arg, result);
        }

        template <typename Target, typename CharacterT>
        inline bool try_lexical_convert(const CharacterT* chars, std::size_t count, Target& result)
        {
            static_assert(boost::detail::is_character<CharacterT>::value, "This overload of try_lexical_convert is meant to be used only with arrays of characters.")


             ;
            return ::boost::conversion::detail::try_lexical_convert(
                ::boost::iterator_range<const CharacterT*>(chars, chars + count), result
            );
        }

    }}

    namespace conversion {

        using ::boost::conversion::detail::try_lexical_convert;
    }

}




#pragma GCC diagnostic pop
# 33 "/usr/local/include/boost/lexical_cast.hpp" 2 3

namespace boost
{
    template <typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        Target result = Target();

        if (!boost::conversion::detail::try_lexical_convert(arg, result)) {
            boost::conversion::detail::throw_bad_cast<Source, Target>();
        }

        return result;
    }

    template <typename Target>
    inline Target lexical_cast(const char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char*>(chars, chars + count)
        );
    }

    template <typename Target>
    inline Target lexical_cast(const unsigned char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const unsigned char*>(chars, chars + count)
        );
    }

    template <typename Target>
    inline Target lexical_cast(const signed char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const signed char*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const wchar_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const wchar_t*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const char16_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char16_t*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const char32_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char32_t*>(chars, chars + count)
        );
    }


}
# 20 "/usr/local/include/boost/python/operators.hpp" 2 3





namespace boost { namespace python {

namespace detail
{


  template <class T>
  PyObject* convert_result(T const& x)
  {
      return converter::arg_to_python<T>(x).release();
  }



  template <operator_id> struct operator_l
  {
      template <class L, class R> struct apply;
  };

  template <operator_id> struct operator_r
  {
      template <class L, class R> struct apply;
  };

  template <operator_id> struct operator_1
  {
      template <class T> struct apply;
  };




  template <operator_id id, class L, class R>
  struct operator_l_inner
      : operator_l<id>::template apply<L,R>
  {};

  template <operator_id id, class L, class R>
  struct operator_r_inner
      : operator_r<id>::template apply<L,R>
  {};

  template <operator_id id, class T>
  struct operator_1_inner
      : operator_1<id>::template apply<T>
  {};
# 84 "/usr/local/include/boost/python/operators.hpp" 3
  template <operator_id id>
  struct binary_op : operator_l<id>
  {
      template <class T>
      struct apply : operator_l_inner<id,T,T>
      {
      };
  };


  template <operator_id id, class R>
  struct binary_op_l : operator_l<id>
  {
      template <class T>
      struct apply : operator_l_inner<id,T,R>
      {
      };
  };


  template <operator_id id, class L>
  struct binary_op_r : operator_r<id>
  {
      template <class T>
      struct apply : operator_r_inner<id,L,T>
      {
      };
  };

  template <operator_id id>
  struct unary_op : operator_1<id>
  {
      template <class T>
      struct apply : operator_1_inner<id,T>
      {
      };
  };



  template <operator_id id, class L = not_specified, class R = not_specified>
  struct operator_
    : def_visitor<operator_<id,L,R> >
  {
   private:
      template <class ClassT>
      void visit(ClassT& cl) const
      {
          typedef typename mpl::eval_if<
              is_same<L,self_t>
            , mpl::if_<
                  is_same<R,self_t>
                , binary_op<id>
                , binary_op_l<
                      id
                    , typename unwrap_other<R>::type
                  >
              >
            , mpl::if_<
                  is_same<L,not_specified>
                , unary_op<id>
                , binary_op_r<
                      id
                    , typename unwrap_other<L>::type
                  >
              >
          >::type generator;

          cl.def(
              generator::name()
            , &generator::template apply<
                 typename ClassT::wrapped_type
              >::execute
          );
      }

      friend class python::def_visitor_access;
  };
}
# 212 "/usr/local/include/boost/python/operators.hpp" 3
namespace detail { template <> struct operator_l<op_add> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l + r); } }; static char const* name() { return "__" "add" "__"; } }; template <> struct operator_r<op_add> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l + r); } }; static char const* name() { return "__" "radd" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_add,L,R> operator +(L const&, R const&) { return detail::operator_<detail::op_add,L,R>(); } }
namespace detail { template <> struct operator_l<op_sub> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l - r); } }; static char const* name() { return "__" "sub" "__"; } }; template <> struct operator_r<op_sub> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l - r); } }; static char const* name() { return "__" "rsub" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_sub,L,R> operator -(L const&, R const&) { return detail::operator_<detail::op_sub,L,R>(); } }
namespace detail { template <> struct operator_l<op_mul> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l * r); } }; static char const* name() { return "__" "mul" "__"; } }; template <> struct operator_r<op_mul> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l * r); } }; static char const* name() { return "__" "rmul" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_mul,L,R> operator *(L const&, R const&) { return detail::operator_<detail::op_mul,L,R>(); } }



    namespace detail { template <> struct operator_l<op_div> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l / r); } }; static char const* name() { return "__" "div" "__"; } }; template <> struct operator_r<op_div> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l / r); } }; static char const* name() { return "__" "rdiv" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_div,L,R> operator /(L const&, R const&) { return detail::operator_<detail::op_div,L,R>(); } }

namespace detail { template <> struct operator_l<op_mod> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l % r); } }; static char const* name() { return "__" "mod" "__"; } }; template <> struct operator_r<op_mod> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l % r); } }; static char const* name() { return "__" "rmod" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_mod,L,R> operator %(L const&, R const&) { return detail::operator_<detail::op_mod,L,R>(); } }
namespace detail { template <> struct operator_l<op_lshift> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l << r); } }; static char const* name() { return "__" "lshift" "__"; } }; template <> struct operator_r<op_lshift> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l << r); } }; static char const* name() { return "__" "rlshift" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_lshift,L,R> operator <<(L const&, R const&) { return detail::operator_<detail::op_lshift,L,R>(); } }
namespace detail { template <> struct operator_l<op_rshift> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l >> r); } }; static char const* name() { return "__" "rshift" "__"; } }; template <> struct operator_r<op_rshift> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l >> r); } }; static char const* name() { return "__" "rrshift" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_rshift,L,R> operator >>(L const&, R const&) { return detail::operator_<detail::op_rshift,L,R>(); } }
namespace detail { template <> struct operator_l<op_and> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l & r); } }; static char const* name() { return "__" "and" "__"; } }; template <> struct operator_r<op_and> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l & r); } }; static char const* name() { return "__" "rand" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_and,L,R> operator &(L const&, R const&) { return detail::operator_<detail::op_and,L,R>(); } }
namespace detail { template <> struct operator_l<op_xor> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l ^ r); } }; static char const* name() { return "__" "xor" "__"; } }; template <> struct operator_r<op_xor> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l ^ r); } }; static char const* name() { return "__" "rxor" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_xor,L,R> operator ^(L const&, R const&) { return detail::operator_<detail::op_xor,L,R>(); } }
namespace detail { template <> struct operator_l<op_or> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l | r); } }; static char const* name() { return "__" "or" "__"; } }; template <> struct operator_r<op_or> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l | r); } }; static char const* name() { return "__" "ror" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_or,L,R> operator |(L const&, R const&) { return detail::operator_<detail::op_or,L,R>(); } }
namespace detail { template <> struct operator_l<op_gt> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l > r); } }; static char const* name() { return "__" "gt" "__"; } }; template <> struct operator_r<op_gt> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l > r); } }; static char const* name() { return "__" "lt" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_gt,L,R> operator >(L const&, R const&) { return detail::operator_<detail::op_gt,L,R>(); } }
namespace detail { template <> struct operator_l<op_ge> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l >= r); } }; static char const* name() { return "__" "ge" "__"; } }; template <> struct operator_r<op_ge> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l >= r); } }; static char const* name() { return "__" "le" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_ge,L,R> operator >=(L const&, R const&) { return detail::operator_<detail::op_ge,L,R>(); } }
namespace detail { template <> struct operator_l<op_lt> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l < r); } }; static char const* name() { return "__" "lt" "__"; } }; template <> struct operator_r<op_lt> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l < r); } }; static char const* name() { return "__" "gt" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_lt,L,R> operator <(L const&, R const&) { return detail::operator_<detail::op_lt,L,R>(); } }
namespace detail { template <> struct operator_l<op_le> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l <= r); } }; static char const* name() { return "__" "le" "__"; } }; template <> struct operator_r<op_le> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l <= r); } }; static char const* name() { return "__" "ge" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_le,L,R> operator <=(L const&, R const&) { return detail::operator_<detail::op_le,L,R>(); } }
namespace detail { template <> struct operator_l<op_eq> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l == r); } }; static char const* name() { return "__" "eq" "__"; } }; template <> struct operator_r<op_eq> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l == r); } }; static char const* name() { return "__" "eq" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_eq,L,R> operator ==(L const&, R const&) { return detail::operator_<detail::op_eq,L,R>(); } }
namespace detail { template <> struct operator_l<op_ne> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(l != r); } }; static char const* name() { return "__" "ne" "__"; } }; template <> struct operator_r<op_ne> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(l != r); } }; static char const* name() { return "__" "ne" "__"; } }; } namespace self_ns { template <class L, class R> inline detail::operator_<detail::op_ne,L,R> operator !=(L const&, R const&) { return detail::operator_<detail::op_ne,L,R>(); } }



namespace detail { template <> struct operator_l<op_pow> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(lhs& l, rhs const& r) { return detail::convert_result(pow(l,r)); } }; static char const* name() { return "__" "pow" "__"; } }; template <> struct operator_r<op_pow> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(rhs& r, lhs const& l) { return detail::convert_result(pow(l,r)); } }; static char const* name() { return "__" "rpow" "__"; } }; }


namespace self_ns
{

  template <class L, class R>
  inline detail::operator_<detail::op_pow,L,R>
  pow(L const&, R const&)
  {
      return detail::operator_<detail::op_pow,L,R>();
  }
# 271 "/usr/local/include/boost/python/operators.hpp" 3
}
# 305 "/usr/local/include/boost/python/operators.hpp" 3
namespace detail { template <> struct operator_l<op_iadd> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() += r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "iadd" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_iadd,self_t,R> operator +=(self_t const&, R const&) { return detail::operator_<detail::op_iadd,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_isub> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() -= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "isub" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_isub,self_t,R> operator -=(self_t const&, R const&) { return detail::operator_<detail::op_isub,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_imul> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() *= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "imul" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_imul,self_t,R> operator *=(self_t const&, R const&) { return detail::operator_<detail::op_imul,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_idiv> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() /= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "idiv" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_idiv,self_t,R> operator /=(self_t const&, R const&) { return detail::operator_<detail::op_idiv,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_imod> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() %= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "imod" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_imod,self_t,R> operator %=(self_t const&, R const&) { return detail::operator_<detail::op_imod,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_ilshift> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() <<= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "ilshift" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_ilshift,self_t,R> operator <<=(self_t const&, R const&) { return detail::operator_<detail::op_ilshift,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_irshift> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() >>= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "irshift" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_irshift,self_t,R> operator >>=(self_t const&, R const&) { return detail::operator_<detail::op_irshift,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_iand> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() &= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "iand" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_iand,self_t,R> operator &=(self_t const&, R const&) { return detail::operator_<detail::op_iand,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_ixor> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() ^= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "ixor" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_ixor,self_t,R> operator ^=(self_t const&, R const&) { return detail::operator_<detail::op_ixor,self_t,R>(); } }
namespace detail { template <> struct operator_l<op_ior> { template <class L, class R> struct apply { typedef typename unwrap_wrapper_<L>::type lhs; typedef typename unwrap_wrapper_<R>::type rhs; static PyObject* execute(back_reference<lhs&> l, rhs const& r) { l.get() |= r; return python::incref(l.source().ptr()); } }; static char const* name() { return "__" "ior" "__"; } }; } namespace self_ns { template <class R> inline detail::operator_<detail::op_ior,self_t,R> operator |=(self_t const&, R const&) { return detail::operator_<detail::op_ior,self_t,R>(); } }
# 344 "/usr/local/include/boost/python/operators.hpp" 3
namespace detail { template <> struct operator_1<op_neg> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(-(x)); } }; static char const* name() { return "__" "neg" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_neg> operator-(self_t const&) { return detail::operator_<detail::op_neg>(); } }
namespace detail { template <> struct operator_1<op_pos> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(+(x)); } }; static char const* name() { return "__" "pos" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_pos> operator+(self_t const&) { return detail::operator_<detail::op_pos>(); } }
namespace detail { template <> struct operator_1<op_abs> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(abs(x)); } }; static char const* name() { return "__" "abs" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_abs> abs(self_t const&) { return detail::operator_<detail::op_abs>(); } }
namespace detail { template <> struct operator_1<op_invert> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(~(x)); } }; static char const* name() { return "__" "invert" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_invert> operator~(self_t const&) { return detail::operator_<detail::op_invert>(); } }



namespace detail { template <> struct operator_1<op_nonzero> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(!!(x)); } }; static char const* name() { return "__" "nonzero" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_nonzero> operator!(self_t const&) { return detail::operator_<detail::op_nonzero>(); } }

namespace detail { template <> struct operator_1<op_int> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(long(x)); } }; static char const* name() { return "__" "int" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_int> int_(self_t const&) { return detail::operator_<detail::op_int>(); } }
namespace detail { template <> struct operator_1<op_long> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(PyLong_FromLong(x)); } }; static char const* name() { return "__" "long" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_long> long_(self_t const&) { return detail::operator_<detail::op_long>(); } }
namespace detail { template <> struct operator_1<op_float> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(double(x)); } }; static char const* name() { return "__" "float" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_float> float_(self_t const&) { return detail::operator_<detail::op_float>(); } }
namespace detail { template <> struct operator_1<op_complex> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(std::complex<double>(x)); } }; static char const* name() { return "__" "complex" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_complex> complex_(self_t const&) { return detail::operator_<detail::op_complex>(); } }
namespace detail { template <> struct operator_1<op_str> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(lexical_cast<std::string>(x)); } }; static char const* name() { return "__" "str" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_str> str(self_t const&) { return detail::operator_<detail::op_str>(); } }
namespace detail { template <> struct operator_1<op_repr> { template <class T> struct apply { typedef typename unwrap_wrapper_<T>::type self_t; static PyObject* execute(self_t& x) { return detail::convert_result(lexical_cast<std::string>(x)); } }; static char const* name() { return "__" "repr" "__"; } }; } namespace self_ns { inline detail::operator_<detail::op_repr> repr(self_t const&) { return detail::operator_<detail::op_repr>(); } }


}}
# 50 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/overloads.hpp" 1 3
# 11 "/usr/local/include/boost/python/overloads.hpp" 3
# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 14 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
# 1 "/usr/local/include/boost/python/detail/defaults_gen.hpp" 1 3
# 14 "/usr/local/include/boost/python/detail/defaults_gen.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repeat_from_to.hpp" 1 3
# 15 "/usr/local/include/boost/python/detail/defaults_gen.hpp" 2 3



# 1 "/usr/local/include/boost/preprocessor/tuple.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/tuple/enum.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/insert.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/insert.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/insert.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/array/insert.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/push_back.hpp" 1 3
# 22 "/usr/local/include/boost/preprocessor/array/push_back.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/detail/get_data.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/array/detail/get_data.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/facilities/is_1.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/facilities/is_1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/facilities/is_empty.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/facilities/is_empty.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/facilities/is_empty_variadic.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/facilities/is_empty_variadic.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/punctuation/is_begin_parens.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/punctuation/is_begin_parens.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/punctuation/detail/is_begin_parens.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/punctuation/is_begin_parens.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/facilities/is_empty_variadic.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/facilities/detail/is_empty.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/facilities/is_empty_variadic.hpp" 2 3
# 21 "/usr/local/include/boost/preprocessor/facilities/is_empty.hpp" 2 3
# 17 "/usr/local/include/boost/preprocessor/facilities/is_1.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/array/detail/get_data.hpp" 2 3
# 23 "/usr/local/include/boost/preprocessor/array/push_back.hpp" 2 3
# 18 "/usr/local/include/boost/preprocessor/array/insert.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/comparison/not_equal.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/array/insert.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/tuple/insert.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/array/to_tuple.hpp" 1 3
# 21 "/usr/local/include/boost/preprocessor/tuple/insert.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/to_array.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/to_array.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/tuple/size.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/to_array.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/tuple/insert.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/pop_back.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/pop_back.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/pop_back.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/array/pop_back.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/repetition/deduce_z.hpp" 1 3
# 15 "/usr/local/include/boost/preprocessor/repetition/deduce_z.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 16 "/usr/local/include/boost/preprocessor/repetition/deduce_z.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/array/pop_back.hpp" 2 3
# 20 "/usr/local/include/boost/preprocessor/tuple/pop_back.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/comparison/greater.hpp" 1 3
# 17 "/usr/local/include/boost/preprocessor/comparison/greater.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/comparison/less.hpp" 1 3
# 18 "/usr/local/include/boost/preprocessor/comparison/greater.hpp" 2 3
# 22 "/usr/local/include/boost/preprocessor/tuple/pop_back.hpp" 2 3
# 23 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/pop_front.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/pop_front.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/pop_front.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/pop_front.hpp" 2 3
# 24 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/push_back.hpp" 1 3
# 25 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/push_front.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/push_front.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/push_front.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/push_front.hpp" 2 3
# 26 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/tuple/remove.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/remove.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/remove.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/remove.hpp" 2 3
# 28 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/replace.hpp" 1 3
# 19 "/usr/local/include/boost/preprocessor/tuple/replace.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/array/replace.hpp" 1 3
# 20 "/usr/local/include/boost/preprocessor/tuple/replace.hpp" 2 3
# 29 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/reverse.hpp" 1 3
# 30 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3


# 1 "/usr/local/include/boost/preprocessor/tuple/to_list.hpp" 1 3
# 33 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 1 "/usr/local/include/boost/preprocessor/tuple/to_seq.hpp" 1 3
# 34 "/usr/local/include/boost/preprocessor/tuple.hpp" 2 3
# 19 "/usr/local/include/boost/python/detail/defaults_gen.hpp" 2 3
# 31 "/usr/local/include/boost/python/detail/defaults_gen.hpp" 3
namespace boost { namespace python {

namespace detail
{


  struct overloads_base
  {
      overloads_base(char const* doc_)
          : m_doc(doc_) {}

      overloads_base(char const* doc_, detail::keyword_range const& kw)
          : m_doc(doc_), m_keywords(kw) {}

      char const* doc_string() const
      {
          return m_doc;
      }

      detail::keyword_range const& keywords() const
      {
          return m_keywords;
      }

   private:
      char const* m_doc;
      detail::keyword_range m_keywords;
  };



  template <class CallPoliciesT, class OverloadsT>
  struct overloads_proxy
      : public overloads_base
  {
      typedef typename OverloadsT::non_void_return_type non_void_return_type;
      typedef typename OverloadsT::void_return_type void_return_type;

      overloads_proxy(
          CallPoliciesT const& policies_
          , char const* doc
          , keyword_range const& kw
          )
          : overloads_base(doc, kw)
            , policies(policies_)
      {}

      CallPoliciesT
      call_policies() const
      {
          return policies;
      }

      CallPoliciesT policies;
  };





  template <class DerivedT>
  struct overloads_common
      : public overloads_base
  {
      overloads_common(char const* doc)
          : overloads_base(doc) {}

      overloads_common(char const* doc, keyword_range const& kw)
          : overloads_base(doc, kw) {}

      default_call_policies
      call_policies() const
      {
          return default_call_policies();
      }

      template <class CallPoliciesT>
      overloads_proxy<CallPoliciesT, DerivedT>
      operator[](CallPoliciesT const& policies) const
      {
          return overloads_proxy<CallPoliciesT, DerivedT>(
              policies, this->doc_string(), this->keywords());
      }
  };

}}}
# 15 "/usr/local/include/boost/python/detail/defaults_def.hpp" 2 3
# 28 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
namespace boost { namespace python {

struct module;

namespace objects
{
  struct class_base;
}

namespace detail
{







  template <class Func, class CallPolicies, class NameSpaceT>
  static void name_space_def(
      NameSpaceT& name_space
      , char const* name
      , Func f
      , keyword_range const& kw
      , CallPolicies const& policies
      , char const* doc
      , objects::class_base*
      )
  {
      typedef typename NameSpaceT::wrapped_type wrapped_type;

      objects::add_to_namespace(
          name_space, name,
          detail::make_keyword_range_function(
              f, policies, kw, get_signature(f, (wrapped_type*)0))
        , doc
      );
  }

  template <class Func, class CallPolicies>
  static void name_space_def(
      object& name_space
      , char const* name
      , Func f
      , keyword_range const& kw
      , CallPolicies const& policies
      , char const* doc
      , ...
      )
  {
      scope within(name_space);

      detail::scope_setattr_doc(
          name
          , detail::make_keyword_range_function(f, policies, kw)
          , doc);
  }


  template <class Func, class CallPolicies, class NameSpaceT>
  static void name_space_def(
      NameSpaceT& name_space
      , char const* name
      , Func f
      , keyword_range const& kw
      , CallPolicies const& policies
      , char const* doc
      , module*
      )
  {
      name_space.def(name, f, policies, doc);
  }
# 125 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
  template <int N>
  struct define_stub_function {};




# 1 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/usr/local/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<0> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_0
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 48 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<1> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_1
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 53 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<2> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_2
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 58 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<3> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_3
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 63 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<4> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_4
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 68 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<5> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_5
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 73 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<6> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_6
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 78 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<7> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_7
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 83 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<8> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_8
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 88 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<9> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_9
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 93 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<10> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_10
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 98 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<11> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_11
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 103 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<12> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_12
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 108 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<13> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_13
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 113 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<14> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_14
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 118 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/usr/local/include/boost/python/detail/defaults_def.hpp" 1 3
# 269 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
template <>
struct define_stub_function<15> {
    template <class StubsT, class CallPolicies, class NameSpaceT>
    static void define(
        char const* name
        , StubsT const&
        , keyword_range const& kw
        , CallPolicies const& policies
        , NameSpaceT& name_space
        , char const* doc)
    {
        detail::name_space_def(
            name_space
            , name
            , &StubsT::func_15
            , kw
            , policies
            , doc
            , &name_space);
    }
};
# 123 "/usr/local/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 132 "/usr/local/include/boost/python/detail/defaults_def.hpp" 2 3
# 157 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
  template <int N>
  struct define_with_defaults_helper {

      template <class StubsT, class CallPolicies, class NameSpaceT>
      static void
      def(
          char const* name,
          StubsT stubs,
          keyword_range kw,
          CallPolicies const& policies,
          NameSpaceT& name_space,
          char const* doc)
      {

          define_stub_function<N>::define(name, stubs, kw, policies, name_space, doc);

          if (kw.second > kw.first)
              --kw.second;


          define_with_defaults_helper<N-1>::def(name, stubs, kw, policies, name_space, doc);
      }
  };

  template <>
  struct define_with_defaults_helper<0> {

      template <class StubsT, class CallPolicies, class NameSpaceT>
      static void
      def(
          char const* name,
          StubsT stubs,
          keyword_range const& kw,
          CallPolicies const& policies,
          NameSpaceT& name_space,
          char const* doc)
      {

          define_stub_function<0>::define(name, stubs, kw, policies, name_space, doc);

      }
  };
# 228 "/usr/local/include/boost/python/detail/defaults_def.hpp" 3
  template <class OverloadsT, class NameSpaceT, class SigT>
  inline void
  define_with_defaults(
      char const* name,
      OverloadsT const& overloads,
      NameSpaceT& name_space,
      SigT const&)
  {
      typedef typename mpl::front<SigT>::type return_type;
      typedef typename OverloadsT::void_return_type void_return_type;
      typedef typename OverloadsT::non_void_return_type non_void_return_type;

      typedef typename mpl::if_c<
          is_same<void, return_type>::value
          , void_return_type
          , non_void_return_type
      >::type stubs_type;

      static_assert((stubs_type::max_args) <= mpl::size<SigT>::value, "(stubs_type::max_args) <= mpl::size<SigT>::value")
                                                           ;

      typedef typename stubs_type::template gen<SigT> gen_type;
      define_with_defaults_helper<stubs_type::n_funcs-1>::def(
          name
          , gen_type()
          , overloads.keywords()
          , overloads.call_policies()
          , name_space
          , overloads.doc_string());
  }

}

}}
# 12 "/usr/local/include/boost/python/overloads.hpp" 2 3
# 52 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/pure_virtual.hpp" 1 3
# 13 "/usr/local/include/boost/python/pure_virtual.hpp" 3
# 1 "/usr/local/include/boost/python/detail/nullary_function_adaptor.hpp" 1 3
# 14 "/usr/local/include/boost/python/detail/nullary_function_adaptor.hpp" 3
namespace boost { namespace python { namespace detail {




template <class NullaryFunction>
struct nullary_function_adaptor
{
    nullary_function_adaptor(NullaryFunction fn)
      : m_fn(fn)
    {}

    void operator()() const { m_fn(); }
# 38 "/usr/local/include/boost/python/detail/nullary_function_adaptor.hpp" 3
# 1 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 1 3
# 37 "/usr/local/include/boost/preprocessor/iteration/detail/local.hpp" 3
        template < class A0> void operator()( A0 const& ) const { m_fn(); }


        template < class A0 , class A1> void operator()( A0 const& , A1 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2> void operator()( A0 const& , A1 const& , A2 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3> void operator()( A0 const& , A1 const& , A2 const& , A3 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& , A9 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& , A9 const& , A10 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& , A9 const& , A10 const& , A11 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& , A9 const& , A10 const& , A11 const& , A12 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& , A9 const& , A10 const& , A11 const& , A12 const& , A13 const& ) const { m_fn(); }


        template < class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14> void operator()( A0 const& , A1 const& , A2 const& , A3 const& , A4 const& , A5 const& , A6 const& , A7 const& , A8 const& , A9 const& , A10 const& , A11 const& , A12 const& , A13 const& , A14 const& ) const { m_fn(); }
# 39 "/usr/local/include/boost/python/detail/nullary_function_adaptor.hpp" 2 3

 private:
    NullaryFunction m_fn;
};

}}}
# 14 "/usr/local/include/boost/python/pure_virtual.hpp" 2 3

namespace boost { namespace python {

namespace detail
{






  void pure_virtual_called();


  template <class S, class T1, class T2>
  struct replace_front2
  {

      typedef typename mpl::push_front<
          typename mpl::push_front<
              typename mpl::pop_front<
                  typename mpl::pop_front<
                      S
                  >::type
              >::type
            , T2
          >::type
        , T1
      >::type type;
  };




  template <class C, class S>
  typename replace_front2<S,void,C&>::type
  error_signature(S)
  {
      typedef typename replace_front2<S,void,C&>::type r;
      return r();
  }
# 65 "/usr/local/include/boost/python/pure_virtual.hpp" 3
  template <class PointerToMemberFunction>
  struct pure_virtual_visitor
    : def_visitor<pure_virtual_visitor<PointerToMemberFunction> >
  {
      pure_virtual_visitor(PointerToMemberFunction pmf)
        : m_pmf(pmf)
      {}

   private:
      friend class python::def_visitor_access;

      template <class C_, class Options>
      void visit(C_& c, char const* name, Options& options) const
      {

          static_assert(!Options::has_default_implementation, "!Options::has_default_implementation");


          c.def(
              name
            , m_pmf
            , options.doc()
            , options.keywords()
            , options.policies()
          );

          typedef typename C_::metadata::held_type held_type;


          c.def(
              name
            , make_function(
                  detail::nullary_function_adaptor<void(*)()>(pure_virtual_called)
                , default_call_policies()
                , detail::error_signature<held_type>(detail::get_signature(m_pmf))
              )
          );
      }

   private:
      PointerToMemberFunction m_pmf;
  };
}







template <class PointerToMemberFunction>
detail::pure_virtual_visitor<PointerToMemberFunction>
pure_virtual(PointerToMemberFunction pmf)
{
    return detail::pure_virtual_visitor<PointerToMemberFunction>(pmf);
}

}}
# 54 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/raw_function.hpp" 1 3
# 18 "/usr/local/include/boost/python/raw_function.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <class F>
  struct raw_dispatcher
  {
      raw_dispatcher(F f) : f(f) {}

      PyObject* operator()(PyObject* args, PyObject* keywords)
      {
          return incref(
              object(
                  f(
                      tuple(borrowed_reference(args))
                    , keywords ? dict(borrowed_reference(keywords)) : dict()
                  )
              ).ptr()
          );
      }

   private:
      F f;
  };

  object make_raw_function(objects::py_function);
}

template <class F>
object raw_function(F f, std::size_t min_args = 0)
{
    return detail::make_raw_function(
        objects::py_function(
            detail::raw_dispatcher<F>(f)
          , mpl::vector1<PyObject*>()
          , min_args
          , (std::numeric_limits<unsigned>::max)()
        )
    );
}

}}
# 56 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/register_ptr_to_python.hpp" 1 3
# 12 "/usr/local/include/boost/python/register_ptr_to_python.hpp" 3
namespace boost { namespace python {

template <class P>
void register_ptr_to_python()
{
    typedef typename boost::python::pointee<P>::type X;
    objects::class_value_wrapper<
        P
      , objects::make_ptr_instance<
            X
          , objects::pointer_holder<P,X>
        >
    >();
}

}}
# 58 "/usr/local/include/boost/python.hpp" 2 3
# 1 "/usr/local/include/boost/python/return_arg.hpp" 1 3
# 25 "/usr/local/include/boost/python/return_arg.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <std::size_t>
  struct return_arg_pos_argument_must_be_positive

  {}

  ;

  struct return_none
  {
      template <class T> struct apply
      {
          struct type
          {
              static bool convertible()
              {
                  return true;
              }

              PyObject *operator()( typename value_arg<T>::type ) const
              {
                  return none();
              }

              PyTypeObject const *get_pytype() const { return converter::expected_pytype_for_arg<T>::get_pytype() ; }

          };
      };
  };
}

template <
    std::size_t arg_pos=1
  , class Base = default_call_policies
>
struct return_arg : Base
{
 private:
    static const bool legal = arg_pos > 0;

 public:
    typedef typename mpl::if_c<
        legal
        , detail::return_none
        , detail::return_arg_pos_argument_must_be_positive<arg_pos>




    >::type result_converter;

    template <class ArgumentPackage>
    static PyObject* postcall(ArgumentPackage const& args, PyObject* result)
    {


        static_assert(arg_pos > 0, "arg_pos > 0");

        result = Base::postcall(args,result);
        if (!result)
            return 0;
        do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0);
        return incref( detail::get(mpl::int_<arg_pos-1>(),args) );
    }

    template <class Sig>
    struct extract_return_type : mpl::at_c<Sig, arg_pos>
    {
    };

};

template <
    class Base = default_call_policies
    >
struct return_self
  : return_arg<1,Base>
{};

}}
# 59 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/return_opaque_pointer.hpp" 1 3
# 18 "/usr/local/include/boost/python/return_opaque_pointer.hpp" 3
namespace boost { namespace python {

namespace detail
{
  template <class Pointee>
  static void opaque_pointee(Pointee const volatile*)
  {
      force_instantiate(opaque<Pointee>::instance);
  }
}

struct return_opaque_pointer
{
    template <class R>
    struct apply
    {
        struct RETURN_OPAQUE_POINTER_EXPECTS_A_POINTER_TYPE; typedef struct RETURN_OPAQUE_POINTER_EXPECTS_A_POINTER_TYPE34 : boost::mpl::assert_ { static boost::mpl::failed ************ (RETURN_OPAQUE_POINTER_EXPECTS_A_POINTER_TYPE::************ assert_arg()) (R) { return 0; } } mpl_assert_arg34; enum { mpl_assertion_in_line_34 = sizeof( boost::mpl::assertion_failed<(is_pointer<R>::value)>( mpl_assert_arg34::assert_arg() ) ) };

        struct type :
          boost::python::to_python_value<
              typename detail::value_arg<R>::type
          >
        {
            type() { detail::opaque_pointee(R()); }
        };
    };
};

}}
# 61 "/usr/local/include/boost/python.hpp" 2 3



# 1 "/usr/local/include/boost/python/slice.hpp" 1 3
# 20 "/usr/local/include/boost/python/slice.hpp" 3
namespace boost { namespace python {

namespace detail
{
  class slice_base : public object
  {
   public:







      object start() const;
      object stop() const;
      object step() const;

   protected:
      explicit slice_base(PyObject*, PyObject*, PyObject*);

      inline explicit slice_base(::boost::python::detail::borrowed_reference p) : object(p) {} inline explicit slice_base(::boost::python::detail::new_reference p) : object(p) {} inline explicit slice_base(::boost::python::detail::new_non_null_reference p) : object(p) {}
  };
}

class slice : public detail::slice_base
{
    typedef detail::slice_base base;
 public:

    slice() : base(0,0,0) {}



    template<typename Integer1, typename Integer2>
    slice( Integer1 start, Integer2 stop)
        : base( object(start).ptr(), object(stop).ptr(), 0 )
    {}

    template<typename Integer1, typename Integer2, typename Integer3>
    slice( Integer1 start, Integer2 stop, Integer3 stride)
        : base( object(start).ptr(), object(stop).ptr(), object(stride).ptr() )
    {}
# 103 "/usr/local/include/boost/python/slice.hpp" 3
    template<typename RandomAccessIterator>
    struct range
    {
        RandomAccessIterator start;
        RandomAccessIterator stop;
        typename iterator_difference<RandomAccessIterator>::type step;
    };

    template<typename RandomAccessIterator>
    slice::range<RandomAccessIterator>
    get_indices( const RandomAccessIterator& begin,
        const RandomAccessIterator& end) const
    {



        slice::range<RandomAccessIterator> ret;

        typedef typename iterator_difference<RandomAccessIterator>::type difference_type;
        difference_type max_dist = std::distance(begin, end);

        object slice_start = this->start();
        object slice_stop = this->stop();
        object slice_step = this->step();


        if (slice_step == object()) {
            ret.step = 1;
        }
        else {
            ret.step = extract<long>( slice_step);
            if (ret.step == 0) {
                PyErr_SetString( PyExc_IndexError, "step size cannot be zero.");
                throw_error_already_set();
            }
        }


        if (slice_start == object()) {
            if (ret.step < 0) {
                ret.start = end;
                --ret.start;
            }
            else
                ret.start = begin;
        }
        else {
            difference_type i = extract<long>( slice_start);
            if (i >= max_dist && ret.step > 0)
                    throw std::invalid_argument( "Zero-length slice");
            if (i >= 0) {
                ret.start = begin;
                using std::min;
                std::advance( ret.start, min (i, max_dist-1));
            }
            else {
                if (i < -max_dist && ret.step < 0)
                    throw std::invalid_argument( "Zero-length slice");
                ret.start = end;

                std::advance( ret.start, (-i < max_dist) ? i : -max_dist );
            }
        }



        if (slice_stop == object()) {
            if (ret.step < 0) {
                ret.stop = begin;
            }
            else {
                ret.stop = end;
                std::advance( ret.stop, -1);
            }
        }
        else {
            difference_type i = extract<long>(slice_stop);

            if (ret.step < 0) {
                if (i+1 >= max_dist || i == -1)
                    throw std::invalid_argument( "Zero-length slice");

                if (i >= 0) {
                    ret.stop = begin;
                    std::advance( ret.stop, i+1);
                }
                else {
                    ret.stop = end;
                    std::advance( ret.stop, (-i < max_dist) ? i : -max_dist);
                }
            }
            else {
                if (i == 0 || -i >= max_dist)
                    throw std::invalid_argument( "Zero-length slice");

                if (i > 0) {
                    ret.stop = begin;
                    std::advance( ret.stop, (std::min)( i-1, max_dist-1));
                }
                else {
                    ret.stop = end;
                    std::advance( ret.stop, i-1);
                }
            }
        }






        typename iterator_difference<RandomAccessIterator>::type final_dist =
            std::distance( ret.start, ret.stop);



        if (final_dist == 0)
            return ret;




        if ((final_dist > 0) != (ret.step > 0))
            throw std::invalid_argument( "Zero-length slice.");





        if (final_dist < 0) {
            difference_type remainder = -final_dist % -ret.step;
            std::advance( ret.stop, remainder);
        }
        else {
            difference_type remainder = final_dist % ret.step;
            std::advance( ret.stop, -remainder);
        }

        return ret;
    }



    template<typename RandomAccessIterator>
    slice::range<RandomAccessIterator>
    get_indicies( const RandomAccessIterator& begin,
        const RandomAccessIterator& end) const
    {
        return get_indices(begin, end);
    }

 public:




    inline explicit slice(::boost::python::detail::borrowed_reference p) : detail::slice_base(p) {} inline explicit slice(::boost::python::detail::new_reference p) : detail::slice_base(p) {} inline explicit slice(::boost::python::detail::new_non_null_reference p) : detail::slice_base(p) {}
};


namespace converter {

template<>
struct object_manager_traits<slice>
    : pytype_object_manager_traits<&PySlice_Type, slice>
{
};

}

} }
# 65 "/usr/local/include/boost/python.hpp" 2 3

# 1 "/usr/local/include/boost/python/stl_iterator.hpp" 1 3
# 10 "/usr/local/include/boost/python/stl_iterator.hpp" 3
# 1 "/usr/local/include/boost/python/object/stl_iterator_core.hpp" 1 3
# 11 "/usr/local/include/boost/python/object/stl_iterator_core.hpp" 3
namespace boost { namespace python { namespace objects {

struct stl_input_iterator_impl
{
    stl_input_iterator_impl();
    stl_input_iterator_impl(boost::python::object const &ob);
    void increment();
    bool equal(stl_input_iterator_impl const &that) const;
    boost::python::handle<> const &current() const;
private:
    boost::python::object it_;
    boost::python::handle<> ob_;
};

}}}
# 11 "/usr/local/include/boost/python/stl_iterator.hpp" 2 3



namespace boost { namespace python
{


template<typename ValueT>
struct stl_input_iterator
  : boost::iterator_facade<
        stl_input_iterator<ValueT>
      , ValueT
      , std::input_iterator_tag
      , ValueT
    >
{
    stl_input_iterator()
      : impl_()
    {
    }


    stl_input_iterator(boost::python::object const &ob)
      : impl_(ob)
    {
    }

private:
    friend class boost::iterator_core_access;

    void increment()
    {
        this->impl_.increment();
    }

    ValueT dereference() const
    {
        return extract<ValueT>(this->impl_.current().get())();
    }

    bool equal(stl_input_iterator<ValueT> const &that) const
    {
        return this->impl_.equal(that.impl_);
    }

    objects::stl_input_iterator_impl impl_;
};

}}
# 67 "/usr/local/include/boost/python.hpp" 2 3
# 7 "/home/maxim/projects/boost-python-examples/01-HelloWorld/hello.cpp" 2

void init_module_hello(); extern "C" __attribute__((__visibility__("default"))) void inithello() { boost::python::detail::init_module( 
# 8 "/home/maxim/projects/boost-python-examples/01-HelloWorld/hello.cpp"
"hello"
# 8 "/home/maxim/projects/boost-python-examples/01-HelloWorld/hello.cpp" 3
,&init_module_hello); } void init_module_hello()

# 9 "/home/maxim/projects/boost-python-examples/01-HelloWorld/hello.cpp"
{
    using namespace boost::python;
    def("greet", greet);
}
